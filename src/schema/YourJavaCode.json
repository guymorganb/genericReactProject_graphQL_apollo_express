{
  "categories": [
    {
      "name": "Arrays",
      "files": [
        {
          "fileName": "declareArray.java",
          "code": "package Arrays;\n\npublic class declareArray {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t\tint name[] = new int[10];\n\t\t// this is an array that holds type 'int' called 'name', which gets enough continuous \n\t\t// memory to hold 10 integers, (40bytes)\n\t\tint[] name2 = new int[10];\n\t\t// can also be written like this\n\t\t// by default empty values are assigned to 0\n\t\t// assign values\n\t\tname[0] = 5;\n\t\tname[5] = 10;\n\t\t// negative indexing doesn't exist\n\t\t\n\t\tchar[] cArray = new char[10];\n\t\tdouble[] dArray = new double[10];\n\t\t\n\t\tSystem.out.println(cArray[1]);\t// prints nothing (equivalent to null) default unassigned values are null\n\t\tSystem.out.println(dArray[3]);\t// prints 0.0 for double, for type long prints 0 for unassigned values\n\t\n\t\tboolean arr[] = new boolean[5];\t// boolean arrays have false as initial values\n\t\tSystem.out.println(arr[3]);\n\t}\n\n}\n"
        },
        {
          "fileName": "takingInput.java",
          "code": "package Arrays;\n\nimport java.util.Scanner;\n\npublic class takingInput {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner s = new Scanner(System.in);\n\t\tint n = s.nextInt();\n\t\tint[] userData = new int[n];\n\t\t\n\t\t// go to each element 1 by \n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tSystem.out.println(\"Enter element at\" + i + \"th index\");\n\t\t\t\n\t\t\tuserData[i] = s.nextInt();\n\t\t}\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tSystem.out.println(userData[i]);\n\t\t}\n\t\t\t\t\n\t}\n\n}\n"
        }
      ]
    },
    {
      "name": "Arrays2D",
      "files": [
        {
          "fileName": "Basics.java",
          "code": "package Arrays2D;\n\npublic class Basics {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\t\n\t\tint[][] arr2d = new int [3][4];\n\t\t\n\t\t//System.out.println(arr2d[1][2]);\n\t\t\n\t\tarr2d[2][1] = 12;\n\t\t\n\t\tSystem.out.println(arr2d[2][1]);\n\t\t\n\t\tint[][] ar2d = {{1,2,3,4},{5,6,7,8},{9,10,11,12}};\n\t\tSystem.out.println(ar2d.length);  // number of rows\n\t\tSystem.out.println(ar2d[0].length);  // number of columns\n\t}\n\n}\n"
        },
        {
          "fileName": "functions2Darrays.java",
          "code": "package Arrays2D;\n\nimport java.util.Scanner;\n\npublic class functions2Darrays {\n\t\n\tpublic static int[][] takeInput(){\n\t\tScanner s = new Scanner(System.in);\n\t\tSystem.out.println(\"Enter the number of rows\");\n\t\t\n\t\tint rows = s.nextInt();\n\t\tSystem.out.println(\"Enter number of columns\");\n\t\tint cols = s.nextInt();\n\t\t\n\t\tint[][] arr = new int[rows][cols];\n\t\t\n\t\tfor(int i=0; i < rows; i ++) {\n\t\t\tfor(int j=0; j<cols; j++) {\n\t\t\t\tSystem.out.println(\"Enter the element at \" + i + \" row\" + j + \"column\");\n\t\t\t\tarr[i][j]=s.nextInt();\n\t\t\t}\n\t\t}return arr;\n\t}\n\tpublic static void print2darray(int[][] array) {\n\t\tint rows = array.length;\n\t\tint cols = array[0].length;\n\t\tfor(int i = 0; i < rows; i++) {\n\t\t\tfor(int j = 0; j < cols; j++) {\n\t\t\t\tSystem.out.print(array[i][j] +  \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\t\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tint[][] input = takeInput();\n\t\tprint2darray(input);\n\t}\n\n}\n"
        },
        {
          "fileName": "jaggedArrays.java",
          "code": "package Arrays2D;\n\npublic class jaggedArrays {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tint[][] arr = new int[4][];\n\t\t\n\t\tfor(int i = 0; i < arr.length; i++) {\n\t\t\tarr[i] = new int[i+2];\n\t\t}\n\t\tfor(int i = 0; i < arr.length; i++) {\n\t\t\tfor(int j = 0; j < arr[i].length; j++) {\n\t\t\t\tSystem.out.print(arr[i][j] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n}\n"
        },
        {
          "fileName": "largestColumnSum.java",
          "code": "package Arrays2D;\n\nimport java.util.Scanner;\n\npublic class largestColumnSum {\n\tpublic static int[][] takeInput(){\n\t\tScanner s = new Scanner(System.in);\n\t\tSystem.out.println(\"Enter the number of rows\");\n\t\t\n\t\tint rows = s.nextInt();\n\t\tSystem.out.println(\"Enter number of columns\");\n\t\tint cols = s.nextInt();\n\t\t\n\t\tint[][] arr = new int[rows][cols];\n\t\t\n\t\tfor(int i=0; i < rows; i ++) {\n\t\t\tfor(int j=0; j<cols; j++) {\n\t\t\t\tSystem.out.println(\"Enter the element at \" + i + \" row\" + j + \"column\");\n\t\t\t\tarr[i][j]=s.nextInt();\n\t\t\t}\n\t\t}return arr;\n\t}\n\tpublic static int largestColSum(int[][] arr) {\n\t\tint rows = arr.length;\n\t\tint cols = arr[0].length;\n\t\tint largest = Integer.MIN_VALUE;\n\t\tfor(int i = 0; i < cols; i++) {\n\t\t\tint sum = 0;\n\t\t\tfor(int j = 0; j < rows; j++) {\n\t\t\t\tsum = sum + arr[j][i];\n\t\t\t}\n\t\t\tif(sum > largest) {\n\t\t\t\tlargest = sum;\n\t\t\t}\n\t\t}return largest;\n\t\t\n\t}\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tint[][] input = takeInput();\n\t\tint largestCol = largestColSum(input);\n\t\tSystem.out.println(largestCol);\n\t}\n\n}\n"
        },
        {
          "fileName": "practice.java",
          "code": "package Arrays2D;\n\npublic class practice {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n//\t\t write out a 2D array like this\n\t\tint[][] arr = { { 1, 2 }, { 3, 4 } }; \n\t\t    System.out.println(arr[0][0]+arr[1][1]); \n\t}\n\n}\n"
        },
        {
          "fileName": "printMatrixSpiral.java",
          "code": "package Arrays2D;\n\nimport java.util.Scanner;\n\npublic class printMatrixSpiral {\n\tpublic static int[][] takeInput(){\n\t\tScanner s = new Scanner(System.in);\n\t\tSystem.out.println(\"Enter the number of rows\");\n\t\t\n\t\tint rows = s.nextInt();\n\t\tSystem.out.println(\"Enter number of columns\");\n\t\tint cols = s.nextInt();\n\t\t\n\t\tint[][] arr = new int[rows][cols];\n\t\t\n\t\tfor(int i=0; i < rows; i ++) {\n\t\t\tfor(int j=0; j<cols; j++) {\n\t\t\t\tSystem.out.println(\"Enter the element at \" + i + \" row\" + j + \"column\");\n\t\t\t\tarr[i][j]=s.nextInt();\n\t\t\t}\n\t\t}return arr;\n\t}\n\tpublic static void printMatrixSpiral(int[][] arr) {\n\t\t// we are printing clockwise in a spiral\n\t\t//  this is for a square array\n\t\tint nRows = arr.length;\n\t\tint mCols = arr[0].length;\n\t\tint total = nRows*mCols;\n\t\t// set 4 bounds upper left row, upper left column, upper right column, lower left row// values are printed moving clockwise around\n\t\tint upperRow = 0;\n\t\tint lowerRow = nRows-1;\n\t\tint LeftColumn = 0;\n\t\tint RightColumn = mCols-1;\n\t\t\n\t\tint count = 0;\n\t\twhile(count < total) {\n\t\t\t// left -> right\n\t\t\tfor(int i = LeftColumn; count<total && i <= RightColumn;i++) {\n\t\t\t\tSystem.out.print(arr[upperRow][i] + \" \");\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tupperRow++;\n\t\t\t\n\t\t\t// top -> bottom\n\t\t\tfor(int i = upperRow; count < total && i <= lowerRow; i++) {\n\t\t\t\tSystem.out.print(arr[i][RightColumn] + \" \");\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tRightColumn--;\n\t\t\t\n\t\t\t// right -> left\n\t\t\tfor(int i = RightColumn; count < total && i >= LeftColumn; i--) {\n\t\t\t\tSystem.out.print(arr[lowerRow][i] + \" \");\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tlowerRow--;\n\t\t\t\n\t\t\t// bottom -> top\n\t\t\tfor(int i = lowerRow; count<total && i >= upperRow; i--) {\n\t\t\t\tSystem.out.print(arr[i][LeftColumn] + \" \");\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tLeftColumn++;\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tint[][] input = takeInput();\n\t\tprintMatrixSpiral(input);\n\t}\n\n}\n"
        },
        {
          "fileName": "printRowWise.java",
          "code": "package Arrays2D;\n\nimport java.util.Scanner;\nimport java.util.Arrays;\npublic class printRowWise {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner s = new Scanner(System.in);\n\t\tSystem.out.println(\"Enter the number of rows\");\n\t\t\n\t\tint rowss = s.nextInt();\n\t\tSystem.out.println(\"Enter number of columns\");\n\t\tint cols = s.nextInt();\n\t\t\n\t\tint[][] arr = new int[rowss][cols];\n\t\t\n\t\tfor(int i=0; i < rowss; i ++) {\n\t\t\tfor(int j=0; j<cols; j++) {\n\t\t\t\tSystem.out.println(\"Enter the element at row \" + i + \" column \" + j);\n\t\t\t\tarr[i][j]=s.nextInt();\n\t\t\t}\n\t\t}\n//\t\ttraverse row-wise\n\t\tint index = 0;\n\t\tint row = arr.length;\t\t // reference to the 2 dimensional, array number of rows\n\t\tint columns = arr[0].length; // reference to 1 dimensional array inside, number of columns\n\t\tint[] result = new int[row * columns];\n\n\t\tfor (int i = 0; i < row; i++) {\n\t\t    for (int j = 0; j < columns; j++) {\n\t\t        result[index] = arr[i][j];\n\t\t        System.out.print(result[index] + \" \");\n\t\t        index++;\n\t\t    }\n\t\t}System.out.print(Arrays.toString(result));\n\t\t\n\t\t\n//\t\ttraverse column-wise\n\t\tint ind = 0;\n\t\tint col = arr.length;\t\t// reference to the 2 dimensional array, number of rows\n\t\tint rows = arr[0].length; \t// reference to 1 dimensional array inside, number of columns\n\t\tint[] res = new int[rows * col];\n\n\t\tfor (int i = 0; i < rows; i++) {\n\t\t    for (int j = 0; j < col; j++) {\n\t\t        res[ind] = arr[j][i];\n\t\t        ind++;\n\t\t    }\n\t\t}\n\n\t\tSystem.out.print(Arrays.toString(res));\n\t}\n\n}\n"
        },
        {
          "fileName": "rowWiseSum.java",
          "code": "package Arrays2D;\n\npublic class rowWiseSum {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\t\n\t\tint[][] mat = {{1, 2, 3, 4}, {5, 6, 7, 8}}; \n\t\tint rows = mat.length;\n\t\tint cols = mat[0].length;\n\t\t\n\t\tfor(int i = 0; i< rows; i++){\n\t\t\tint sum = 0;\n\t\t\tfor(int j = 0; j< cols; j++){\n\t\t\t\tsum += mat[i][j];\n\t\t\t}\n\t\t\tSystem.out.print(sum + \" \");\n\t\t\t\n\t\t}\n\t}\n\n}\n"
        },
        {
          "fileName": "takingInput.java",
          "code": "package Arrays2D;\n\nimport java.util.Scanner;\n\npublic class takingInput {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner s = new Scanner(System.in);\n\t\tSystem.out.println(\"Enter the number of rows\");\n\t\t\n\t\tint rows = s.nextInt();\n\t\tSystem.out.println(\"Enter number of columns\");\n\t\tint cols = s.nextInt();\n\t\t\n\t\tint[][] arr = new int[rows][cols];\n\t\t\n\t\tfor(int i=0; i < rows; i ++) {\n\t\t\tfor(int j=0; j<cols; j++) {\n\t\t\t\tSystem.out.println(\"Enter the element at \" + i + \" row\" + j + \"column\");\n\t\t\t\tarr[i][j]=s.nextInt();\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i <rows; i++) {\n\t\t\tfor(int j=0; j<cols; j++) {\n\t\t\t\tSystem.out.print(arr[i][j]+ \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n}\n"
        },
        {
          "fileName": "test.java",
          "code": "package Arrays2D;\n\npublic class test {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n"
        }
      ]
    },
    {
      "name": "BinarySearchTrees",
      "files": [
        {
          "fileName": "BSTClass.java",
          "code": "package BinarySearchTrees;\n\nimport BinaryTrees.BinaryTreeNode;\n\npublic class BSTClass {\n\t\n\tprivate BinaryTreeNode<Integer> root;\n\tprivate int size;\n//////////////element isPresent/////////////////////////////////\t\n\t// we use a helper function so we dont have to search the BST in an iterative manner\n\t// this function is static because it operates independently and only works on the node which the user passes it, not the entire BST\n\tprivate static boolean isPresentHelper(BinaryTreeNode<Integer> RootNode, int x) {\n\t\tif(RootNode == null) {\n\t\t\treturn false;\n\t\t}\n\t\tif(RootNode.data == x) {\n\t\t\treturn true;\n\t\t}\n\t\tif(x < RootNode.data) {\n\t\t\t// call left side\n\t\t\treturn isPresentHelper(RootNode.left, x);\n\t\t}else {\n\t\t\t// call on the right side\n\t\t\treturn isPresentHelper(RootNode.right, x);\n\t\t}\n\t}\n\t\n\tpublic boolean isPresent(int x) {\n\t\treturn isPresentHelper(root, x);\n\t\t\n\t}\n//////////////insert/////////////////////////////////\n\tprivate static BinaryTreeNode<Integer> InsertHelper(BinaryTreeNode<Integer> node, int x){\n\t\t// if there is no root node create one and set it equal to x\n\t\tif(node == null) {\n\t\t\tBinaryTreeNode<Integer> newRoot = new BinaryTreeNode<Integer>(x);\n\t\t\treturn newRoot;\n\t\t}\n\t\t// if root node is present but x is greater than root, x must be inserted on the right side of BST \n\t\tif(x >= node.data) {\n\t\t\tBinaryTreeNode<Integer> newRoot = InsertHelper(node.right, x);\n\t\t\tnode.right = newRoot;\n\t\t}else {\n\t\t\t// if x is not greater than root.data must insert on the left side of BST\n\t\t\tBinaryTreeNode<Integer> newRoot = InsertHelper(node.left, x);\n\t\t\tnode.left = newRoot;\n\t\t}\n\t\treturn node;\n\t}\n\t\n\tpublic void insert(int x) {\n\t\t// update the root using the InsertHelper function\n\t\troot = InsertHelper(root, x);\n\t\tsize++;\n\t\t\n\t}\n//////////////delete: requires many functions//////////////////////////////////\n\t// find the minimum on the right\n\tprivate static int minimum(BinaryTreeNode<Integer> root) {\n\t\tif(root == null) {\n\t\t\treturn Integer.MAX_VALUE;\n\t\t}\n\t\t\n\t\tint minimumLeft = minimum(root.left);\n\t\tint minimumRight = minimum(root.right);\n\t\treturn Math.min(root.data, Math.min(minimumLeft, minimumRight));\n\t}\n\t// we want to return if the element was deleted and the new root\n\tprivate static class BSTdeleteReturn{\n\t\tboolean elementDeleted;\n\t\tBinaryTreeNode<Integer> newRoot;\n\t\t// constructor function\n\t\tpublic BSTdeleteReturn(BinaryTreeNode<Integer> newRoot, boolean elementDeleted) {\n\t\t\tthis.newRoot = newRoot;\n\t\t\tthis.elementDeleted = elementDeleted;\n\t\t}\n\n\t}\n\t\n\tprivate static BSTdeleteReturn deleteDataHelper(BinaryTreeNode<Integer> root, int x) {\n\t\tif(root == null) {\n\t\t\treturn new BSTdeleteReturn(null, false);\n\t\t}\n\t\t\n\t\tif(root.data < x) {\n\t\t\tBSTdeleteReturn outputRight = deleteDataHelper(root.right, x);\n\t\t\troot.right = outputRight.newRoot;\n\t\t\toutputRight.newRoot = root;\n\t\t\treturn outputRight;\n\t\t}\n\t\t\n\t\tif(root.data > x) {\n\t\t\tBSTdeleteReturn outputLeft = deleteDataHelper(root.left, x);\n\t\t\troot.left = outputLeft.newRoot;\n\t\t\toutputLeft.newRoot = root;\n\t\t\treturn outputLeft;\n\t\t}\n\t\t// 0 children\n\t\tif(root.left == null && root.right == null) {\n\t\t\treturn new BSTdeleteReturn(null, true);\n\t\t}\n\t\t// only left child\n\t\tif(root.left != null && root.right == null) {\n\t\t\treturn new BSTdeleteReturn(root.left, true);\n\t\t}\n\t\t\n\t\t// only right child\n\t\tif(root.left == null && root.right != null) {\n\t\t\treturn new BSTdeleteReturn(root.right, true);\n\t\t}\n\t\t\n\t\t// both children are present, find the minimum on the right, and delete x, then set the root to the minimum\n\t\tint rightMin = minimum(root.right);\n\t\troot.data = rightMin;\n\t\tBSTdeleteReturn outputRight = deleteDataHelper(root.right, rightMin);\n\t\troot.right = outputRight.newRoot;\n\t\treturn new BSTdeleteReturn(root, true);\n\t}\n\t\n\tpublic boolean deleteData(int x) {\n\t\tBSTdeleteReturn output = deleteDataHelper(root, x);\n\t\troot = output.newRoot;\n\t\tif(output.elementDeleted) {\n\t\t\tsize--;\n\t\t}\n\t\treturn output.elementDeleted;\n\t}\n//////////////size/////////////////////////////////\n\tpublic int size() {\n\t\treturn size;\n\t}\n//////////////print/////////////////////////////////\n\tprivate static void printTreeHelper(BinaryTreeNode<Integer> rootNode) {\n\t\tif(rootNode == null) {\n\t\t\treturn;\n\t\t}\n\t\tSystem.out.print(rootNode.data + \": \");\n\t\t\n\t\tif(rootNode.left != null) {\n\t\t\tSystem.out.print(\"L\"+ rootNode.left.data + \", \");\n\t\t}\n\t\tif(rootNode.right != null) {\n\t\t\tSystem.out.print(\"R\"+ rootNode.right.data + \", \");\n\t\t}\n\t\n\t\tSystem.out.println();\n\t\t\n\t\tprintTreeHelper(rootNode.left);\n\t\tprintTreeHelper(rootNode.right);\n\t}\n\t\n\tpublic void printTree() {\n\t\tprintTreeHelper(root);\n\t}\n//////////////height/////////////////////////////////\n\tprivate static int heightHelper(BinaryTreeNode<Integer> node) {\n        if (node == null) {\n            return 0;\n        }\n\n        int leftHeight = heightHelper(node.left);\n        int rightHeight = heightHelper(node.right);\n\n        return Math.max(leftHeight, rightHeight) + 1;\n    }\n\n    public int height() {\n        return heightHelper(root);\n    }\n\t\n}\n"
        },
        {
          "fileName": "BSTClassUse.java",
          "code": "package BinarySearchTrees;\n\npublic class BSTClassUse {\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tBSTClass tree = new BSTClass();\n\t\t\n\t\ttree.insert(5);\n\t\ttree.insert(2);\n\t\ttree.insert(7);\n\t\ttree.insert(1);\n\t\ttree.insert(3);\n\t\ttree.insert(6);\n\t\ttree.insert(8);\n\t\t\n\t\ttree.printTree();\n\t\tSystem.out.println(tree.height());\n\t\tSystem.out.println();\n\t\t\n\t\tSystem.out.println(tree.isPresent(5));\n\t\ttree.deleteData(5);\t// removes node and replaces it so tree stays BST\n\t\tSystem.out.println(tree.isPresent(5));\n\t\ttree.printTree();\n\t\tSystem.out.println();\n\t\t\n\t\ttree.deleteData(2);\n\t\ttree.printTree();\n\t\tSystem.out.println();\n\t\ttree.deleteData(6);\n\t\ttree.deleteData(1);\n\t\ttree.printTree();\n\t\t//System.out.println(tree.size());\n\t\tSystem.out.println(tree.height());\n\t}\n\n}\n"
        },
        {
          "fileName": "LinkedListFromBinaryTreeLevelWise.java",
          "code": "package BinarySearchTrees;\n\nimport java.util.*;\n\npublic class LinkedListFromBinaryTreeLevelWise {\n\n    // BinaryTreeNode class\n    static class BinaryTreeNode<T> {\n        T data;\n        BinaryTreeNode<T> left;\n        BinaryTreeNode<T> right;\n\n        public BinaryTreeNode(T data) {\n            this.data = data;\n        }\n    }\n\n    // LinkedListNode class\n    static class LinkedListNode<T> {\n        T data;\n        LinkedListNode<T> next;\n\n        public LinkedListNode(T data) {\n            this.data = data;\n        }\n    }\n\n    public static ArrayList<LinkedListNode<Integer>> constructLinkedListForEachLevel(BinaryTreeNode<Integer> root) {\n        // Initialize an ArrayList to hold the head of the linked lists for each level\n        ArrayList<LinkedListNode<Integer>> result = new ArrayList<>();\n\n        if (root == null) {\n            return result;\n        }\n\n        // Initialize a queue to hold the nodes for level order traversal\n        Queue<BinaryTreeNode<Integer>> queue = new LinkedList<>();\n        queue.add(root);\n\n        while (!queue.isEmpty()) {\n            int levelSize = queue.size();\n            LinkedListNode<Integer> levelHead = null;\n            LinkedListNode<Integer> previousNode = null;\n\n            // Iterate through the current level\n            for (int i = 0; i < levelSize; i++) {\n                BinaryTreeNode<Integer> currentNode = queue.poll();\n\n                // Create a new linked list node for this element\n                LinkedListNode<Integer> newNode = new LinkedListNode<>(currentNode.data);\n\n                // Link the previous node to the current node\n                if (previousNode != null) {\n                    previousNode.next = newNode;\n                } else {\n                    // If it's the first node of this level, set the head\n                    levelHead = newNode;\n                }\n\n                // Move to the next linked list node\n                previousNode = newNode;\n\n                // Add left and right children to the queue\n                if (currentNode.left != null) {\n                    queue.add(currentNode.left);\n                }\n                if (currentNode.right != null) {\n                    queue.add(currentNode.right);\n                }\n            }\n\n            // Add the head of the linked list for this level to the result\n            result.add(levelHead);\n        }\n\n        return result;\n    }\n}\n"
        },
        {
          "fileName": "checkIfBST.java",
          "code": "package BinarySearchTrees;\n\nimport BinaryTrees.BinaryTreeNode;\n\npublic class checkIfBST {\n\t\n\tpublic static int minimum(BinaryTreeNode<Integer> root) {\n\t\tif(root == null) {\n\t\t\t// if its an empty set return the maximum sized minimum value\n\t\t\treturn Integer.MAX_VALUE;\n\t\t}\n\t\tint leftMin = minimum(root.left);\n\t\tint rightMin = minimum(root.right);\n\t\t\n\t\treturn Math.min(root.data, Math.min(leftMin,  rightMin));\n\t\t\n\t}\n\t\n\tpublic static int maximum(BinaryTreeNode<Integer> root) {\n\t\tif(root == null) {\n\t\t\treturn Integer.MIN_VALUE;\n\t\t}\n\t\tint largestLeft = maximum(root.left);\n\t\tint largestRight = maximum(root.right);\n\t\treturn Math.max(root.data, Math.max(largestLeft, largestRight));\n\t}\n\t\n\t// check if Binary Tree is a Binary Search tree\n\tpublic static boolean isBST(BinaryTreeNode<Integer> root) {\n\t\tif(root == null) {\n\t\t\treturn true;\n\t\t}\n\t\t// root has to be larger than everything on the left side making a function for this\n\t\tint leftMax = maximum(root.left);\n\t\tif(leftMax >= root.data) {\n\t\t\treturn false;\n\t\t}\n\t\t// root must be smaller than everything on the right side for Tree to be BinarySearchTree\n\t\tint rightMin = minimum(root.right);\n\t\tif(rightMin < root.data) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tboolean isLeftBST = isBST(root.left);\n\t\tboolean isRightBST = isBST(root.right);\n\t\treturn isLeftBST && isRightBST;\n\t\t\n\t}\n\t// to improve the speed of the isBST function we need to create a class(isBSTReturn) which will return min/max/isBST so we only\n\t// need to make one call to each side of the binary tree to determine if it s a BST\n\tpublic static isBSTReturn isBSTBetter(BinaryTreeNode<Integer> root) {\n\t\tif(root == null) {\n\t\t\tisBSTReturn ans = new isBSTReturn(Integer.MAX_VALUE, Integer.MIN_VALUE, true);\n\t\t\treturn ans;\n\t\t}\n\t\n\t\tisBSTReturn leftSide = isBSTBetter(root.left);\n\t\tisBSTReturn rightSide = isBSTBetter(root.right);\n\t\t\n\t\t// finding the minimum and maximum value between the top level root/leftSide/rightSide \n\t\tint min = Math.min(root.data, Math.min(leftSide.min, rightSide.min));\n\t\tint max = Math.max(root.data, Math.max(leftSide.max, rightSide.max));\n\t\t\n\t\t// no we need to find if overall is the tree a BST\n\t\tboolean isBST = true;\n\t\tif(leftSide.max >= root.data) {\n\t\t\t// violation of BST rules\n\t\t\tisBST = false;\n\t\t}\n\t\tif(rightSide.min <= root.data) {\n\t\t\t// violates isBST rules\n\t\t\tisBST = false;\n\t\t}\n\t\tif(!leftSide.isBst) {\n\t\t\tisBST = false;\n\t\t}\n\t\tif(!rightSide.isBst) {\n\t\t\tisBST = false;\n\t\t}\n\t\tisBSTReturn ans = new isBSTReturn(min, max, isBST);\n\t\treturn ans;\n\t \n\t}\n\t\n\t// another way to solve isBST\n\tpublic static boolean isBST2(BinaryTreeNode<Integer> root, int minRange, int maxRange) {\n\t\tif(root == null) {\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tif(root.data < minRange || root.data > maxRange) {\n\t\t\treturn false;\n\t\t}\n\t\t// max on left side must be smaller than roots data\n\t\tboolean isLeftWithinRange = isBST2(root.left, minRange, root.data - 1);\n\t\t// max on right side must be larger than roots data\n\t\tboolean isRightWithinRange = isBST2(root.right, root.data, maxRange);\n\t\treturn isLeftWithinRange && isRightWithinRange;\n\t\t\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\n\t}\n\n}\n"
        },
        {
          "fileName": "convertBSTtoLinkedList.java",
          "code": "package BinarySearchTrees;\n\nimport BinaryTrees.BinaryTreeNode;\n\nimport linkedLists.LinkedListNodeClass;\n\npublic class convertBSTtoLinkedList {\n\n\tprivate static LinkedListNodeClass<Integer> head, tail;\n\n    private static void convertToLinkedList(BinaryTreeNode<Integer> root) {\n        if (root == null) {\n            return;\n        }\n\n        convertToLinkedList(root.left);\n\n        LinkedListNodeClass<Integer> newNode = new LinkedListNodeClass<>(root.data);\n        if (head == null) {\n            head = newNode;\n            tail = newNode;\n        } else {\n            tail.next = newNode;\n            tail = newNode;\n        }\n\n        convertToLinkedList(root.right);\n    }\n    \n    public static LinkedListNodeClass<Integer> constructLinkedList(BinaryTreeNode<Integer> root) {\n        head = null;\n        tail = null;\n        convertToLinkedList(root);\n        return head;\n    }\n    \n\tpublic static void main(String[] args) {\n\t\t\n\t\t\n\t\t\n\t}\n\n}\n"
        },
        {
          "fileName": "createBSTFromSortedArray.java",
          "code": "package BinarySearchTrees;\n\nimport BinaryTrees.BinaryTreeNode;\n\npublic class createBSTFromSortedArray {\n\n//\tGiven a sorted integer array A of size n, which contains all unique elements. You need to construct a balanced BST from this input array. Return the root of constructed BST.\n//\tNote: If array size is even, take first mid as root.\n\t\n\t // Helper method that constructs BST recursively\n    private static BinaryTreeNode<Integer> ToBST(int[] arr, int start, int end){\n        // Base case: if start index is more than end index, it means we have traversed all elements in this section of the array\n        if(start > end) {\n            return null;\n        }\n        \n        // Calculate the middle index\n        int mid = start + (end - start) / 2;\n\n        // Create a new node with the middle element\n        BinaryTreeNode<Integer> root = new BinaryTreeNode<>(arr[mid]);\n\n        // Construct the left subtree by recursively finding the middle element in the left half of the current section of the array\n        root.left = ToBST(arr, start, mid - 1);\n\n        // Construct the right subtree by recursively finding the middle element in the right half of the current section of the array\n        root.right = ToBST(arr, mid + 1, end);\n\n        // Return the root node of the constructed BST\n        return root;\n    }\n\n    // Method that initiates the recursive BST construction\n    public static BinaryTreeNode<Integer> SortedArrayToBST(int[] arr, int n){\n        // Call the helper method with the full array (from index 0 to n-1)\n        return ToBST(arr, 0, n - 1);\n    }\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tint[] arr = {1,2,3,4,5,6};\n\t\t\n\t}\n\n}\n"
        },
        {
          "fileName": "isBSTReturn.java",
          "code": "package BinarySearchTrees;\n\npublic class isBSTReturn {\n\t int min;\n\t int max;\n\t boolean isBst;\n\t \n\t public isBSTReturn(int min, int max, boolean isBST) {\n\t\t this.min = min;\n\t\t this.max = max;\n\t\t this.isBst = isBST;\n\t }\n}\n"
        },
        {
          "fileName": "largestBSTsubtree.java",
          "code": "package BinarySearchTrees;\n\nimport BinaryTrees.BinaryTreeNode;\n// Given a Binary tree, find the largest BST subtree. \n// That is, you need to find the BST with maximum height in the given binary tree. You have to return the height of largest BST.\npublic class largestBSTsubtree {\n\tstatic class BSTInfo {\n        boolean isBST;\n        int min;\n        int max;\n        int size; // height of the tree\n\n        public BSTInfo() {\n            min = Integer.MAX_VALUE;\n            max = Integer.MIN_VALUE;\n            isBST = true;\n            size = 0;\n        }\n    }\n\n    public static int largestBSTSubtree(BinaryTreeNode<Integer> root) {\n        return largestBSTHelper(root).size;\n    }\n\n    public static BSTInfo largestBSTHelper(BinaryTreeNode<Integer> root) {\n        if (root == null) {\n            return new BSTInfo(); // base case\n        }\n\n        BSTInfo leftInfo = largestBSTHelper(root.left);\n        BSTInfo rightInfo = largestBSTHelper(root.right);\n\n        BSTInfo current = new BSTInfo();\n\n        // If the subtree rooted at this node is not a BST, then this subtree cannot be a BST\n        if (!leftInfo.isBST || !rightInfo.isBST || (root.data <= leftInfo.max) || (root.data > rightInfo.min)) {\n            current.isBST = false;\n            current.size = Math.max(leftInfo.size, rightInfo.size); // height of the largest BST in the left or right subtree\n            return current;\n        }\n\n        // If the subtree rooted at this node is a BST\n        current.isBST = true;\n        current.size = Math.max(leftInfo.size, rightInfo.size) + 1; // height of this subtree\n        current.min = root.left != null ? leftInfo.min : root.data;\n        current.max = root.right != null ? rightInfo.max : root.data;\n\n        return current;\n    }\n}\n"
        },
        {
          "fileName": "lowestCommonAncestor.java",
          "code": "package BinarySearchTrees;\n\npublic class lowestCommonAncestor {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n"
        },
        {
          "fileName": "rootToNodePathBST.java",
          "code": "package BinarySearchTrees;\n\nimport java.util.ArrayList;\n\nimport BinaryTrees.BinaryTreeNode;\n\npublic class rootToNodePathBST {\n\t// search for a value in a binary tree and return the path\n\tpublic static ArrayList<Integer> nodeToRootPath(BinaryTreeNode<Integer> root, int x){\n\t\tif(root == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif(root.data == x) {\n\t\t\t// if x is found create an array list and add the path to it.\n\t\t\tArrayList<Integer> path = new ArrayList<>();\n\t\t\tpath.add(x);\n\t\t\treturn path;\n\t\t}\n\t\t// search for x value on the left side of the binary tree\n\t\tArrayList<Integer> leftOutput = nodeToRootPath(root.left, x);\n\t\tif(leftOutput != null) {\n\t\t\tleftOutput.add(root.data);\n\t\t\treturn leftOutput;\n\t\t}\n\t\t// search for x value on the right side and add to the array list\n\t\tArrayList<Integer> rightOutput = nodeToRootPath(root.right, x);\n\t\tif(rightOutput != null) {\n\t\t\t// if right output is not null we've found it\n\t\t\trightOutput.add(root.data);\n\t\t\treturn rightOutput;\n\t\t}\n\t\t// if we haven't found x anywhere return null\n\t\treturn null;\n\t\t\n\t}\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n"
        },
        {
          "fileName": "searchBinarySearchTree.java",
          "code": "package BinarySearchTrees;\n\nimport BinaryTrees.BinaryTreeNode;\n\npublic class searchBinarySearchTree {\n\n\tpublic static boolean searchBST(BinaryTreeNode<Integer> root, int k) {\n\t\tif(root == null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (root.data == k) {\n\t        return true; // Element k found in the current node\n\t    } else if (root.data > k) {\n\t        return searchBST(root.left, k); // Search in the left subtree\n\t    } else {\n\t        return searchBST(root.right, k); // Search in the right subtree\n\t    }\n\t}\n\t\n\tpublic static void findAndPrintElementsBetweenK1andK2(BinaryTreeNode<Integer> root, int k1, int k2) {\n\t    if (root == null) {\n\t        return;\n\t    }\n\n\t    // If the current node's data is greater than k1, search the left subtree\n\t    if (root.data > k1) {\n\t        findAndPrintElementsBetweenK1andK2(root.left, k1, k2);\n\t    }\n\n\t    // If the current node's data is between k1 and k2, print the node's data\n\t    if (root.data >= k1 && root.data <= k2) {\n\t        System.out.print(root.data + \" \");\n\t    }\n\n\t    // If the current node's data is less than k2, search the right subtree\n\t    if (root.data < k2) {\n\t        findAndPrintElementsBetweenK1andK2(root.right, k1, k2);\n\t    }\n\t}\n\t\n\t// Check if tree is Binary search tree///////////////////////////////////\n\t // Helper class to store the min and max values\n    private static class MinMax {\n        int min;\n        int max;\n        boolean isBST;\n    }\n\n    public static boolean isBST(BinaryTreeNode<Integer> root) {\n        return isBSTHelper(root).isBST;\n    }\n\n    private static MinMax isBSTHelper(BinaryTreeNode<Integer> node) {\n        // An empty tree is BST\n        if (node == null) {\n            MinMax m = new MinMax();\n            m.min = Integer.MAX_VALUE;\n            m.max = Integer.MIN_VALUE;\n            m.isBST = true;\n            return m;\n        }\n\n        // Recursively check left and right subtrees\n        MinMax left = isBSTHelper(node.left);\n        MinMax right = isBSTHelper(node.right);\n\n        MinMax m = new MinMax();\n        m.isBST = (left.isBST && right.isBST && (node.data >= left.max && node.data < right.min));\n        m.min = Math.min(node.data, Math.min(left.min, right.min));\n        m.max = Math.max(node.data, Math.max(left.max, right.max));\n        \n        return m;\n    }\n    \t///////////////////////////////////\n    \n\tpublic static void main(String[] args) {\n\t\t// create a Binary search tree(all elements to left of root on main tree and subtrees are less than root, all elements to the right side are greater \n\t\t// root\t\t\n\t\t// first level\t\t\n\t\tBinaryTreeNode<Integer> root = new BinaryTreeNode<Integer>(8);\n\t\t//second level\n\t\t\tBinaryTreeNode<Integer> rootLeft = new BinaryTreeNode<Integer>(5);\n\t\t\tBinaryTreeNode<Integer> rootRight = new BinaryTreeNode<Integer>(10);\n\t\t\t// set roots left node to point to rootLeft\n\t\t\troot.left = rootLeft;\n\t\t\t// set roots right node to point toward rootRight\n\t\t\troot.right = rootRight;\n\t\t\t// third level (left side)\n\t\t\t\tBinaryTreeNode<Integer> rootLeft_LeftChild = new BinaryTreeNode<Integer>(2);\n\t\t\t\tBinaryTreeNode<Integer> rootLeft_RightChild = new BinaryTreeNode<Integer>(6);\n\t\t\t\t// set rootLeft's node to point to the left child\n\t\t\t\trootLeft.left = rootLeft_LeftChild;\n\t\t\t\t// set rootLeft's node to point to the right child\n\t\t\t\trootLeft.right = rootLeft_RightChild;\n\t\t\t//third level right side\n\t\t\tBinaryTreeNode<Integer> rootRight_leftChild = new BinaryTreeNode<Integer>(9);\n\t\t\tBinaryTreeNode<Integer> rootRight_rightChild = new BinaryTreeNode<Integer>(13);\n\t\t\t\trootRight.left = rootRight_leftChild;\n\t\t\t\trootRight.right = rootRight_rightChild;\n\t\t\t\t\n\t\t\n\t\t\t\t\n\t\t\t\n\t\t\t\t\n\n\t}\n\n}\n"
        }
      ]
    },
    {
      "name": "BinaryTrees",
      "files": [
        {
          "fileName": "BinaryTreeNode.java",
          "code": "package BinaryTrees;\n\npublic class BinaryTreeNode <T> {\n\t\n\tpublic T data;\n\tpublic BinaryTreeNode<T> left;\n\tpublic BinaryTreeNode<T> right;\n\t\n\t// create constructor function\n\tpublic BinaryTreeNode(T data) {\n\t\tthis.data = data;\n\t}\n\t\n\t\n}\n"
        },
        {
          "fileName": "BinaryTreeUse.java",
          "code": "package BinaryTrees;\n\npublic class BinaryTreeUse {\n\t\n\tpublic static void printPre_orderedTreeDetailed(BinaryTreeNode<Integer> root) {\n\t\t// base case\n\t\tif(root == null) {\n\t\t\treturn;\n\t\t}\n\t\tSystem.out.print(root.data + \": \");\n\t\t\n\t\tif(root.left != null) {\n\t\t\tSystem.out.print(\"L\"+ root.left.data + \", \");\n\t\t}\n\t\t\n\t\tif(root.right != null) {\n\t\t\tSystem.out.print(\"R\"+ root.right.data + \", \");\n\t\t}\n\t\t\n\t\tSystem.out.println();\n\t\t\n\t\t\n\t\tprintPre_orderedTreeDetailed(root.left);\n\t\tprintPre_orderedTreeDetailed(root.right);\n\t\t\n\t}\n\t\n\t\n\tpublic static void printTreePre_Ordered(BinaryTreeNode<Integer> root) {\n\t\t// base case\n\t\tif(root == null) {\n\t\t\treturn;\n\t\t}\n\t\tSystem.out.print(root.data + \" \");\n\t\tprintTreePre_Ordered(root.left);\n\t\tprintTreePre_Ordered(root.right);\n\t\t\n\t}\n\t\n\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\t// create the root of the binary tree \n\t\tBinaryTreeNode<Integer> root = new BinaryTreeNode<Integer>(1);\n\t\t// set the data of the root if no constructor function\n\t\t// root.data = 1;\n\t\t// making a \n\t\tBinaryTreeNode<Integer> rootLeft = new BinaryTreeNode<Integer>(2);\n\t\tBinaryTreeNode<Integer> rootRight = new BinaryTreeNode<Integer>(3);\n\t\t// set roots left node to point to rootLeft\n\t\troot.left = rootLeft;\n\t\t// set roots right node to point toward rootRight\n\t\troot.right = rootRight;\n\t\t\n\t\t\n\t\t\n\t\tBinaryTreeNode<Integer> rootLeft_RightChild = new BinaryTreeNode<Integer>(4);\n\t\tBinaryTreeNode<Integer> rootRight_LeftChild = new BinaryTreeNode<Integer>(5);\n\t\t// set rootLeft's node to point to the right side child rootLeft_RightChild\n\t\trootLeft.right = rootLeft_RightChild;\n\t\t// set rootRight's node to point to the left side child rootRight_leftChild\n\t\trootRight.left = rootRight_LeftChild;\n\t\t\n\t\tprintPre_orderedTreeDetailed(root);\n\t\t\n\t}\n\n}\n"
        },
        {
          "fileName": "UserInputBinaryTree.java",
          "code": "package BinaryTrees;\n\nimport java.util.Scanner;\n// working from the root first, then -> left then -> right: is called \"Pre-order\" because root is being worked first\n\n// working on children elements first, then -> parent then -> back to the root: its called \"Post-order\".\npublic class UserInputBinaryTree {\n\t\t\n\tpublic static BinaryTreeNode<Integer> TakeTreeInput(boolean isRoot, int parentData, boolean isLeft){\n\t\tif(isRoot) {\n\t\t\tSystem.out.println(\"Enter Root Data\");\n\t\t}else {\n\t\t\tif(isLeft) {\n\t\t\t\tSystem.out.println(\"Enter left child of \" + parentData);\t\t\t\t\n\t\t\t}else {\n\t\t\t\tSystem.out.println(\"Enter right child of \" + parentData);\n\t\t\t}\n\t\t}\n\t\tScanner s = new Scanner(System.in);\n\t\tint rootData = s.nextInt();\n\t\t\t\n\t\t// use minus one as a dummy for the input to null\n\t\tif(rootData == -1) {\n\t\t\treturn null;\n\t\t}\n\t\t\t\n\t\t// create the root with the input taken from the user\n\t\tBinaryTreeNode<Integer> root = new BinaryTreeNode<Integer>(rootData);\n\t\tBinaryTreeNode<Integer> leftChild = TakeTreeInput(false, rootData, true);\n\t\tBinaryTreeNode<Integer> rightChild = TakeTreeInput(false, rootData, false);\n\t\t// point the root to their respective children\n\t\troot.left = leftChild;\n\t\troot.right = rightChild;\n\t\treturn root;\n\t}\n\t\n\tpublic static int countNodes(BinaryTreeNode<Integer> root) {\n\t\t\n\t\tif(root == null) {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tint leftNodeCount = countNodes(root.left);\n\t\tint rightNodeCount = countNodes(root.right);\n\t\t// going to each and every node, and if its not null we are adding 1\n\t\treturn 1 + leftNodeCount + rightNodeCount;\n\t}\n\t\n\tpublic static int countNodesLargerThanX(BinaryTreeNode<Integer> root, int X) {\n\t\t\n\t\tif(root == null) {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tint leftNodeCount = countNodesLargerThanX(root.left, X);\n\t\tint rightNodeCount = countNodesLargerThanX(root.right, X);\n\t\t// going to each and every node, and if its not null we are adding 1\n\t\tif(root.data > X) {\n\t\t\treturn 1 + leftNodeCount + rightNodeCount;\n\t\t}\n\t\treturn leftNodeCount + rightNodeCount;\n\t}\n\t\n\tpublic static void printPre_orderedTreeDetailed(BinaryTreeNode<Integer> root) {\n\t\t// base case\n\t\tif(root == null) {\n\t\t\treturn;\n\t\t}\n\t\tSystem.out.print(root.data + \": \");\n\t\t\n\t\tif(root.left != null) {\n\t\t\tSystem.out.print(\"L\"+ root.left.data + \", \");\n\t\t}\n\t\tif(root.right != null) {\n\t\t\tSystem.out.print(\"R\"+ root.right.data + \", \");\n\t\t}\n\t\n\t\tSystem.out.println();\n\t\t\n\t\tprintPre_orderedTreeDetailed(root.left);\n\t\tprintPre_orderedTreeDetailed(root.right);\n\t}\n\t\n\tpublic static void printTreePost_Ordered(BinaryTreeNode<Integer> root) {\n\t\t// base case\n\t\tif(root == null) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tprintTreePost_Ordered(root.left);\n\t\tprintTreePost_Ordered(root.right);\n\t\tSystem.out.print(root.data + \" \");\n\t}\n\t\n\tpublic static int largestNodeValue(BinaryTreeNode<Integer> root) {\n\t\tif(root == null) {\n\t\t\treturn -1;\n\t\t}\n\t\tint largestLeft = largestNodeValue(root.left);\n\t\tint largestRight = largestNodeValue(root.right);\n\t\treturn Math.max(root.data, Math.max(largestLeft, largestRight));\n\t\t\n\t}\n\t\n\tpublic static int sumOfNodeData(BinaryTreeNode<Integer> root) {\n\t\t\n\t\tif(root == null) {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tint leftNodeCount = sumOfNodeData(root.left);\n\t\tint rightNodeCount = sumOfNodeData(root.right);\n\t\t// going to each and every node, and if its not null we are adding 1\n\t\treturn root.data + leftNodeCount + rightNodeCount;\n\t}\n\t\n\tpublic static int heightOfTree(BinaryTreeNode<Integer> root) {\n\t\tif(root == null) {\n\t\t\treturn 0;\n\t\t}\n\t\tint leftHeight = heightOfTree(root.left);\n\t\tint rightHeight = heightOfTree(root.right);\n\t\t\t\t  \n\t\treturn Math.max(leftHeight, rightHeight) + 1;\n\t}\n\tpublic static int countLeavesOfTree(BinaryTreeNode<Integer> root) {\n\t\tif(root == null) {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif(root.left == null && root.right == null) {\n\t\t\treturn 1;\n\t\t}\n\t\t\n\t\treturn countLeavesOfTree(root.left) + countLeavesOfTree(root.right);\n\t}\n\t\n\tpublic static void printNodesAtDepthK(BinaryTreeNode<Integer> root, int k) {\n\t\tif(root == null) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(k == 0) {\n\t\t\tSystem.out.println(root.data);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tprintNodesAtDepthK(root.left, k-1);\n\t\tprintNodesAtDepthK(root.right, k-1);\n\t\t\n\t}\n\t\n\tpublic static void changeToDepthTree(BinaryTreeNode<Integer> root) {\n        class Helper {\n            void changeDepth(BinaryTreeNode<Integer> node, int depth) {\n                if (node == null) {\n                    return;\n                }\n\n                node.data = depth;\n\n                changeDepth(node.left, depth + 1);\n                changeDepth(node.right, depth + 1);\n            }\n        }\n        new Helper().changeDepth(root, 0);\n\t}\n\t\n\tpublic static boolean isNodePresent(BinaryTreeNode<Integer> root, int x) {\n        // if root is null, return false as empty tree doesn't contain any nodes\n        if (root == null) {\n            return false;\n        }\n\n        // if the root node's value is equal to x, return true\n        if (root.data.equals(x)) {\n            return true;\n        }\n\n        // check left and right subtrees\n        boolean foundInLeft = isNodePresent(root.left, x);\n        boolean foundInRight = isNodePresent(root.right, x);\n\n        // return true if x was found in either subtree\n        return foundInLeft || foundInRight;\n    }\n\t\n\t public static void printNodesWithoutSibling(BinaryTreeNode<Integer> root) {\n\t        if (root == null) {\n\t            return;\n\t        }\n\n\t        // check if the left child has a sibling or not\n\t        if (root.left != null && root.right == null) {\n\t            System.out.print(root.left.data + \" \");\n\t        }\n\n\t        // check if the right child has a sibling or not\n\t        if (root.right != null && root.left == null) {\n\t            System.out.print(root.right.data + \" \");\n\t        }\n\n\t        // recursive call to the left child\n\t        printNodesWithoutSibling(root.left);\n\n\t        // recursive call to the right child\n\t        printNodesWithoutSibling(root.right);\n\t    }\n\t \n\t public static BinaryTreeNode<Integer> RemoveLeaves(BinaryTreeNode<Integer> root) {\n\t\t if(root == null) {\n\t\t\t return null;\n\t\t }\n\t\t if(root.left == null && root.right == null) {\n\t\t\t return null;\n\t\t }\n\t\t root.left = RemoveLeaves(root.left);\n\t\t root.right = RemoveLeaves(root.right);\n\t\t \n\t\t return root;\n\t\t \n\t }\n\t \n\t public static void mirrorBinaryTree(BinaryTreeNode<Integer> root) {\n\t        if (root == null) {\n\t            return;\n\t        }\n\n\t        // Swap the left and the right child of each node\n\t        BinaryTreeNode<Integer> temp = root.left;\n\t        root.left = root.right;\n\t        root.right = temp;\n\n\t        // Recur for the left and right subtrees\n\t        mirrorBinaryTree(root.left);\n\t        mirrorBinaryTree(root.right);\n\t    }\n//\t Time complexity O(nlogn)\n\t public static boolean isTreeBalanced(BinaryTreeNode<Integer> root) {\n\t\t if(root == null) {\n\t\t\t return true;\n\t\t }\n\t\t int leftHeight = height(root.left);\n\t\t int rightHeight = height(root.right);\n\t\t \n\t\t if(Math.abs(leftHeight - rightHeight) > 1) {\n\t\t\t return false;\n\t\t }\n\t\t \n\t\t boolean isLeftBalanced = isTreeBalanced(root.left);\n\t\t boolean isRightBalanced = isTreeBalanced(root.right);\n\t\t \n\t\t return isLeftBalanced && isRightBalanced;\n\t\t \n\t }\n\t \n\t // time complexity O(n)\n\t public static int height(BinaryTreeNode<Integer> root) {\n\t\t if(root == null) {\n\t\t\t return 0;\n\t\t }\n\t\t int leftHeight = height(root.left);\n\t\t int rightHeight = height(root.right);\n\t\t return 1 + Math.max(leftHeight, rightHeight);\n\t\t \n\t }\n\t // this is O(n) time complexity\n\t //Improving the time complexity of isTreeBalanced by returning height and is balanced at the same time\n\t public static optimizedBalancedTree isBalancedBetter(BinaryTreeNode<Integer> root) {\n\t\t if(root == null) {\n\t\t\t int height = 0;\n\t\t\t boolean isBal = true;\n\t\t\t optimizedBalancedTree ans = new optimizedBalancedTree();\n\t\t\t ans.height = height;\n\t\t\t ans.isBalanced = isBal;\n\t\t\t return ans;\n\t\t }\n\t\t \n\t\t optimizedBalancedTree leftOutpt = isBalancedBetter(root.left);\n\t\t optimizedBalancedTree rightOutput = isBalancedBetter(root.right);\n\t\t boolean isBal = true;\n\t\t int height = 1 + Math.max(leftOutpt.height, rightOutput.height);\n\t\t \n\t\t if(Math.abs(leftOutpt.height - rightOutput.height) >1 ) {\n\t\t\t isBal = false;\n\t\t }\n\t\t \n\t\t if(!leftOutpt.isBalanced || !rightOutput.isBalanced) {\n\t\t\t isBal = false;\n\t\t }\n\t\t \n\t\t optimizedBalancedTree ans = new optimizedBalancedTree();\n\t\t ans.height = height;\n\t\t ans.isBalanced = isBal;\n\t\t return ans;\n\t } \n\t /// find binary tree diameter/////////////////////////////////////\n\t static class Height {\n\t        int h;\n\t    }\n\t \n\t public static int findDiameter(BinaryTreeNode<Integer> root) {\n\t\t Height height = new Height();\n\t     return findDiameterUtil(root, height);\n\t\t\t  \n\t }\n\t \n\t private static int findDiameterUtil(BinaryTreeNode<Integer> root, Height height) {\n\t        Height lh = new Height(), rh = new Height();\n\n\t        if (root == null) {\n\t            height.h = 0;\n\t            return 0; // Diameter is also 0\n\t        }\n\n\t        lh.h++; rh.h++; // Increase height of left and right subtrees\n\n\t        // Recursive case: get the diameters of left and right subtrees\n\t        int ldiameter = findDiameterUtil(root.left, lh);\n\t        int rdiameter = findDiameterUtil(root.right, rh);\n\n\t        // Height of current node is max of heights of left and\n\t        // right subtrees plus 1\n\t        height.h = Math.max(lh.h, rh.h) + 1;\n\n\t        return Math.max(lh.h + rh.h + 1, Math.max(ldiameter, rdiameter));\n\t    }\n\t \n\t/// find binary tree diameter/////////////////////////////////////^^^^^^\n\t \n\t \n\t // insert node into BST\n\t public static BinaryTreeNode<Integer> insertNodeIntoTree(BinaryTreeNode<Integer> root, int x){\n\t\t // if there is no root node create one and set it equal to x\n\t\t if(root == null) {\n\t\t\t BinaryTreeNode<Integer> newRoot = new BinaryTreeNode<Integer>(x);\n\t\t\t return newRoot;\n\t\t }\n\t\t // if root node is present but x is greater than root, x must be inserted on the right side of BST \n\t\t if(x >= root.data) {\n\t\t\t BinaryTreeNode<Integer> newRoot = insertNodeIntoTree(root.right, x);\n\t\t\t root.right = newRoot;\n\t\t }else {\n\t\t\t // if x is not greater than root.data must insert on the left side of BST\n\t\t\t BinaryTreeNode<Integer> newRoot = insertNodeIntoTree(root.left, x);\n\t\t\t root.left = newRoot;\n\t\t }\n\t\t return root;\n\t }\n\n\t \n\tpublic static void main(String[] args) {\n\t\tBinaryTreeNode<Integer> root = TakeTreeInput(true, 0, true);\n\t\tprintTreePost_Ordered(root);\n\t\t\n\t\tSystem.out.println(\"sum of nodes \" + sumOfNodeData(root));\n\t\tSystem.out.println(largestNodeValue(root));\n\t\t\n\t\t\n\t\t\n\t}\n\n}\n"
        },
        {
          "fileName": "extraProblemsBinaryTrees.java",
          "code": "package BinaryTrees;\nimport java.util.ArrayList;\nimport java.util.*;\n\npublic class extraProblemsBinaryTrees {\n\t//For a given Binary Tree of type integer and a number K, \n\t//print out all root-to-leaf paths where the sum of all the node data along the path is equal to K.\n\t\n//\tTo solve this problem, you can use a recursive helper function that maintains a current path and its sum. \n//\tWhen it reaches a leaf node, it checks if the total sum equals K and if so, \n//\tit prints the path. Here is the solution code:\n\t\n\tpublic static void rootToLeafPathsSumToK(BinaryTreeNode<Integer> root, int k) {\n        ArrayList<Integer> path = new ArrayList<>();\n        rootToLeafPathsSumToKHelper(root, k, 0, path);\n    }\n\n    private static void rootToLeafPathsSumToKHelper(BinaryTreeNode<Integer> root, int k, int currentSum, ArrayList<Integer> path) {\n        if (root == null) {\n            return;\n        }\n\n        // add current node's data to the path and update the current sum\n        path.add(root.data);\n        currentSum += root.data;\n\n        // if the current node is a leaf node and the current sum equals k, print the path\n        if (root.left == null && root.right == null && currentSum == k) {\n            for (int i : path) {\n                System.out.print(i + \" \");\n            }\n            System.out.println();\n        } else {\n            // otherwise, recursively call the function on the left and right subtrees\n            rootToLeafPathsSumToKHelper(root.left, k, currentSum, path);\n            rootToLeafPathsSumToKHelper(root.right, k, currentSum, path);\n        }\n\n        // remove the current node from the path before returning\n        path.remove(path.size() - 1);\n    }\n////////////////////////////////////////////////////////////////////////////////////////////\n//    For a given a Binary Tree of type integer, find and return the minimum and the maximum data values.\n//    \t\tReturn the output as an object of Pair class, which is already created.\n//    \t\tNote:\n//    \t\tAll the node data will be unique and hence there will always exist a minimum and maximum \n    \n//    To solve this problem, you can use a recursive approach to traverse the entire binary tree and find the minimum and maximum values. \n//    The base case of the recursion would be when the node is null, in which case it would return a Pair with both elements set to null. \n//    Otherwise, it would compare the current node's value with the minimum and maximum values of the left and right subtrees \n//    to find the overall minimum and maximum values.\n    \n//\tRepresentation of the Pair Class\n\n    static class Pair<T, U> {\n\t\tT minimum;\n\t\tU maximum;\n\n\t\tpublic Pair(T minimum, U maximum) {\n\t\t\tthis.minimum = minimum;\n\t\t\tthis.maximum = maximum;\n\t\t}\n\t}\n\n\n\npublic class Solution {\n\n    public static Pair<Integer, Integer> getMinAndMax(BinaryTreeNode<Integer> root) {\n        // If the tree is empty, return null for both min and max values\n        if (root == null) {\n            return new Pair<>(null, null);\n        }\n\n        // Recursively get min and max from left and right subtrees\n        Pair<Integer, Integer> left = getMinAndMax(root.left);\n        Pair<Integer, Integer> right = getMinAndMax(root.right);\n\n        // Calculate the minimum and maximum values\n        int min = root.data;\n        int max = root.data;\n\n        // Compare with left subtree\n        if (left.minimum != null && left.minimum < min) {\n            min = left.minimum;\n        }\n        if (left.maximum != null && left.maximum > max) {\n            max = left.maximum;\n        }\n\n        // Compare with right subtree\n        if (right.minimum != null && right.minimum < min) {\n            min = right.minimum;\n        }\n        if (right.maximum != null && right.maximum > max) {\n            max = right.maximum;\n        }\n\n        // Return the pair of minimum and maximum values\n        return new Pair<>(min, max);\n    }\n    \n}\n////////////////////////////////////////////////////////////////////////////////////////////\n\n//You are given a Binary Tree of type integer, a target node, and an integer value K.\n//Print the data of all nodes that have a distance K from the target node. The order in which they would be printed will not matter.\n\n\tprivate static void printNodesAtKDistance(BinaryTreeNode<Integer> node, int k) {\n\t    if (node == null || k < 0) {\n\t        return;\n\t    }\n\t    if (k == 0) {\n\t        System.out.println(node.data);\n\t        return;\n\t    }\n\t    printNodesAtKDistance(node.left, k - 1);\n\t    printNodesAtKDistance(node.right, k - 1);\n\t}\n\t\n\t// Helper method to print nodes that are at k distance from target node\n\tprivate static int printNodesAtKDistance(BinaryTreeNode<Integer> node, int target, int k) {\n\t    // Base cases\n\t    if (node == null) {\n\t        return -1;\n\t    }\n\t    if (node.data == target) {\n\t        printNodesAtKDistance(node, k);\n\t        return 0;\n\t    }\n\t\n\t    // Check if target node is in left subtree or right subtree\n\t    int dl = printNodesAtKDistance(node.left, target, k);\n\t\n\t    if (dl != -1) {\n\t        if (dl + 1 == k) {\n\t            System.out.println(node.data);\n\t        } else {\n\t            printNodesAtKDistance(node.right, k - dl - 2);\n\t        }\n\t        return 1 + dl;\n\t    }\n\t\n\t    int dr = printNodesAtKDistance(node.right, target, k);\n\t    if (dr != -1) {\n\t        if (dr + 1 == k) {\n\t            System.out.println(node.data);\n\t        } else {\n\t            printNodesAtKDistance(node.left, k - dr - 2);\n\t        }\n\t        return 1 + dr;\n\t    }\n\t\n\t    return -1;\n\t}\n\t\n\tpublic static void nodesAtDistanceK(BinaryTreeNode<Integer> root, int node, int k) {\n\t    printNodesAtKDistance(root, node, k);\n\t}\n\t\n////////////////////////////////////////////////////////////////////////////////////////////\n//\tFor a given a Binary Tree of type integer, duplicate every node of the tree and attach it to the left of itself.\n//\tThe root will remain the same. So you just need to insert nodes in the given Binary Tree.\n\tpublic static void insertDuplicateNode(BinaryTreeNode<Integer> root) {\n\t\t// Base case: if root is null, return\n\t\tif (root == null) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Create a new node duplicating the current node\n\t\tBinaryTreeNode<Integer> newNode = new BinaryTreeNode<>(root.data);\n\t\t\n\t\t// Save the current left child\n\t\tBinaryTreeNode<Integer> temp = root.left;\n\t\t\n\t\t// Make the new node as the left child\n\t\troot.left = newNode;\n\t\t\n\t\t// Make the old left child as the left child of new node\n\t\tnewNode.left = temp;\n\t\t\n\t\t// Recursively do this for the remaining tree\n\t\tinsertDuplicateNode(temp);\n\t\tinsertDuplicateNode(root.right);\n\t}\n////////////////////////////////////////////////////////////////////////////////////////////\n//\tFor a given a Binary Tree of type integer, print it in a level order fashion where each level will be printed on a new line. \n//\tElements on every level will be printed in a linear fashion and a single space will separate them.\n\t\n\tpublic static void printLevelWise(BinaryTreeNode<Integer> root) {\n\t\tif (root == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tQueue<BinaryTreeNode<Integer>> currentLevel = new LinkedList<>();\n\t\tQueue<BinaryTreeNode<Integer>> nextLevel = new LinkedList<>();\n\n\t\tcurrentLevel.add(root);\n\n\t\twhile (!currentLevel.isEmpty()) {\n\t\t\tBinaryTreeNode<Integer> currNode = currentLevel.poll();\n\t\t\tSystem.out.print(currNode.data + \" \");\n\n\t\t\tif (currNode.left != null) {\n\t\t\t\tnextLevel.add(currNode.left);\n\t\t\t}\n\n\t\t\tif (currNode.right != null) {\n\t\t\t\tnextLevel.add(currNode.right);\n\t\t\t}\n\n\t\t\tif (currentLevel.isEmpty()) {\n\t\t\t\tSystem.out.println();\n\t\t\t\tQueue<BinaryTreeNode<Integer>> temp = currentLevel;\n\t\t\t\tcurrentLevel = nextLevel;\n\t\t\t\tnextLevel = temp;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n"
        },
        {
          "fileName": "optimizedBalancedTree.java",
          "code": "package BinaryTrees;\n\npublic class optimizedBalancedTree {\n\t// we are improving the time complexity over the isBalanced & height functions in UserInputBinaryTree by returning multiple items\n\t// in a single object\n\tint height;\n\tboolean isBalanced;\n}\n"
        },
        {
          "fileName": "takeInputLevelwise.java",
          "code": "package BinaryTrees;\n\nimport java.util.Scanner;\nimport java.util.Queue;\nimport java.util.LinkedList;\n\npublic class takeInputLevelwise {\n// to take input level wise for a tree we must implement use of a queue\t\n\t// take root input\n\t// insert it into a queue\n\t// while queue is not empty: \n//\t\t-take the first element out\n//\t\t-Ask for its left child node\n//\t\t\t-if left is not = -1, attach to parent element on left side, & push left to the queue\n//\t\t-Ask for its right child node\n//\t\t\t-if right is not = -1, attach to parent element on right side, and push to the queue\n\t\n\tpublic static BinaryTreeNode<Integer> takeInput(){\n\t\tScanner s = new Scanner(System.in);\n\t\tSystem.out.println(\"Enter Root data\");\n\t\tint rootData = s.nextInt();\n\t\t\n\t\tif(rootData == -1) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tBinaryTreeNode<Integer> root = new BinaryTreeNode<Integer>(rootData);\n\t\t\n\t\t// because Queue is an interface we need to use a class which implements this interface, we will use linked list class\n\t\t// Note: we have to put the entire Node inside the queue in order to assign the left and right children\n\t\tQueue<BinaryTreeNode<Integer>> pendingChildren = new LinkedList<BinaryTreeNode<Integer>>();\n\t\t\n\t\t// insert the root inside the queue\n\t\tpendingChildren.add(root);\n\t\t\n\t\t// while pending children queue is not empty, take out the first element \n\t\twhile(!pendingChildren.isEmpty()) {\n\t\t\tBinaryTreeNode<Integer> front = pendingChildren.poll();\n\t\t\t// ask for fronts left child\n\t\t\tSystem.out.println(\"Enter left child of \" + front.data);\n\t\t\tint left = s.nextInt();\n\t\t\t//\n\t\t\tif(left != -1) {\n\t\t\t\t// creates a new left child node\n\t\t\t\tBinaryTreeNode<Integer> leftChild = new BinaryTreeNode<Integer>(left);\n\t\t\t\tfront.left = leftChild;\n\t\t\t\t// add the new leftChild to the pending queue, so we can ask for its children later\n\t\t\t\tpendingChildren.add(leftChild);\n\t\t\t}\n\t\t\t// repeat the work for the right side\n\t\t\tSystem.out.println(\"Enter right child of \" + front.data);\n\t\t\tint right = s.nextInt();\n\t\t\t//\n\t\t\tif(right != -1) {\n\t\t\t\t// creates a new right child node\n\t\t\t\tBinaryTreeNode<Integer> rightChild = new BinaryTreeNode<Integer>(right);\n\t\t\t\tfront.right = rightChild;\n\t\t\t\t// add the new rightChild to the pending queue, so we can ask for its children later\n\t\t\t\tpendingChildren.add(rightChild);\n\t\t\t}\n\t\t}\n\t\treturn root;\n\t}\n\t\n\tpublic static void printLevelwise(BinaryTreeNode<Integer> root) {\n\t\t// add root to the queue, if root is null, do nothing\n\t\t// while queue is not empty take out first node, print it, check for children, if children are not null, add to queue.\n\t\tif(root == null) {\n\t        return;\n\t    }\n\t    \n\t    Queue<BinaryTreeNode<Integer>> pendingChildren = new LinkedList<BinaryTreeNode<Integer>>();\n\t    pendingChildren.add(root);\n\t    \n\t    while(!pendingChildren.isEmpty()) {\n\t        BinaryTreeNode<Integer> front = pendingChildren.poll();\n\n\t        String output = front.data + \":\";\n\t        \n\t        // Check and append left child info\n\t        if(front.left != null) {\n\t            pendingChildren.add(front.left);\n\t            output += \"L:\" + front.left.data + \",\";\n\t        } else {\n\t            output += \"L:-1,\";\n\t        }\n\t        \n\t        // Check and append right child info\n\t        if(front.right != null) {\n\t            pendingChildren.add(front.right);\n\t            output += \"R:\" + front.right.data;\n\t        } else {\n\t            output += \"R:-1\";\n\t        }\n\n\t        System.out.println(output);\n\t    }\n\t}\n\t\n\tpublic static void printPre_orderedTreeDetailed(BinaryTreeNode<Integer> root) {\n\t\t// base case\n\t\tif(root == null) {\n\t\t\treturn;\n\t\t}\n\t\tSystem.out.print(root.data + \": \");\n\t\t\n\t\tif(root.left != null) {\n\t\t\tSystem.out.print(\"L\"+ root.left.data + \", \");\n\t\t}\n\t\tif(root.right != null) {\n\t\t\tSystem.out.print(\"R\"+ root.right.data + \", \");\n\t\t}\n\t\n\t\tSystem.out.println();\n\t\t\n\t\tprintPre_orderedTreeDetailed(root.left);\n\t\tprintPre_orderedTreeDetailed(root.right);\n\t}\n\t\n\t// Build binary tree from pre-order and in-order list.////////////////////////////////\n\t static int preIndex = 0;\n\n\t    private static int search(int[] inOrder, int start, int end, int value) {\n\t        for (int i = start; i <= end; i++) {\n\t            if (inOrder[i] == value) {\n\t                return i;\n\t            }\n\t        }\n\t        return -1;\n\t    }\n\n\t    private static BinaryTreeNode<Integer> buildTreeHelper(int[] preOrder, int[] inOrder, int inStart, int inEnd) {\n\t        // Base case: if no elements are remaining in the subarray\n\t        if (inStart > inEnd) {\n\t            return null;\n\t        }\n\n\t        // The next element in preOrder is the root of the current subtree\n\t        BinaryTreeNode<Integer> root = new BinaryTreeNode<>(preOrder[preIndex++]);\n\n\t        // If the current subtree has no children, return the root\n\t        if (inStart == inEnd) {\n\t            return root;\n\t        }\n\n\t        // Find the root in inOrder to split into left and right subtrees\n\t        int inIndex = search(inOrder, inStart, inEnd, root.data);\n\n\t        // Recursively construct the left and right subtrees\n\t        root.left = buildTreeHelper(preOrder, inOrder, inStart, inIndex - 1);\n\t        root.right = buildTreeHelper(preOrder, inOrder, inIndex + 1, inEnd);\n\n\t        return root;\n\t    }\n\n\t    public static BinaryTreeNode<Integer> buildTree(int[] preOrder, int[] inOrder) {\n\t        preIndex = 0;  // reset the preIndex\n\t        return buildTreeHelper(preOrder, inOrder, 0, inOrder.length - 1);\n\t    }\n\t // Build binary tree from pre-order and in-order list.////////////////////////////////\n\t    \n\t // Build binary tree from post-order and in-order list.////////////////////////////////\n\t    public class Solution {\n\t        static int postIndex;\n\n\t        private static int search(int[] inOrder, int start, int end, int value) {\n\t            for (int i = start; i <= end; i++) {\n\t                if (inOrder[i] == value) {\n\t                    return i;\n\t                }\n\t            }\n\t            return -1;  // should never reach here!\n\t        }\n\n\t        private static BinaryTreeNode<Integer> buildTreeHelper(int[] postOrder, int[] inOrder, int inStart, int inEnd) {\n\t            // Base case: if no elements are remaining in the subarray\n\t            if (inStart > inEnd) {\n\t                return null;\n\t            }\n\n\t            // The next element in postOrder is the root of the current subtree\n\t            BinaryTreeNode<Integer> root = new BinaryTreeNode<>(postOrder[postIndex--]);\n\n\t            // If the current subtree has no children, return the root\n\t            if (inStart == inEnd) {\n\t                return root;\n\t            }\n\n\t            // Find the root in inOrder to split into left and right subtrees\n\t            int inIndex = search(inOrder, inStart, inEnd, root.data);\n\n\t            // Recursively construct the right and left subtrees (note the order is reversed compared to preOrder)\n\t            root.right = buildTreeHelper(postOrder, inOrder, inIndex + 1, inEnd);\n\t            root.left = buildTreeHelper(postOrder, inOrder, inStart, inIndex - 1);\n\n\t            return root;\n\t        }\n\n\t        public static BinaryTreeNode<Integer> buildTree(int[] postOrder, int[] inOrder) {\n\t            postIndex = postOrder.length - 1;  // initialize postIndex to the last element\n\t            return buildTreeHelper(postOrder, inOrder, 0, inOrder.length - 1);\n\t        }\n\t    }\n\t // Build binary tree from post-order and in-order list.////////////////////////////////\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tBinaryTreeNode<Integer> root = takeInput();\n\t\tprintPre_orderedTreeDetailed(root);\n\t}\n\n}\n"
        }
      ]
    },
    {
      "name": "BitwiseOperations",
      "files": [
        {
          "fileName": "BitwiseOperations.java",
          "code": "package BitwiseOperations;\n\npublic class BitwiseOperations {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n//\t    int a=10,b=20;\n//\t    System.out.println(a+++--b);//line 1\n//\t    System.out.println(a--+++b);//line 2 // error here\n//\t    System.out.println(a++-++b);//line 3\n//\t    System.out.println(a+++++b);//line 4\n\t\n//\t\t   int a = 42;\n//\t       int b = ~a; \n//\t       System.out.print(b);  //output = 42 -43\n//\t\tBitwise operations ( 1 = true / 0 = false )\n//\t    int a=5;\n//\t    a+=5+(++a)+(a++);\n//\t    System.out.print(a); output = 22\n//\t\t______________________________\n//\t\tint a = 10;\n//\t\tint b = 21;\n//\t\t\n//\t\tint c = a & b;\n//\t\tSystem.out.println(c);\n//\t\tbitwise &\n//\t\t10 = 1010 (binary)\n//\t\t 2 = 0010 (binary)\n//\t\t\t_____\n//\t\t\t fftf\n//\t  10 & 2=0010\t=2\n//\t\t______________________________\n//\t\tBitwise 'or' = |\n//\t\tint d = a | b;\n//\t\tSystem.out.println(d);\n//\t\tbitwise |\n//\t\t10 = 1010 (binary)\n//\t\t 2 = 0010 (binary)\n//\t\t\t_____\n//\t\t\t tftf\n//\t  10 | 2=1010\t=10\n\t\t\n//\t\t_____________________________\n////\t\tbitwise ^ XOR = If the values are the same its false, if they are different its true\n//\t\tint e = a ^ b;\n//\t\tSystem.out.println(e);\n//\t\t10 = 1010 (binary)\n//\t\t 2 = 0010 (binary)\n//\t\t\t_____\n//\t\t\t tfff\n//\t  10 | 2=1000\t=8\n\t\t\n//\t\tcan use a^=1; this \n//\t\tSystem.out.println(a^=1); will increase the value by one if a is even, and decrease by one if the value of a is odd.\n//\t\t____________________________\n//\t\tbitwise ~ NOT = similar to ones compliment, all values will be toggled ex. ~1111 = 0000\n//\t       Note: in order to solve a bitwise not for a number, you must take the 2's compliment.\n//\t\t\ta = 10 = 1010(binary)\n//\t\tSystem.out.println(~a); // ~a = 0101 = -11\n//\t\t___________________________________________\n//\t\tbitwise << left shift = left shift by 1 equivalent to multiplying by 2 (to power 1), if shifted by 2 it will increase by 2 (to power 2). the power = number of shifts  \n//\t\ta = 10 = 1010(binary)\tsyntax = a << 1 or a << 2  (a left shift 1, or a left shift 2)\n//\tSystem.out.println(a << 1); // a = 20\n//\t\t___________________________________________\n//\t\tbitwise << right shift = right shift by 1 --> after right shift by 1 a=5 / effectively multiplying by 1/2 (to power 1). the power = number of shifts\n//\t\ta = 10 = 1010(binary)\tsyntax = a >> 1 or a >> 2  (a right shift of 1, or a right shift of 2)\n//\tSystem.out.println(a >> 1); // a = 4\n\t\t\n\t\t\n\t\t\n\t}\n\n}\n"
        },
        {
          "fileName": "OrderOfPrecedence.java",
          "code": "package BitwiseOperations;\n\npublic class OrderOfPrecedence {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n//\t\tThe order of precedence in the expression:\n\t\tint a =10;\n\t\ta+=++a-5/3+6*a; \n\t\tSystem.out.println(a);\n\t\tSystem.out.println(5/3);\n\t}\n\n}\n"
        }
      ]
    },
    {
      "name": "DemoOfPassingBetweenPackages",
      "files": [
        {
          "fileName": "StudentUse2.java",
          "code": "package DemoOfPassingBetweenPackages;\n\nimport ObjectOrientedPrograming.Student;\n\npublic class StudentUse2 {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tStudent s1 = new Student();\n\t\tSystem.out.println(s1.name);\t// name isn't visible from original package because its access modifier is set to default\n\t\t// to make this available, go back to Student file and set name to public.\n\t\n\t}\n\n}\n"
        }
      ]
    },
    {
      "name": "ExceptionHandling",
      "files": [
        {
          "fileName": "Exceptions.java",
          "code": "package ExceptionHandling;\n\npublic class Exceptions {\n\t\n\n\t// key take away, you can either handle your exceptions or pass them, if you handle them use try/catch statements.\n\t\n\t\npublic static int divide(int a, int b) throws divideByZeroException {\t// throws declaration passes a checked exception to the calling function, in this caise main\n\tif(b == 0) {\n\t\tthrow new divideByZeroException();  \n\t\t\t\n//\t\tthrow new ArithmeticException();\n\t}\n\treturn a/b;\n}\n\t\n\n\tpublic static void main(String[] args) {\n\t\t// 3 types of exceptions in java: \n//\t\tErrors: \n//\t\tChecked: expected exceptions\n//\t\tUnchecked: Unexpected exceptions\n\t\t\n\t\t\n\t\ttry {\t\t\t\t\t// try/catch will deal with the exception, instead of letting it be passed up to main\n\t\t\tdivide(10,0);\n\t\t\t\n\t\t} catch (divideByZeroException error) {\n\t\t\t\n\t\t\tSystem.out.println(\"Divide by 0 exception\");\n\t\t\t//error.printStackTrace();   // un-commenting this will print the stack trace in red\n\t\t}finally {\n\t\t\t//finally will run no matter what, use finally to close an established connection to a network of a file, \n\t\t\t// this way it doesn't remain open in case an error occurs\n\t\t}\n\t\t\n\t\tSystem.out.println(\"Main\");\n\t}\n\n}\n"
        },
        {
          "fileName": "divideByZeroException.java",
          "code": "package ExceptionHandling;\n\npublic class divideByZeroException extends Exception {\n\t\n\t// Exception is already a class that exists in Java\n\n}\n"
        }
      ]
    },
    {
      "name": "Functions",
      "files": [
        {
          "fileName": "AnotherWayToRotateArrays.java",
          "code": "package Functions;\n\nimport java.util.Scanner;\n\npublic class AnotherWayToRotateArrays {\n\t\n\tpublic static void swap(int[] a, int l, int r) {\n\t\tint temp = a[l];\n\t\t\ta[l] = a[r];\n\t\t\ta[r] = temp;\n\t}\n\t\n\tpublic static void reverse(int[] a, int l, int r) {\n\t\tr--;\n\t\tint len = (r-1)/2;\n\t\tfor(int i=0;i<=len;i++) {\n\t\t\tswap(a,l,r);\n\t\t\tl++;\n\t\t\tr--;\n\t\t}\n\t}\n\t\n\tpublic static void rotateRight(int[] a, int n, int x) {\n\t\treverse(a,0,n);\n\t\treverse(a,0,x);\n\t\treverse(a,x,n);\n\t}\n\t\n\tpublic static void rotateLeft( int[] a, int n, int x) {\n\t\treverse(a,0,n);\n\t\treverse(a,0,n-x);\n\t\treverse(a,n-x,n);\n\t}\n\t\n\t\n\tpublic static void rotateArray(int[] a, int n, int x, String dir) {\n\t\tx = x%n;\n\t\tif(x>0 && dir.equals(\"LEFT\")) {\n\t\t\trotateLeft(a,n,x);\n\t\t}\n\t\telse if(x>0 && dir.equals(\"right\")) {\n\t\t\trotateRight(a,n,x);\n\t\t}\n\t\tfor(int i=0; i<n;i++) {\n\t\t\tSystem.out.print(a[i]);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner s = new Scanner (System.in);\n\t\tint n = s.nextInt();\n\t\tint x = s.nextInt();\n\t\tString dir = s.next();\n\t\tint[] a = new int[n];\n\t\tfor(int i=0; i<n; i++) {\n\t\t\ta[i] = s.nextInt();\n\t\t}\n\t\trotateArray(a, n, x, dir);\n\t}\n\n}\n"
        },
        {
          "fileName": "ArrayRotation.java",
          "code": "package Functions;\n\npublic class ArrayRotation {\n\t\t\n\tpublic static void printArray(int[] array) {\n\t\tint n = array.length;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tSystem.out.print(array[i]+ \" \");\n\t\t}\n\t}\n\t\n\tpublic static int[] rotateArray(int[] array) {\n\t\tfor(int i = 0, j = array.length-1; j >= (int) Math.floor((array.length/2)); i++, j--) {\n\t\t\tint temp = array[i];\n\t\t\tarray[i]= array[j];\n\t\t\tarray[j] = temp;\n\t\t}return array;\n\t}\n\t\n\tpublic static int[] rotateRight(int[] array, int Rotation) {\n\t\tRotation = Rotation % array.length; // handles case where rotation is greater than array.length\n\t\tint j = array.length - 1;\n\t\tint k = array.length - (array.length - Rotation); // corrected\n\t\tfor(int i = 0, m = Rotation-1; i < m; i++, m--) {\n\t\t\tint temp = array[m];\n\t\t\tarray[m] = array[i];\n\t\t\tarray[i] = temp;\n\t\t\twhile(j > k) { // corrected\n\t\t\t\tint temp1 = array[j];\n\t\t\t\tarray[j] = array[k];\n\t\t\t\tarray[k] = temp1;\n\t\t\t\tj--;\n\t\t\t\tk++;\n\t\t\t}\n\t\t}return array;\n\t}\n\t// rotate left and rotate right are very similar except, rotate right takes the rotation factor from the front of the array \n\t// rotate left takes the rotation factor from the back of the array\n\tpublic static int[] rotateLeft(int[] array, int Rotation) {\n\t\tRotation = Rotation % array.length; // handles case where rotation is greater than array.length\n\t\tint j = 0;\n\t\tint k = array.length-(Rotation+1);\n\t\tfor(int i = array.length-1, m = array.length - Rotation; i > m; i--, m++) {\n\t\t\tint temp = array[i];\n\t\t\tarray[i] = array[m];\n\t\t\tarray[m] = temp;\n\t\t\twhile(j < k) {\n\t\t\t\tint temp1 = array[k];\n\t\t\t\tarray[k] = array[j];\n\t\t\t\tarray[j] = temp1;\n\t\t\t\tj++;\n\t\t\t\tk--;\n\t\t\t}\n\t\t}return array;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tint[] arr = {2,5,3}; // length 8\n\t\tboolean rotateRight = false;\n\t\tint rotationFactor = 2;\n\t\t//printArray(arr);\n\t\tint [] rotated = rotateArray(arr);\n\t\t//printArray(rotated);\n\t\tif(rotateRight) {\n\t\t\tint[] rightShift = rotateRight(rotated, rotationFactor);\n\t\t\tprintArray(rightShift);\n\t\t}else if(!rotateRight) {\n\t\t\tint [] leftShift = rotateLeft(rotated, rotationFactor);\n\t\t\tprintArray(leftShift);\n\t\t}\n\t}\n\n}\n"
        },
        {
          "fileName": "BubbleSort.java",
          "code": "package Functions;\nimport java.util.Arrays;\npublic class BubbleSort {\n\tpublic static void printArray(int[] arr) {\n\t\tint n = arr.length;\n\t\tfor(int i = 0; i<n;i++) {\n\t\t\tSystem.out.print(arr[i]+\" \");\n\t\t}\n\t}\n\n    public static int[] bubbleSort(int[] array){\n        for(int i = 0; i< array.length-1; i++){\n            for(int j = 0; j< array.length -1; j++){\n                if(array[j] > array[j+1]){\n                    int temp = array[j+1];\n                    array[j+1] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n\t\treturn array;\n    }\n        public static void main(String[] args) {\n        \t\n        \tint[] arr = {4, 11, 7, 12, 2, 6, 3, 5, 10, 9};\n    \t\tbubbleSort(arr);\n    \t\t\n    \t\tprintArray(arr);\n    \t\n    \t\t\t\n        }\n    }"
        },
        {
          "fileName": "InsertionSort.java",
          "code": "package Functions;\n\npublic class InsertionSort {\n\t\n\tpublic static void printArray(int[] arr) {\n\t\tint n = arr.length;\n\t\tfor(int i = 0; i<n;i++) {\n\t\t\tSystem.out.print(arr[i]+\" \");\n\t\t}\n\t}\n\t\n\tpublic static void insertionSort(int[] array) {\n\t\t\n\t\tfor(int i=1; i<array.length; i++) {\n\t\t\t// insert the i'th element in the sorted array\n\t\t\tint j = i-1;\n\t\t\tint temp = array[i];\n\t\t\t\n\t\t\twhile(j >= 0 && array[j] > temp) {\n\t\t\t\tarray[j+1] = array[j]; // shifts the elements to the right\n\t\t\t\tj--;\n\t\t\t}\n\t\t\t\n\t\t\tarray[j+1]=temp;\n\t\t}\n\t}\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tint[] arr = {90, 31, 94, 80, 46, 28, 48, 31, 28, 90, 9, 27, 81, 43, 94, 5, 56, 13, 1, 23, 85, 71, 93, 53, 82 };\n\t\tinsertionSort(arr);\n\t\t\n\t\tprintArray(arr);\n\t}\n\n}\n"
        },
        {
          "fileName": "JavaFunctionBasiscs.java",
          "code": "package Functions;\n\npublic class JavaFunctionBasiscs {\n\t\n\t\n//pub/priv/return type/Name(inputs)\t\n\tpublic static void demo(int a, int b){\n\t    System.out.println(a + \" \" + b);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t    int a = 5;\n\t    int b = 15; \n\t    //demo(a);\n\t\n\n\t}\n\n}\n"
        },
        {
          "fileName": "PrimitiveAndNonPrimitives.java",
          "code": "package Functions;\n\npublic class PrimitiveAndNonPrimitives {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n"
        },
        {
          "fileName": "addBetween3Arrays.java",
          "code": "package Functions;\nimport java.util.Arrays;\npublic class addBetween3Arrays {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\t\n\t\t/// Array out of bounds needs to be fixed\n\t\t\n\t\tint n = 6; \n\t\t\n\t\tint x = 16;\n\t\t\n\t\tint[] p1 = {8, 1, 2, 3, 2, 5}; \n\t\t\n\t\tint[] p2 = {9, 5, 6, 7, 7, 6}; \n\t\t\n\t\tint[] f = new int[n];\n\t\tint R = 0;\n\t\tint sum = 0;\n\t    for(int i = 0; i<n; i++){\n\t    \t\n\t    \tsum = p1[i]+ p2[i];\n\t    \t\n\t    \tif(sum > x){\n\t    \t\t\n\t    \t\tR = sum - x;// working R=1\n\t    \t\tsum = x;\t// working sum = 16\n\t    \t\tf[i+1] = R; // working f[i+1] = 1\n\t    \t\t//System.out.println(\"in if \"+ f[i+1]);\n\t    \t\t//System.out.println(\"at R in if\"+ R);\n\t    \t\t\n\t    \t}else{\n\t    \t  \n\t    \t\tR = 0;\n\t    \t}\n\t    \t//System.out.println(\"at end b4 assignment \"+ f[i]);\n\t    \t//System.out.println(\"end sum \"+ sum);\n\t    \t//System.out.println(\"at R \"+ R);\n\t    \tf[i] = f[i] + sum;\n\t    \t//System.out.println(\"at end \"+ f[i]);\n\t    \t\n\t   }System.out.print(Arrays.toString(f));\n\t}\n\n}\n"
        },
        {
          "fileName": "arraySwapBetweenIndicies.java",
          "code": "package Functions;\n\nimport java.util.Scanner;\nimport java.util.Arrays;\npublic class arraySwapBetweenIndicies {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\t// swap between user given indices (inclusive\n\t\tint[] arr = {2,5,8,5,9,0,1,3};\n\t\tScanner s = new Scanner (System.in);\n\t\tSystem.out.print(\"Please enter a L index and R index between 0 and \" + arr.length);\n\t\tint L = s.nextInt();\n\t\tint R = s.nextInt();\n\t\t// Alternatively you could use i < j instead of Math.floor()\n\t\tfor(int i = L, j= R; i <= (int)Math.floor((L+R)/2); i++, j--) {\n\t\t\tint temp = arr[i];\n\t\t\tarr[i] = arr[j];\n\t\t\tarr[j] = temp;\n\t\t}\n\t\tSystem.out.print(Arrays.toString(arr));\n\t}\n\n}\n"
        },
        {
          "fileName": "binarySearch.java",
          "code": "package Functions;\n\npublic class binarySearch {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\t\n\t\t// this binary search wont return -1 if target doesn't exist\n//\t\tint[] arr = {1,3,4,5,6,7,8,9,11};\n//\t\t int target = 2;\n//\t\t int start = 0;\n//\t\t int end = arr.length - 1;\n//\t\t int middleIndex = (int)Math.floor((start+end)/2);\n//\t\t int value = arr[middleIndex];\n//\t\t \n//\t\t while (start < end) {\n//\t\t\t \n//\t\t\t if (value < target) {\n//\t\t\t\t \n//\t\t\t\t start = middleIndex;\n//\t\t\t\t middleIndex = (int)Math.floor((start+end)/2);\n//\t\t\t\t value = arr[middleIndex];\n//\t\t\t }else if(value > target) {\n//\t\t\t\t end = middleIndex;\n//\t\t\t\t middleIndex = (int)Math.floor((start+end)/2);\n//\t\t\t\t value = arr[middleIndex];\n//\t\t\t }else if( value == target ) {\n//\t\t\t\t System.out.println(middleIndex);\n//\t\t\t\t break;\n//\t\t\t }\n//\t\t }\n\t// this binary search should return -1 if the element doesnt exist.\n\t\t\t        int[] nums = {1, 3, 4, 5, 6, 7, 8, 9, 11};\n\t\t\t        // start by identifying the components needed to solve the problem\n\t\t\t        int target = 7;\n\t\t\t        int start = 0;\n\t\t\t        int end = nums.length -1;\n\t\t\t        int middleIndex;\n\t\t\t        int value;\n\t\t\t        int notFound = -1;\n\t\t\t        while ( start <= end){\n\t\t\t            middleIndex =(int)Math.floor((start + end)/2);\n\t\t\t            value = nums[middleIndex];\n\t\t\t            if (value < target){\n\t\t\t                start = middleIndex + 1;\n\t\t\t            }else if( value > target){\n\t\t\t                end = middleIndex-1;\n\t\t\t            }else if(value == target){\n\t\t\t                 System.out.println(middleIndex);\n\t\t\t                 return;\n\t\t\t            }\n\t\t\t        }\n\t\t\t        System.out.println(notFound); // Target not found\n\t\t\t}\n}\n\t\n\n\n"
        },
        {
          "fileName": "functionsWithArrays.java",
          "code": "package Functions;\nimport java.util.Scanner;\npublic class functionsWithArrays {\n\n\t\n\tpublic static void printArray(int[] arr) {\n\t\tint n = arr.length;\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tSystem.out.println(arr[i]);\n\t\t}\n\t}\n\t\n\t\n\tpublic static int[] takeInput() {\n\t\tScanner s = new Scanner(System.in);\n\t\tint n = s.nextInt();\n\t\tint[] arr = new int[n];\n\t\t\n\t\tfor(int i = 0; i<n; i++) {\n\t\t\tSystem.out.println(\"Enter element at index \" + i);\n\t\t\tarr[i] = s.nextInt();\n\t\t}\n\t\treturn arr;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tint[] arr = takeInput();\n\t\tprintArray(arr);\n\t\t\n\t}\n\n}\n"
        },
        {
          "fileName": "largestNumberinArray.java",
          "code": "package Functions;\n\nimport java.util.Scanner;\n\npublic class largestNumberinArray {\n\n\tpublic static int[] takeInput() {\n\t\tScanner s = new Scanner(System.in);\n\t\tint n = s.nextInt();\n\t\tint[] arr = new int[n];\n\t\t\n\t\tfor(int i = 0; i<n; i++) {\n\t\t\t\n\t\t\tSystem.out.println(\"Enter element at index \" + i);\n\t\t\tarr[i] = s.nextInt();\n\t\t}\n\t\treturn arr;\n\t}\n\t\n\tpublic static int largest(int[] element) {\n\t\tint maxVal = Integer.MIN_VALUE;\n\t\t\n\t\tfor(int i = 0; i < element.length; i++) {\n\t\t\t\n\t\t\tmaxVal = (maxVal < element[i]) ? element[i] : maxVal;\n\t\t\t\n\t\t}\n\t\treturn maxVal;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tint[] array = takeInput();\n\t\t\n\t\tint lar = largest(array); \n\t\t\n\t\tSystem.out.println(lar);\n\n\t\t\n\t}\n\n}\n"
        },
        {
          "fileName": "linearSearch.java",
          "code": "package Functions;\n\nimport java.util.Scanner;\n\npublic class linearSearch {\n    // takes user input//////////////////////////////////////////////\n\tpublic static int[] takeInput() {\n\t\tScanner s = new Scanner(System.in);\n\t\tint n = s.nextInt();\n\t\tint[] arr = new int[n];\n\t\t\n\t\tfor(int i = 0; i<n; i++) {\n\t\t\t\n\t\t\tSystem.out.println(\"Enter element at index \" + i);\n\t\t\tarr[i] = s.nextInt();\n\t\t}\n\t\treturn arr;\n\t}\n\t// completes a linear search//////////////////////////////////////\n\tpublic static int linearSearch(int arr[], int x) {\n\t\t//Your code goes here\n\t    for(int i = 0; i < arr.length; i++){\n\t      if (arr[i] == x){\n\t        return i;\n\t      }\n\t      else{\n\t        continue;\n\t      }\n\t    }\n    return -1;\n    }\n////////////////////////////////////////////////////////\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\t\n\t\tint[] array = takeInput();\n\t\t\n\t\tint searchResult = linearSearch(array, 6); \n\t\t\n\t\tSystem.out.println(searchResult);\n\t}\n\n}\n"
        },
        {
          "fileName": "mergeSort.java",
          "code": "package Functions;\n\npublic class mergeSort {\n\tpublic static int[] split(int[] arr, int start, int end) {\n\t\tint middleIndex = (start + end)/2;\n\t\tint [] arr1 = new int[middleIndex];\n\t\tint [] arr2 = new int[end-arr1.length];\n\t\t\t\t\n\t\tfor(int i = start, j = 0; i < end; i++) {\n\t\t\tif(i < middleIndex) {\n\t\t\t\tarr1[i]=arr[i];\n\t\t\t}else {\n\t\t\t\tarr2[j]=arr[i];\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n//\t\tfor (int element : arr1) {\n//\t          System.out.println(\"arr1: \" + element);\n//\t      }\n//\t\tfor (int element : arr2) {\n//\t          System.out.println(\"arr2: \" + element);\n//\t      }\n\t\tint[] sortedArr1 = insertionSort(arr1);\n\t\tint[] sortedArr2 = insertionSort(arr2);\n\t\treturn merge2SortedArrays(sortedArr1, sortedArr2);\n\t}\n\t\t\n\tpublic static int[] insertionSort(int[] arr) {\n\t\t\n\t\tfor(int i = 1; i<arr.length; i++) {\n\t\t\t// insert the i'th element in the sorted array\n\t\t\tint j = i-1;\n\t\t\tint temp = arr[i];\n\t\t\t\n\t\t\twhile(j >= 0 && arr[j] > temp) {\n\t\t\t\tarr[j+1] = arr[j]; // shifts the elements to the right\n\t\t\t\tj--;\n\t\t\t}\n\t\t\t\n\t\t\tarr[j+1]=temp;\n\t\t}\n//\t\tfor (int element : arr) {\n//\t          System.out.println(\"arr: \" + element);\n//\t      }\n\t\treturn arr;\n\t}\n\t\n\tpublic static int[] merge2SortedArrays(int[] arr1, int[] arr2) {\n\t\tint[] sortedArray = new int[arr1.length + arr2.length];\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tint k = 0;\n\t\twhile(i < arr1.length && j < arr2.length) {\n\t\t\tif(arr1[i] <= arr2[j]) {\n\t\t\t\tsortedArray[k] = arr1[i];\n\t\t\t\ti++;\n\t\t\t\tk++;\n\t\t\t}else {\n\t\t\t\tsortedArray[k] = arr2[j];\n\t\t\t\tk++;\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\twhile(i < arr1.length) {\n\t\t\tsortedArray[k] = arr1[i];\n\t\t\ti++;\n\t\t\tk++;\n\t\t}\n\t\twhile(j < arr2.length) {\n\t\t\tsortedArray[k] = arr2[j];\n\t\t\tj++;\n\t\t\tk++;\n\t\t}\n//\t\tfor (int element : sortedArray) {\n//\t          System.out.println(\"arr: \" + element);\n//\t      }\n\t\treturn sortedArray;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t// breaks 1 array into 2 halves, sorts each half, and merges them back together sorted\n\t\tint[] array = {90, 31, 94, 80, 46, 28, 48, 31, 28, 90, 9, 27, 81, 43, 94, 5, 56, 13, 1, 23, 85, 71, 93, 53, 82 };\n\t\n\t\tint[] sorted = split(array, 0, array.length);\n\t\tfor (int element : sorted) {\n        System.out.println(\"arr: \" + element);\n    }\n\t}\n\n}\n"
        },
        {
          "fileName": "mergeTwoSortedArrays.java",
          "code": "package Functions;\n\npublic class mergeTwoSortedArrays {\n\t\n\tpublic static void printArray(int[] arr) {\n\t\tint n = arr.length;\n\t\tfor(int i = 0; i<n;i++) {\n\t\t\tSystem.out.print(arr[i]+\" \");\n\t\t}\n\t}\n\t\n\tpublic static int[] mergeSorted(int[] arr1, int[] arr2) {\n\t\tint m = arr1.length;\n\t\tint n = arr2.length;\n\t\tint[] arr3 = new int[m+n];\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tint k = 0;\n\t\twhile(i < m && j < n) {\n\t\t\tif(arr1[i] <= arr2[j]) {\n\t\t\t\tarr3[k] = arr1[i];\n\t\t\t\ti++;\n\t\t\t\tk++;\n\t\t\t}else {\n\t\t\t\tarr3[k] = arr2[j];\n\t\t\t\tk++;\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\twhile(i < m) {\n\t\t\tarr3[k] = arr1[i];\n\t\t\ti++;\n\t\t\tk++;\n\t\t}\n\t\twhile(j < n) {\n\t\t\tarr3[k] = arr2[j];\n\t\t\tj++;\n\t\t\tk++;\n\t\t}\n\t\treturn arr3;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tint[] arr1 = {2, 4, 5, 7, 9, 10, 11, 15};\n\t\tint[] arr2 = {1, 2, 3, 6, 8, 10, 13};\n\t\t\n\t\tint[] arr3 = mergeSorted(arr1,arr2);\n\t\tprintArray(arr3);\n\t}\n\n}\n"
        },
        {
          "fileName": "moreFunctions.java",
          "code": "package Functions;\n\npublic class moreFunctions {\n\t\n\tpublic static int func(int a){\n\t    a += 10;\n\t    return a;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t    int a = 5;\n\t    int b = func(a);\n\t    System.out.println(b);\n\t\t\n\t}\n\n}\n"
        },
        {
          "fileName": "moveNegativesToFront.java",
          "code": "package Functions;\nimport java.util.Arrays;\npublic class moveNegativesToFront {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tint[] a = {2, 4, -5, 7, -9, 10, -11, -5};  \n\t\t\n\t\tfor(int i= 0, j=0; i < a.length; i++){\n\t            if(a[i] < 0){\n\t                int temp = a[j];\n\t                a[j] = a[i];\n\t                a[i] = temp;\n\t                j++;\n\t            }\n\t        }System.out.println(Arrays.toString(a));\n\t}\n\n}\n"
        },
        {
          "fileName": "selectionSort.java",
          "code": "package Functions;\nimport java.util.Arrays;\npublic class selectionSort {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\t\n\t\t\n\t\t// the trick to sorting is to use the indexes, to compare the values, making to many stand in variable gets confusing\n\t\tint[] arr = {4, 11, 7, 4, 2, 6, 3, 4, 10, 9};\n\t\t\t\n\t\tint n = arr.length;\n\t\t\t\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\t\n\t\t\tint Val = arr[i];\n\t\t\tint minIndex = i;\n\t\t\t\t\n\t\t\t\tfor(int j = i; j<n; j++) {\n\t\t\t\t\t\n\t\t\t\t\tif(Val > arr[j]) {\n\t\t\t\t\t\tVal = arr[j];\n\t\t\t\t\t\tminIndex = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint temp = arr[i];\n\t\t\t\tarr[i] = arr[minIndex];\n\t\t\t\tarr[minIndex] = temp;\n\t\t\t\t\t\t\n\t\t\t}System.out.println(Arrays.toString(arr));\n\t    }    \n\n\t}\n"
        },
        {
          "fileName": "sortArrayOf012s.java",
          "code": "package Functions;\nimport java.util.Arrays;\npublic class sortArrayOf012s {\n\n\tpublic static int[] sort012(int[] arr) {\n\t\tfor(int i = 1; i<arr.length; i++) {\n\t\t\tint temp = arr[i];\n\t\t\tint j=i-1;\n\t\t\twhile(j >= 0 && arr[j] > arr[j+1]) {\n\t\t\t\tarr[j+1] = arr[j];\n\t\t\t\tarr[j]= temp;\n\t\t\t\tj--;\n\t\t\t}\n\t\t}return arr;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tint[] arr = {0,1,1,0,1,0,0,1};\n\t\t\n\t\tint[] arr2 = sort012(arr);\n\t\t\n\t\tSystem.out.print(Arrays.toString(arr2));\n\t}\n\n}\n"
        },
        {
          "fileName": "sumOfTwoArrays.java",
          "code": "package Functions;\nimport java.util.Arrays;\npublic class sumOfTwoArrays {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\t// integers are single digits\n\t\tint[] a = {1,3,5,4};\n\t\tint[] b = {2,1,3,5,9,6};\n\t\tint[] c = new int[a.length + b.length];\n\t\t\n\t\tint i = a.length - 1;\n\t\tint j= b.length -1;\n\t\tint k = (a.length > b.length) ? a.length : b.length;\n\t\t\n\t\tint carry = 0;\n\t\n\t\twhile(i >= 0 && j >= 0) {\n\t\t\tint total = a[i] + b[j] +carry;\n\t\t\tc[k] = total % 10;\n\t\t\tcarry = total/10;\n\t\t\t\n\t\t\ti-=1;\n\t\t\tj-=1;\n\t\t\tk-=1;\n\t\t\n\t\t}\n\t\twhile(i >= 0) {\n\t\t\tint total = a[i] + carry;\n\t\t\tc[k] = total %10;\n\t\t\tcarry = total/10;\n\t\t\ti-=1;\n\t\t\tk-=1;\n\t\t}\n\t\twhile(j>=0) {\n\t\t\tint total = b[j] + carry;\n\t\t\tc[k] = total %10;\n\t\t\tcarry = total/10;\n\t\t\tj-=1;\n\t\t\tk-=1;\n\t\t}\n\t\tc[0]=carry;\n\t\tSystem.out.print(Arrays.toString(c));\n\t}\n\n}\n"
        }
      ]
    },
    {
      "name": "GenericTrees",
      "files": [
        {
          "fileName": "GenericTreeNode.java",
          "code": "package GenericTrees;\n\nimport java.util.ArrayList;\n\npublic class GenericTreeNode<T> {\n\t// generic trees at the root contain an Array List that holds reference to its children\n\tT data;\n\tArrayList<GenericTreeNode<T>> children;\n\t\n\tpublic GenericTreeNode(T data) {\n\t\tthis.data = data;\n\t\tthis.children = new ArrayList<>();\n\t}\n\t///////////////////print pre order generic tree///////////////////////////////\n\t// print in pre-order not the best way because we don't know who the children belong to\n\tpublic void printTree(GenericTreeNode<T> root) {\n\t\t// special case, this is not a base case, base case is reached by the for loop, because it will not run if a child doesn't exist\n\t\tif(root == null) {\n\t\t\treturn;\n\t\t}\n\t\tSystem.out.println(root.data);\n\t\t// iterate over the array list references and print them, then call for the children, if they exist they will be printed\n\t\tfor(int i = 0; i < root.children.size(); i++) {\n\t\t\tGenericTreeNode<T> child = root.children.get(i);\n\t\t\tprintTree(child);\n\t\t}\n\t\t\n\t}\n\t///////////////////print tree better///////////////////\n\tpublic void printTreeBetter(GenericTreeNode<T> root) {\n\t\t// special case is main root == null\n\t\tif(root == null) {\n\t\t\treturn;\n\t\t}\n\t\tSystem.out.print(root.data + \": \");\n\t\tfor( int i = 0; i < root.children.size(); i++) {\n\t\t\tSystem.out.print(root.children.get(i).data + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t\tfor(int i = 0; i < root.children.size(); i++) {\n\t\t\tGenericTreeNode<T> child = root.children.get(i);\n\t\t\tprintTreeBetter(child);\n\t\t}\n\t}\n\t\n\t///////////////////////take input////////////////////////\n\t// put input into a queue\n\tpublic void takeInputLevelWise(GenericTreeNode<T> root) {\n\t\t\n\t}\n\t///////////////////////count number of nodes///////////////////\n\tpublic int countNodes(GenericTreeNode<T> root) {\n\t\tint count = 1;\n\t\tfor(int i = 0; i < root.children.size(); i++) {\n\t\t\tint childCount = countNodes(root.children.get(i));\n\t\t\tcount += childCount;\n\t\t}\n\t\treturn count;\n\t}\n\t\n\t//////////////////////sum of nodes////////////////////////////\n\tpublic int sumOfNodes(GenericTreeNode<T> root) {\n\t\tint data = (int)root.data;\n\t\tfor(int i = 0; i < root.children.size(); i++) {\n\t\t\tint childData = sumOfNodes(root.children.get(i));\n\t\t\tdata += childData;\n\t\t}\n\t\treturn data;\n\t}\n}\n"
        },
        {
          "fileName": "GenericTreeUse.java",
          "code": "package GenericTrees;\n\npublic class GenericTreeUse {\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\t// creates a new generic tree root containing 4 as its data, and an ArrayList with references to its children\n\t\tGenericTreeNode<Integer> root = new GenericTreeNode<Integer>(4);\n\t\t// creating many nodes\n\t\tGenericTreeNode<Integer> node1 = new GenericTreeNode<Integer>(2); \n\t\tGenericTreeNode<Integer> node2 = new GenericTreeNode<Integer>(3);\n\t\tGenericTreeNode<Integer> node3 = new GenericTreeNode<Integer>(1);\n\t\tGenericTreeNode<Integer> node4 = new GenericTreeNode<Integer>(5);\n\t\tGenericTreeNode<Integer> node5 = new GenericTreeNode<Integer>(6);\n\t\t// added the reference to roots' children\n\t\troot.children.add(node1);\n\t\troot.children.add(node2);\n\t\troot.children.add(node3);\n\t\t// added references to node2's children\n\t\tnode2.children.add(node4);\n\t\tnode2.children.add(node5);\n\t\t// print the generic tree\n\t\t//root.printTreeBetter(root);\n\t\t\n\t\t//System.out.println(root.countNodes(root));\n\t\tSystem.out.println(root.sumOfNodes(root));\n\t}\n\n}\n"
        }
      ]
    },
    {
      "name": "HackerRankProblems",
      "files": [
        {
          "fileName": "printSeries.java",
          "code": "package HackerRankProblems;\nimport java.util.*;\nimport java.io.*;\npublic class printSeries {\n\t/*We use the integers , , and  to create the following series:\n\t * \n\t * (a+2^(0)*b),(a+2^(0)*b+2^(1)*b),...(a+2^(0)*b+2^(1)*b+...+2^(n-1)*b)\n\n\t\tYou are given t queries in the form of a, b, and n. For each query, print the series corresponding to the given a, b, and n values as a single line of n space-separated integers.\n\n\t\tInput Format\n\n\t\tThe first line contains an integer, t, denoting the number of queries.\n\t\tEach line i of the q subsequent lines contains three space-separated integers describing the respective a, b, and n values for that query.\n\n\t\tConstraints\n\t\t\n\t\t0 <= t <= 500\n\t\t0<=a,b<=50\n\t\t1<=n<=15\n\t\t\n\t\tOutput Format\n\n\t\tFor each query, print the corresponding series on a new line. Each series must be printed in order as a single line of n space-separated integers.\n\n\t\tSample Input:\n\n\t\t2\n\t\t0 2 10\n\t\t5 3 5\n\t\t\n\t\tSample Output:\n\n\t\t2 6 14 30 62 126 254 510 1022 2046\n\t\t8 14 26 50 98\n\t\t\n\t\tExplanation:\n\n\t\tWe have two queries:\n\n\t\tWe use a=0, b=2, n=10 and  to produce some series s0, s1,...sn-1:\n\t\t\n\t\ts0 = 0 + 1*2 = 2\n\t\ts1 = 0 + 1*2 + 2*2 = 6\n\t\ts2 = 0 + 1*2 + 2*2 + 4*2 = 14\n\t\t\n\t\t... and so on.\n\n\t\tOnce we hit n=10, we print the first ten terms as a single line of space-separated integers.\n\n\t\tWe use a=5, b=3, n=5 and  to produce some series s0, s1,...sn-1:\n\t\t\n\t\ts0 = 5 + 1*3 = 8\n\t\ts1 = 5 + 1*3 + 2*3 = 14\n\t\ts2 = 5 + 1*3 + 2*3 + 4*3 = 26\n\t\ts3 = 5 + 1*3 + 2*3 + 4*3 + 8*3 = 50\n\t\ts4 = 5 + 1*3 + 2*3 + 4*3 + 8*3 + 16*3 = 98\n\n\t\tWe then print each element of our series as a single line of space-separated values.*/\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner in = new Scanner(System.in);\n        int t = in.nextInt();\n        // we are using nested for loop \n        for(int i = 0; i < t ; i++){\n            int a = in.nextInt();\n            int b = in.nextInt();\n            int n = in.nextInt();\n            int s = a;\n            // formula for the series (even though the examples gave a different example): a += 2^(j) * b\n            for (int j = 0; j < n; j++){\n                s += Math.pow(2,j) * b;\n                System.out.print(s + \" \" );\n            }System.out.println();\n        }\n        in.close();\n\n\t}\n\n}\n"
        },
        {
          "fileName": "system_out_printf_print_formating.java",
          "code": "package HackerRankProblems;\nimport java.util.Scanner;\npublic class system_out_printf_print_formating {\n\t/*Java's System.out.printf function can be used to print formatted output. The purpose of this exercise is to test your understanding of formatting output using printf.\n\n\tTo get you started, a portion of the solution is provided for you in the editor; you must format and print the input to complete the solution.\n\n\tInput Format\n\n\tEvery line of input will contain a String followed by an integer.\n\tEach String will have a maximum of  alphabetic characters, and each integer will be in the inclusive range from  to .\n\n\tOutput Format\n\n\tIn each line of output there should be two columns:\n\tThe first column contains the String and is left justified using exactly  characters.\n\tThe second column contains the integer, expressed in exactly  digits; if the original input has less than three digits, you must pad your output's leading digits with zeroes.\n\n\tSample Input\n\n\tjava 100\n\tcpp 65\n\tpython 50\n\tSample Output\n\n\t================================\n\tjava           100 \n\tcpp            065 \n\tpython         050 \n\t================================\n\tExplanation\n\n\tEach String is left-justified with trailing whitespace through the first 15 characters. \n\tThe leading digit of the integer is the 16th character, \n\tand each integer that was less than 3 digits now has leading zeroes.*/\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc=new Scanner(System.in);\n\t\t\n        System.out.println(\"================================\");\n        \n        for(int i=0;i<3;i++){\n            String s1 = sc.next();\n            int x = sc.nextInt();\n            \n            //Complete this \n            System.out.printf(\"%-15s%03d%n\", s1, x);\n        }\n        \n        System.out.println(\"================================\");\n\n\t}\n\n}\n"
        }
      ]
    },
    {
      "name": "JavaCalculator",
      "files": [
        {
          "fileName": "CalculatorApp.java",
          "code": "package JavaCalculator;\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\n\npublic class CalculatorApp {\n    public static void main(String[] args) {\n        JFrame frame = new JFrame(\"Calculator\");\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\n        JPanel panel = new JPanel();\n        panel.setLayout(new GridLayout(4, 4));\n\n        JTextField resultField = new JTextField(10);\n        panel.add(resultField);\n\n        String[] buttonLabels = {\"7\", \"8\", \"9\", \"/\", \"4\", \"5\", \"6\", \"*\", \"1\", \"2\", \"3\", \"-\", \"0\", \".\", \"=\", \"+\"};\n        for (String label : buttonLabels) {\n            JButton button = new JButton(label);\n            button.addActionListener(new ActionListener() {\n                @Override\n                public void actionPerformed(ActionEvent e) {\n                    String currentText = resultField.getText();\n                    String buttonText = e.getActionCommand();\n                    resultField.setText(currentText + buttonText);\n                }\n            });\n            panel.add(button);\n        }\n\n        frame.add(panel);\n        frame.pack();\n        frame.setVisible(true);\n    }\n}\n"
        }
      ]
    },
    {
      "name": "LoopVariations",
      "files": [
        {
          "fileName": "BinaryToDecimal.java",
          "code": "package LoopVariations;\n\nimport java.util.Scanner;\n\npublic class BinaryToDecimal {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner s = new Scanner(System.in);\n\t\tint n = s. nextInt();\n//\t\t// convert binary to decimal\n//\t\tint result = 0;\n//\t\tfor(int i = 0; n > 0; i++ ) {\n//\t\t\tint lastDigit = n % 10;\n//\t\t\tint convert = lastDigit * (int)Math.pow(2, i);\n//\t\t\tresult = result + convert;\n//\t\t\t\n//\t\t\tn /= 10;\n//\t\t}System.out.println(result);\n\t\t\n\t\t\n\t\t// convert decimal to binary\n\t\tString result = Integer.toBinaryString(n);\n\t\tSystem.out.println(result);\n\t\t\n\t\t// square root\n\t\t//System.out.println((int)Math.floor((Math.sqrt(n))));\n\t}\n\n}\n"
        },
        {
          "fileName": "Exampleofrecursion.java",
          "code": "package LoopVariations;\n\npublic class Exampleofrecursion {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\t\n//\t\tthis is an example of a recursive function that calls itself and updates itself\n\t\t// this is the formula for Greatest common divisor:\n\t\t\n//\t\tpublic class Solution {\n\t\t\n//\t\t\tpublic static int findGcd(int x, int y) {\n//\t\t\t\t\n//\t\t\t\tif (y == 0) {\n//\t\t        \treturn x;\n//\t\t\t} \telse {\n//\t\t        \treturn findGcd(y, x % y);\n//\t\t\t\t}\n}\n\n}\n"
        },
        {
          "fileName": "MorePatterns.java",
          "code": "package LoopVariations;\nimport java.util.Scanner;\npublic class MorePatterns {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner s = new Scanner(System.in);\n\t\tint n = s.nextInt();\n\t\t\n//\t\tint i = 1;\n//\t\twhile(i <= n) {\n//\t\t\tint j = n;\n//\t\t\twhile (j > i) {\n//\t\t\t\tif(i == n) {\n//\t\t\t\t\tj--;\n//\t\t\t\t}\n//\t\t\t\tSystem.out.print(j);\n//\t\t\t\tj--;\n//\t\t\t\t}int k = j;\n//\t\t\t\twhile(k == i) {\n//\t\t\t\tSystem.out.print(\"*\");\n//\t\t\t\tk--;\n//\t\t\t\tj--;\n//\t\t\t\t}while(j >=1) {\t\t\t\n//\t\t\t\tSystem.out.print(j);\n//\t\t\t\tj--;\n//\t\t\t\t}\n//\t\t\tSystem.out.println();\n//\t\t\ti++;\n//\t\t}\n\t\tint i = 0;\n\t\twhile (i < n) {\n\t\t    int j = 0;\n\t\t    while (j < i) {\n\t\t        System.out.print(\" \");\n\t\t        j++;\n\t\t    }\n\t\t    int k = i;\n\t\t    while (k < n) {\n\t\t        System.out.print(\"*\");\n\t\t        k++;\n\t\t    }\n\t\t    System.out.println();\n\t\t    i++;\n\t\t}\n\t\t\n\t}\n\n}\n"
        },
        {
          "fileName": "PrimeNumbers.java",
          "code": "package LoopVariations;\n\nimport java.util.Scanner;\n\npublic class PrimeNumbers {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner s = new Scanner(System.in);\n\t\tint n = s.nextInt();\n\t\t\n\t\tfor(int i = 2; i <= n; i++) {\n\t\t\t\n\t\t\tfor(int j = 2; j <= i; j++) {\n\t\t\t\t\n\t\t\t\tint k = i % j;\n\t\t\t\t\n\t\t\t\tif ( j < i && k == 0) {\n\t\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\t}else if(j == i) {\n\t\t\t\tSystem.out.println(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n"
        },
        {
          "fileName": "ReverseOfNumber.java",
          "code": "package LoopVariations;\nimport java.util.Scanner;\npublic class ReverseOfNumber {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\t\n\t\tScanner s = new Scanner(System.in);\n\t\tint n = s. nextInt();\n//       \n//        \n//\n//        String reversedString = new StringBuilder(String.valueOf(n)).reverse().toString();\n//        \n//        String nonTrailingZerosString = reversedString.replaceAll(\"0*$\", \"\");\n//        \n//        int nonTrailingZerosNumber = Integer.parseInt(nonTrailingZerosString);\n//\n//        System.out.println(\"The reverse of the number is \" + nonTrailingZerosNumber);\n//        \n//        alternatives:\n\t\t\n//        int reverse = 0;\n//        while (n > 0) {\n//            int digit = n % 10;\n//            if (digit != 0) {\n//                reverse = reverse * 10 + digit;\n//            }\n//            n /= 10;\n//        }\n//\n//        System.out.println(\"The reverse of the number is \" + reverse);\n        \n        \n        int reverse = 0;\n        while (n > 0) {\n            int digit = n % 10;\n            reverse = reverse * 10 + digit;\n            n /= 10;\n        }\n\n        System.out.println(\"The reverse of the number is \" + reverse);\n\t}\n\n}\n"
        },
        {
          "fileName": "SumOrProduct.java",
          "code": "package LoopVariations;\nimport java.util.Scanner;\npublic class SumOrProduct {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner s = new Scanner(System.in);\n\t\tint n = s.nextInt();\n//\t\tint choice = s.nextInt();\n//\t\t\n//\t\tif(choice == 1) {\n//\t\t\tint sum = 0, num = 1;\n//\t\t\twhile(num <= n) {\n//\t\t\t\tsum += num;\n//\t\t\t\tnum++;\n//\t\t\t}\n//\t\t\tSystem.out.println(sum);\n//\t\t}\n//\t\telse if(choice ==2) {\n//\t\t\tint product = 1, num = 1;\n//\t\t\twhile(num <= n) {\n//\t\t\t\tproduct *= num;\n//\t\t\t}\n//\t\t\tSystem.out.println(product);\n//\t\t}\n//\t\telse {\n//\t\t\tSystem.out.println(\"-1\");\n//\t\t}\n//\t\tprint first n terms, of 3x+2 but omit multiples of 4.\n\t\tfor(int i = 1, j = 1; j <= n; i++, j++){\n\t\t\tint x = (3*i)+2;\n\t\t\tif (x % 4 == 0){\n\t\t\t\tj--;\n\t\t\t\tcontinue;\n\t\t\t}else{\n\t\t\t\tSystem.out.print(x + \" \");\n\t\t\t}\n\t\t}\n\t}\n\n}\n"
        },
        {
          "fileName": "forLoopVariations.java",
          "code": "package LoopVariations;\n\npublic class forLoopVariations {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\t\n//\t\tfor(int i = 1; i <= 5; i++) {\n//\t\t\tfor(int j=1; j<=4; j++) {\n//\t\t\t\tSystem.out.println(\"i \"+ i + \" j \"+ j);\n//\t\t\t}\n//\t\t}\n//\t\tfor(int i = 1, j = 100; i<=5 && j<=200; i++, j+=40) {\n//\t\t\tSystem.out.println(i +\" \"+ j);\n//\t\t}\n//\t\tprint prime numbers, 2 -> n, (both inclusive)\n\n\t}\n\n}\n"
        }
      ]
    },
    {
      "name": "ObjectOrientedPrograming",
      "files": [
        {
          "fileName": "ComplexNumber.java",
          "code": "package ObjectOrientedPrograming;\n\npublic class ComplexNumber {\n\n\t\t// Complete this class\n\t\tint real;\n\t    int imag;\n\n\t    // Constructor\n\t    public ComplexNumber(int real, int imag) {\n\t        this.real = real;\n\t        this.imag = imag;\n\t    }\n\n\t    // Plus\n\t    public void plus(ComplexNumber c2) {\n\t        this.real += c2.real;\n\t        this.imag += c2.imag;\n\t    }\n\n\t    // Multiply\n\t    public void multiply(ComplexNumber c2) {\n\t        int real = this.real * c2.real - this.imag * c2.imag;\n\t        int imag = this.imag * c2.real + this.real * c2.imag;\n\t        this.real = real;\n\t        this.imag = imag;\n\t    }\n\n\t    // Print\n\t    public void print() {\n\t        System.out.println(this.real + \" + i\" + this.imag);\n\t    }\n\t}\n//While complex and imaginary numbers are related, they are not the same.\n//\n//Imaginary numbers are a subset of complex numbers.\n//\n//Imaginary Numbers: These are numbers that when squared, result in a negative number. They're based on the imaginary unit, which is denoted by the symbol \"i\", where i is the square root of -1. Any multiple of \"i\" is considered an imaginary number. For instance, 2i, 5i, and -3i are all imaginary numbers.\n//\n//Complex Numbers: A complex number is a number that can be expressed in the form a + bi, where 'a' and 'b' are real numbers, and 'i' is the imaginary unit. The 'a' part is known as the real part, while 'bi' is known as the imaginary part. If b is not zero, then the complex number is said to have both a real part and an imaginary part. If b is zero, then it's just a real number. If 'a' is zero and 'b' is not, then it's an imaginary number.\n//\n//So while all imaginary numbers are complex numbers, not all complex numbers are imaginary numbers because complex numbers also include real numbers.\n//----------------------------------------------------------------------------------------------------------------------------------\n//Complex numbers are essential in many fields of science and engineering. Some of the primary use cases include:\n//\n//Electrical Engineering: Complex numbers are used extensively in electrical engineering, especially in signal analysis and electronics. The imaginary part of a complex number is used to represent the amplitude of a signal's oscillation, while the real part represents the phase shift. This is often used in analysis of AC circuits and signal processing.\n//\n//Physics: In quantum mechanics, complex numbers are used to calculate the probability of different outcomes. The wave function, which describes the state of a quantum system, is a complex-valued function.\n//\n//Control Theory: Complex numbers are used to analyze system stability in control theory. In this context, the roots of a certain characteristic equation determine the system's behavior over time.\n//\n//Mathematics: Complex numbers are used to find solutions to equations that have no solutions in the real numbers. For example, the equation x + 1 = 0 has no solution when only real numbers are considered, but it does when complex numbers are used.\n//\n//Computer Science: Complex numbers are often used in graphics, simulations, and calculations involving rotations. They are also used in certain algorithms, like the Fast Fourier Transform (FFT), which is essential in signal and image processing.\n//\n//Engineering: They are used in fluid dynamics, electromagnetic field theory, and other similar domains."
        },
        {
          "fileName": "ComplexNumberUse.java",
          "code": "package ObjectOrientedPrograming;\nimport java.util.Scanner;\npublic class ComplexNumberUse {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\t\n\t\t\tScanner s = new Scanner(System.in);\n\n\t\t\tint real1 = s.nextInt();\n\t\t\tint imaginary1 = s.nextInt();\n\n\t\t\tint real2 = s.nextInt();\n\t\t\tint imaginary2 = s.nextInt();\n\n\t\t\tComplexNumber c1 = new ComplexNumber(real1, imaginary1);\n\t\t\tComplexNumber c2 = new ComplexNumber(real2, imaginary2);\n\n\t\t\tint choice = s.nextInt();\n\t\t\t \n\t\t\tif(choice == 1) {\n\t\t\t\t// Add\n\t\t\t\tc1.plus(c2);\n\t\t\t\tc1.print();\n\t\t\t}\n\t\t\telse if(choice == 2) {\n\t\t\t\t// Multiply\n\t\t\t\tc1.multiply(c2);\n\t\t\t\tc1.print();\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\n\t}\n\n}\n//While complex and imaginary numbers are related, they are not the same.\n//\n//Imaginary numbers are a subset of complex numbers.\n//\n//Imaginary Numbers: These are numbers that when squared, result in a negative number. They're based on the imaginary unit, which is denoted by the symbol \"i\", where i is the square root of -1. Any multiple of \"i\" is considered an imaginary number. For instance, 2i, 5i, and -3i are all imaginary numbers.\n//\n//Complex Numbers: A complex number is a number that can be expressed in the form a + bi, where 'a' and 'b' are real numbers, and 'i' is the imaginary unit. The 'a' part is known as the real part, while 'bi' is known as the imaginary part. If b is not zero, then the complex number is said to have both a real part and an imaginary part. If b is zero, then it's just a real number. If 'a' is zero and 'b' is not, then it's an imaginary number.\n//\n//So while all imaginary numbers are complex numbers, not all complex numbers are imaginary numbers because complex numbers also include real numbers.\n"
        },
        {
          "fileName": "DynamicArray.java",
          "code": "package ObjectOrientedPrograming;\n\npublic class DynamicArray {\n\t// keep an internal array\n\t\n\tprivate int data[];\n\t\n\tprivate int nextElementIndex;\n\t\n\tpublic DynamicArray(){\n\t\tdata = new int[5];\n\t\tnextElementIndex = 0;\t\t// sets initial element index to 0, so when calling add() an element is added to the next open index\n\t}\n\t\n\tpublic int size() {\n\t\treturn nextElementIndex;\n\t}\n\t\n\tpublic boolean isEmpty() {\n\t\treturn nextElementIndex == 0;\n\t}\n\t\n\tpublic int get(int i) {\n\t\tif(i >= nextElementIndex) {\n\t\t\t// throw error i is out of bounds\n\t\t\treturn -1;\t\n\t\t}\n\t\treturn data[i];\n\t}\n\t\n\tpublic void set(int i, int num) {\n\t\tif(i >= nextElementIndex) {\n\t\t\t// throw error\n\t\t\treturn;\n\t\t}\n\t\tdata[i] = num;\n\t\t\n\t}\n\t\n\tpublic void add(int elem) {\n\t\tif(nextElementIndex == data.length) {\n\t\t\tincreaseCapacity(elem);\n\t\t}\n\t\t data[nextElementIndex] = elem;\n\t\t nextElementIndex+=1;\n\t}\n\t\n\tprivate void increaseCapacity(int elem) {\n\t\tint[] newData = new int[data.length+1];\n\t\tfor(int i = 0, j = elem; i < data.length+1; i++) {\n\t\t\tif(i < data.length) {\n\t\t\tnewData[i] = data[i];\n\t\t\t}else {\n\t\t\t\tnewData[i]=j;\n\t\t\t}\n\t\t}\n\t\tdata = newData;\n\t}\n\n\tpublic void removeLast() {\n\t\tif(nextElementIndex == 0) {\n\t\t\treturn;\t\t// if array is empty, return\n\t\t}\n\t\tint[] newData = new int[data.length-1];\n\t\tfor(int i = 0; i < newData.length; i++) {\n\t\t\tnewData[i] = data[i];\n\t\t}\n\t\tnextElementIndex --;\n\t\tdata = newData;\n\t}\n\t\n\tpublic int length() {\n\t\treturn data.length;\n\t}\n\t\n}\n"
        },
        {
          "fileName": "DynamicArrayUse.java",
          "code": "package ObjectOrientedPrograming;\nimport java.util.ArrayList;\npublic class DynamicArrayUse {\n\n\tpublic static void main(String[] args) {\n\t\tDynamicArray d = new DynamicArray();\n\t\t\n\t\tfor(int i = 1; i < 10; i++) {\n\t\t\td.add(10 + i);\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tSystem.out.println(d.size());\n\t\t\n\t\tSystem.out.println(d.get(0));\n\t\tSystem.out.println(d.get(1));\n\t\tSystem.out.println(d.get(2));\n\t\tSystem.out.println(d.get(3));\n\t\tSystem.out.println(d.get(4));\n\t\tSystem.out.println(d.get(5));\n\t\tSystem.out.println(d.get(6));\n\t\tSystem.out.println(d.get(7));\n\t\tSystem.out.println(d.get(8));\n\t\t\n\t\t\n\t\t\n\t\tSystem.out.println(d.length());\n\t\t\n\t\td.add(2);\n\t\t\n\t\tSystem.out.println(d.get(0));\n\t\tSystem.out.println(d.get(1));\n\t\tSystem.out.println(d.get(2));\n\t\tSystem.out.println(d.get(3));\n\t\tSystem.out.println(d.get(4));\n\t\tSystem.out.println(d.get(5));\n\t\tSystem.out.println(d.get(6));\n\t\tSystem.out.println(d.get(7));\n\t\tSystem.out.println(d.get(8));\n\t\tSystem.out.println(d.get(9));\n\t\t\n\t\tSystem.out.println(d.length());\n//\t\t\n\t\td.removeLast();\n\t\tSystem.out.println(\"space\");\n\t\tSystem.out.println(d.get(8));\n\t\t\n\t\tSystem.out.println(d.length());\n//\t\td.set(3, 170);\n//\t\tSystem.out.println(d.get(3));\n//\t\t\n//\t\twhile(! disEmpty()) {\n//\t\t\tSystem.out.println(d.removeLast());\n//\t\t\tSystem.out.println(\"size -\" + d.size());\n//\t\t\t\n//\t\t}\n\t\t\n\t}\n\n}\n"
        },
        {
          "fileName": "Fraction.java",
          "code": "package ObjectOrientedPrograming;\n\npublic class Fraction {\n\t\n\tprivate int numerator;\n\tprivate int denominator;\n\t\n\tpublic Fraction( int numerator,int denominator) {\n\t\tif(denominator == 0) {\n\t\t\tdenominator = 1;\n\t\t\treturn;\n\t\t}\n\t\tthis.denominator = denominator;\n\t\tthis.numerator = numerator;\n\t\tsimplify();\n\t}\n\t\n\tpublic void setNumerator(int num) {\n\t\tthis.numerator = num;\n\t\tsimplify();\n\t}\n\t\n\tpublic void setDenominator(int num) {\n\t\tif(num == 0) {\n\t\t\treturn;\n\t\t}\n\t\tthis.denominator = num;\n\t\tsimplify();\n\t}\n\t\n\tpublic int getNumerator() {\n\t\treturn numerator;\n\t\n\t}\n\t\n\tpublic int getDenominator() {\n\t\treturn denominator;\n\t}\n\t\n\tprivate void simplify() {\n//\t\tint smallestNum = numerator > denominator ? denominator : numerator == denominator ? denominator : numerator < denominator ? numerator : null;\n\t\tint smallestNum = Math.min(numerator, denominator);   //alternative approach\n\t\tint gcd = 1;\n\t\tfor(int i = 1; i <= smallestNum; i++) {\n\t\t\tif(numerator % i == 0 && denominator % i == 0) {\n\t\t\t\tgcd = i;\n\t\t\t}\n\t\t}\n\t\tnumerator /= gcd;\n\t\tdenominator /= gcd;\n\t}\n\t\n\tpublic void print() {\n\t\tSystem.out.println(numerator + \"/\" + denominator);\n\t}\n\t\n\tpublic void increment(int num) {\n\t\tnum *= denominator;\n\t\tnumerator += num;\n\t\tsimplify();\n\t}\n\t\n\tpublic void addFractions(Fraction f2) {\n\t\t// first fraction is the fraction which this method is called on, so we must use \"this\" to reference the first fraction\n\t\t// second fraction is passed as an argument\n\t\tthis.numerator = this.numerator * f2.denominator + this.denominator * f2.numerator;\n\t\tthis.denominator = this.denominator * f2.denominator;\n\t\tsimplify();\n\t\t\n\t}\n//\tadd 2 fractions together\n//\tpass it the 2 fractions we want to add\n//\tthis is static because its being used between multiple objects in the class\n//\treturn type is Fraction object\n\tpublic static Fraction add(Fraction f1, Fraction f2) {\n//\t\tthis is taking 2 objects as parameters and returning a new object after calculating them\n\t\tint newNum = f1.numerator * f2.denominator + f1.denominator * f2.numerator;\n\t\tint newDenominator = f1.denominator * f2.denominator;\n\t\tFraction f3 = new Fraction(newNum, newDenominator);\n\t\treturn f3;\n\t}\n\tpublic void subtractFractions(Fraction f2) {\n\t\t// first fraction is the fraction which this method is called on, so we must use \"this\" to reference the first fraction\n\t\t// second fraction is passed as an argument\n\t\tthis.numerator = this.numerator * f2.denominator - this.denominator * f2.numerator;\n\t\tthis.denominator = this.denominator * f2.denominator;\n\t\tsimplify();\n\t}\n\t\n\tpublic static Fraction subtract(Fraction f1, Fraction f2) {\n//\t\tthis is taking 2 objects as parameters and returning a new object after calculating them\n\t\tint newNumerat = f1.numerator * f2.denominator - f1.denominator * f2.numerator;\n\t\tint newDenominat = f1.denominator * f2.denominator;\n\t\tFraction f3 = new Fraction(newNumerat,newDenominat);\n\t\treturn f3;\n\t}\n\tpublic void multiply(Fraction f2) {\n\t\t// first fraction is the fraction which this method is called on, so we must use \"this\" to reference the first fraction\n\t\t// second fraction is passed as an argument\n\t\tthis.numerator = this.numerator * f2.numerator;\n\t\tthis.denominator = this.denominator * f2.denominator;\n\t\tsimplify();\n\t}\n\tpublic static Fraction multiplyFractions(Fraction f1, Fraction f2) {\n\t\tint newNumerator = f1.numerator * f2.numerator;\n\t\tint newDenominator = f1.denominator * f2.denominator;\n\t\tFraction f3 = new Fraction(newNumerator, newDenominator);\n\t\treturn f3;\n\t}\n}\n"
        },
        {
          "fileName": "FractionUse.java",
          "code": "package ObjectOrientedPrograming;\n\npublic class FractionUse {\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tFraction f1 = new Fraction(4,6);\n\t\t\n\t\tf1.print();\n\t\t\n//\t\tf1.increment(3);\n//\t\tf1.print();\n\n\t\tFraction f2 = new Fraction(4,8);\n\t\t\n//\t\tf1.addFractions(f2);\n\t\tf2.print();\n\t\t\n//\t\tf1.addFractions(f2);\n\t\tf1.print();\n\t\t\n//\t\tf1.subtractFractions(f2);\n\t\tf1.print();\n\t\t\n\t\tf1.multiply(f2);\n\t\tf1.print();\n\t\t\n//\t\tFraction f3 = Fraction.multiplyFractions(f1, f2);\n//\t\tf3.print();\n\n\t}\n\n}\n"
        },
        {
          "fileName": "Polynomial.java",
          "code": "\n\n\n\npackage ObjectOrientedPrograming;\n\nimport java.util.*;\n\npublic class Polynomial {\n\n    private Map<Integer, Integer> terms = new TreeMap<>();\n\n    public void setCoefficient(int degree, int coeff) {\n        terms.put(degree, coeff);\n    }\n\n    public Polynomial add(Polynomial p) {\n        Polynomial result = new Polynomial();\n\n        for (Integer degree : this.terms.keySet()) {\n            result.setCoefficient(degree, this.terms.get(degree));\n        }\n\n        for (Integer degree : p.terms.keySet()) {\n            result.setCoefficient(degree, result.terms.getOrDefault(degree, 0) + p.terms.get(degree));\n        }\n\n        return result;\n    }\n\n    public Polynomial subtract(Polynomial p) {\n        Polynomial result = new Polynomial();\n\n        for (Integer degree : this.terms.keySet()) {\n            result.setCoefficient(degree, this.terms.get(degree));\n        }\n\n        for (Integer degree : p.terms.keySet()) {\n            result.setCoefficient(degree, result.terms.getOrDefault(degree, 0) - p.terms.get(degree));\n        }\n\n        return result;\n    }\n\n    public Polynomial multiply(Polynomial p) {\n        Polynomial result = new Polynomial();\n\n        for (Integer degree1 : this.terms.keySet()) {\n            for (Integer degree2 : p.terms.keySet()) {\n                int newDegree = degree1 + degree2;\n                int newCoeff = this.terms.get(degree1) * p.terms.get(degree2);\n\n                result.setCoefficient(newDegree, result.terms.getOrDefault(newDegree, 0) + newCoeff);\n            }\n        }\n\n        return result;\n    }\n\n    public void print() {\n        StringBuilder sb = new StringBuilder();\n\n        for (Integer degree : terms.keySet()) {\n            int coeff = terms.get(degree);\n\n            if (coeff != 0) {\n                sb.append(coeff + \"x\" + degree + \" \");\n            }\n        }\n\n        if (sb.length() > 0) {\n            sb.setLength(sb.length() - 1);  // remove the last space\n        }\n\n        System.out.println(sb.toString());\n    }\n}\n\n"
        },
        {
          "fileName": "PolynomialUse.java",
          "code": "package ObjectOrientedPrograming;\n\npublic class PolynomialUse {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\t\n\t\tPolynomial p1 = new Polynomial();\n\t\t\n\t\tp1.print();\n\t\t\n\t\tPolynomial p2 = new Polynomial();\n\t\t\n\t\tp2.print();\n\t\t\n\t}\n\n}\n"
        },
        {
          "fileName": "Student.java",
          "code": "package ObjectOrientedPrograming;\n\npublic class Student {\n//\taccess modifiers: add private before an attribute to prevent access outside of the class\n//\tprivate String email;\t// restricts access to only within the class\n\n\tprivate String name;\t\t// private only allows access within the class// use private when you want to control access to the variable\n\tfinal  private int rollNumber;\n\tdouble gpa;\n\tpublic final static double conversionFactor = 0.95;\t// final keyword wont allow the value to be changed. for variables who's value is assigned only once.\n\tprivate static int numStudents;\t\t// static properties are shared by all objects. makes this property one property that is not multiple copies for each object, keeps track of quantity of students\n\n\t\n\tpublic Student(String n) {\t//\tconstructor function, does not take a return type. Constructor must match the class name.\n\t\tname = n;\n\t\tnumStudents++;\t// keeps count of total number of students\n\t\trollNumber = numStudents; // doing this will increment rollNumber for each student\n\t\t\n\t}\n\t\n\tpublic static int getNumStudents() {\t\t// this variable is shared, therefore its static\n//\t\tSystem.out.println(rollNumber);\t\t\t// cannot access non-static properties within a static function\n\t\treturn numStudents;\t\t\t\t\t\n\t}\n\t//to allow flexibility to not require rollNUmber we need to make another constructor function\n\t\n//\tpublic Student(String n) {\n//\t\tname = n;\n////\t\tusing only this constructor rollNumber will default to 0\n//\t}\n\t\n//\tfunction to print\n\t\n\tpublic void print() {\n\t\tSystem.out.println(name + \" \" + rollNumber);\n\t}\n\t\n\t\n//\tgetter and setter methods\n\t\n\tpublic int getRollNumber() {\n\t\treturn rollNumber;\n\t}\n\t\n//\tpublic void setRollNumber(int rollNumber) {\n//\t\tif(rollNumber <= 0) {\n//\t\t\treturn;\n//\t\t}\n//\tthis.rollNumber = rollNumber;\t// this references the current object.property and sets it \n//\t}\n//\t\n}\n"
        },
        {
          "fileName": "StudentUse.java",
          "code": "package ObjectOrientedPrograming;\n\n\npublic class StudentUse {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\t\n//\t\tCreating a new student object\n//\t\ts1 and s2 are stored in the stack, while the student object is stored in the heap\n//\t\tSystem.out.println(Student.getNumStudents());\n\t\t\n\t\tStudent s1 = new Student(\"Guy\");\t\t\n\t\t//s1.print(); // prints roll number as specified in student class\n\t\t\n//\t\tSystem.out.println(s1.name+ \" \" + s1.getRollNumber());\n\t\t\n\t\t// roll number is private but the getter and setter methods can still access it and change it\n//\t\ts1.rollNumber = 4;\n\t\t\n\t\t\n\t\t\n\t\tStudent s2 = new Student(\"Morgan\");\n\n\t\t//s2.print();\n\t\tSystem.out.println(s2.getRollNumber());\n\t\t\n\t\tSystem.out.println(s1.getNumStudents());\n\t\tSystem.out.println(s2.getNumStudents());\n\t\tStudent s3 = new Student(\"Name\");\n\t\t\n\t\t\n\t}\n\n}\n"
        }
      ]
    },
    {
      "name": "Patterns",
      "files": [
        {
          "fileName": "AlphabetPatterns.java",
          "code": "//package Patterns;\n//import java.util.Scanner;\n//public class AlphabetPatterns {\n//\n//\tpublic static void main(String[] args) {\n//\t\t// TODO Auto-generated method stub\n//\t\tScanner s = new Scanner(System.in);\n//\t\t\n//\t\tint n = s.nextInt();\n////\t\tPrint this pattern: for n=4:\n////\t\tABCD\n////\t\tABCD\n////\t\tABCD\n////\t\tABCD\n//\t\tint i = 1;\n//\t\twhile(i <= n) {\n//\t\t\tint j = 1;\n//\t\t\twhile(j <= n) {\n//\t\t\t\tSystem.out.print((char)('A'+j-1));\t// here we are explicitly typecasting 'A'+1 into a char to print the letter from the ASCII table\n//\t\t\t\tSystem.out.print('.');\n//\t\t\t\tj++;\n//\t\t\t}System.out.println();\n//\t\t\ti++;\n//\t\t}\n//\t\tSystem.out.println();     // print new line for spacing\n////\t\tPrint this pattern: using n as input:\n////\t\tA\n////\t\tAB\n////\t\tABC\n//\t\tint a = 1;\n//\t\twhile (a <= n) {\n//\t\t\tint b = 1;\n//\t\t\twhile (b <= a) {\n//\t\t\t\tSystem.out.print((char)('A' + b-1));\n//\t\t\t\tb++;\n//\t\t\t}System.out.println();\n//\t\t\ta++;\n//\t\t}\n//\t\tSystem.out.println();     // print new line for spacing\n////\t\tPrint this pattern: using n as input:\n////\t\tABCD\n////\t\tBCDE\n////\t\tCDEF\n////\t\tDEFG\n//\t\tint c = 1;\n//\t\twhile(c <= n) {\n//\t\t\tint d = 1;\n//\t\t\tchar ch = (char)('A'+ c -1);\n//\t\t\twhile (d <= n) {\n//\t\t\t\tSystem.out.print(ch);\n//\t\t\t\tch = (char)(ch+1);\n//\t\t\t\td++;\n//\t\t\t}System.out.println();\n//\t\t\tc++;\n//\t\t}\n//\t}\t\n//\n//}\n"
        },
        {
          "fileName": "Pattern2.java",
          "code": "//package Patterns;\n//import java.util.Scanner;\n//public class Pattern2 {\n//\n//\tpublic static void main(String[] args) {\n//\t\t// TODO Auto-generated method stub\n//\t\tScanner s = new Scanner(System.in);\n////\t\tPrint this pattern:\n////\t\t1111\n////\t\t2222\n////\t\t3333\n////\t\t4444\n//\t\tint n = s.nextInt();\n//\t\tint i = 1;\n//\t\twhile(i <= n) {\n//\t\t\tint j = 1;\n//\t\t\twhile(j <= n) {\n//\t\t\t\tSystem.out.print(i);\n//\t\t\t\tj++;\n//\t\t\t}System.out.println();\n//\t\t\ti++;\n//\t\t}\n//\t\tSystem.out.println();     // print a line to create spacing\n////\t\tnow print this pattern:\n////\t\t1234\n////\t\t1234\n////\t\t1234\n////\t\t1234\n////\t\tuse input n already taken:\n//\t\tint l = 1;\n//\t\twhile(l <= n) {\n//\t\t\tint m = 1;\n//\t\t\twhile(m <= n) {\n//\t\t\t\tSystem.out.print(m);\n//\t\t\t\tm++;\n//\t\t\t}System.out.println();\n//\t\t\tl++;\n//\t\t}\n//\t\tSystem.out.println();     // print a line to create spacing\n////\t\tNow print this pattern:\n////\t\t4321\n////\t\t4321\n////\t\t4321\n////\t\t4321\n////\t\tUse input n already taken:\n//\t\tint a = 1;\n//\t\twhile(a <= n) {\n//\t\t\tint b = 1;\n//\t\t\twhile(b <= n) {\n//\t\t\t\tSystem.out.print((n+1) - b);\n//\t\t\t\tb++;\n//\t\t\t}System.out.println();\n//\t\t\ta++;\n//\t\t}\n//\t\t\n//\n//\t\t\n//\t}\n//\n//}\n"
        },
        {
          "fileName": "PrintDiamond.java",
          "code": "//\n//package Patterns;\n//import java.util.Scanner;\n//public class PrintDiamond {\n//\n//\tpublic static void main(String[] args) {\n//\t\t// TODO Auto-generated method stub\n//\t      Scanner s = new Scanner(System.in);\n//\t        \n//\t        int n = s.nextInt();\n//\n////\t        int i = 1;\n////\t        int spaces, stars;\n////\n////\t        while (i <= n) {\n////\t            spaces = Math.abs((n- 1) / 2 - i + 1);\n////\t            stars = n - 2 * spaces;\n////\n////\t            int j= 1;\n////\t            while (j <= spaces) {\n////\t                System.out.print(\" \");\n////\t                j++;\n////\t            }\n////\n////\t            int m = 1;\n////\t            while (m <= stars) {\n////\t                System.out.print(\"*\");\n////\t                m++;\n////\t            }\n////\n////\t            System.out.println();\n////\t            i++;\n////\t        }\n////\t        print this pattern: n=3\n////\t        *\n////\t        *1*\n////\t        *121*\n////\t        *12321*\n////\t        *121*\n////\t        *1*\n////\t        *\n//\t        System.out.println('*');\n//\t        // first half\n//\t        int currRow = 1;\n//\t        \n//\t        while(currRow <= n) {\n//\t        \tSystem.out.print('*');\n//\t        \tint currCol = 1;\n//\t        \t\n//\t        \twhile (currCol <= currRow) {\n//\t        \t\tSystem.out.print(currCol);\n//\t        \t\tcurrCol += 1;\n//\t        \t}\n//\t        \tcurrCol = currCol - 2;\n//\t        \twhile(currCol >= 1) {\n//\t        \t\tSystem.out.print(currCol);\n//\t        \t\tcurrCol -= 1;\n//\t        \t}\n//\t        \tSystem.out.println('*');\n//\t        \tcurrRow ++;\n//\t        }\n//\t        // Second half\n//\t        currRow = 1;\n//\t        \n//\t        while(currRow <= n - 1) {\n//\t        \tSystem.out.print('*');\n//\t        \t\n//\t        \tint currCol = 1;\n//\t        \twhile(currCol <= n - currRow) {\n//\t        \t\tSystem.out.print(currCol);\n//\t        \t\tcurrCol += 1;\n//\t        \t}\n//\t        \tcurrCol = currCol - 2;\n//\t        \twhile(currCol >= 1) {\n//\t        \t\tSystem.out.print(currCol);\n//\t        \t\tcurrCol -=  1;\n//\t        \t}\n//\t        \t\n//\t        \tSystem.out.println('*');\n//\t        \tcurrRow ++;\n//\t        }\n//\t        System.out.print('*');\n//\t}\n//\n//}\n"
        },
        {
          "fileName": "PrintParallelagram.java",
          "code": "//package Patterns;\n//import java.util.Scanner;\n//public class PrintParallelagram {\n//\n//\tpublic static void main(String[] args) {\n//\t\t// TODO Auto-generated method stub\n//\t\t Scanner s = new Scanner(System.in);\n//\t        \n//\t        int n = s.nextInt();\n//\t\tint i = 1;\n//\t\twhile (i <= n) {\n//\t\t    int spaces = 1;\n//\t\t    while (spaces <= i - 1) {\n//\t\t        System.out.print(\" \");\n//\t\t        spaces++;\n//\t\t    }\n//\t\t    int j = 1;\n//\t\t    while (j <= n) {\n//\t\t        System.out.print(\"*\");\n//\t\t        j++;\n//\t\t    }\n//\t\t    System.out.println();\n//\t\t    i++;\n//\t\t}\n//\t}\n//\n//}\n"
        },
        {
          "fileName": "PrintStars.java",
          "code": "//package Patterns;\n//import java.util.Scanner;\n//public class PrintStars {\n//\n//\tpublic static void main(String[] args) {\n//\t\t// TODO Auto-generated method stub\n//\t\tScanner s = new Scanner(System.in);\n//\t\t\n//\t\tint n = s.nextInt();\n////\t\tPrint a star pattern like this:\n////\t\t****\n////\t\t****\n////\t\t****\n////\t\t****\n////\t\tThis will require nested loops\n//\t\tint i = 1;\n//\t\twhile(i <= n) {\n//\t\t\tint j = 1;\n//\t\t\twhile(j <= n ) {\n//\t\t\t\tSystem.out.print('*');\n//\t\t\t\tj = j + 1;\n//\t\t\t}System.out.println();\n//\t\t\ti++;\n//\t\t}\n//\t}\n//\n//}\n"
        },
        {
          "fileName": "PrintStarsInvertedTriangle.java",
          "code": "package Patterns;\nimport java.util.Scanner;\npublic class PrintStarsInvertedTriangle {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n//\t\tPrint this pattern\n//\t\t****\n//\t\t***\n//\t\t**\n//\t\t*\n//\t\tScanner s = new Scanner(System.in);\n//\t\tint n = s.nextInt();\n\t\t\n//\t\tint i = 1;\n//\t\twhile(i <= n) {\n//\t\t\tint j = 1;\n//\t\t\twhile(j <= (n-i+1)) {\n//\t\t\t\tSystem.out.print('*');\n//\t\t\t\tj++;\n//\t\t\t}System.out.println();\n//\t\t\ti++;\n//\t\t}\n//\t\tPrint this pattern\n//\t\t4444\n//\t\t333\n//\t\t22\n//\t\t1\n//\t\tint i = 1;\n//\t\tint num = n;\n//\t\twhile(i <= n) {\n//\t\t\tint j = 1;\n//\t\t\twhile(j <= (n - i + 1)) {\n//\t\t\t\tSystem.out.print(num);\n//\t\t\t\tj++;\n//\t\t\t}System.out.println();\n//\t\t\ti++;\n//\t\t\tnum--;\n//\t\t}\n//\t\tPrint this pattern (mirrored stars) need 2 loops in one loop\n//\t\t   *\n//\t\t  **\n//\t\t ***\n//\t\t****\n//\t\tint i = 1;\n//\t\t\n//\t\t\n//\t\tString gap = \" \";\n//\t\twhile(i <= n) {\n//\t\t\tint j = 1;\n//\t\t\twhile(j <= n-i) {\n//\t\t\t\tSystem.out.print(gap);\n//\t\t\t\tj++;\n//\t\t\t}\n//\t\t\tint k = 1;\n//\t\t\twhile(k <= i) {\n//\t\t\t\tSystem.out.print(\"*\");\n//\t\t\t\tk++;\n//\t\t\t}System.out.println();\n//\t\t\ti++;\n//\t\t}\n//\t\tPrint this pattern (mirrored stars) need 2 loops in one loop\n//\t\t   1\n//\t\t  12\n//\t\t 123\n//\t\t1234\n//\t\tint i = 1;\n//\t\twhile(i <= n) {\n//\t\t\tint j = 1;\n//\t\t\twhile (j <= n-i) {\n//\t\t\t\tSystem.out.print(' ');\n//\t\t\t\tj++;\n//\t\t\t}\n//\t\t\tint k = 1;\n//\t\t\twhile (k <= i) {\n//\t\t\t\tSystem.out.print(k);\n//\t\t\t\tk++;\n//\t\t\t}System.out.println();\n//\t\t\ti++;\n//\t\t}\n//\t\tPrint this pattern (mirrored stars) need 3 loops in one loop n=4\n//\t\t   1\t\t\t// break it apart: we need \n//\t\t  121\t\t\t1) space\n//\t\t 12321\t\t\t2) increasing numbers\n//\t\t1234321\t\t\t3) decreasing numbers\n//\t\tint i = 1;\n//\t\twhile(i <= n) {\n//\t\t\tint j = 1;\n//\t\t\twhile(j <= n-i) {\n//\t\t\t\tSystem.out.print(' ');\n//\t\t\t\tj++;\n//\t\t\t}int k = 1;\n//\t\t\twhile(k <= i) {\n//\t\t\t\tSystem.out.print(k);\n//\t\t\t\tk++;\n//\t\t\t}int m = i-1;\n//\t\t\twhile(m >= 1) {\n//\t\t\t\tSystem.out.print(m);\n//\t\t\t\tm--;\n//\t\t\t}\n//\t\t\tSystem.out.println();\n//\t\t\ti++;\n//\t\t}\n//\t\t\n\t\t}\n\n}\n"
        },
        {
          "fileName": "SumPattern.java",
          "code": "//package Patterns;\n//import java.util.Scanner;\n//public class SumPattern {\n//\n//\tpublic static void main(String[] args) {\n//\t\t// TODO Auto-generated method stub\n//\t\tScanner s = new Scanner(System.in);\n//\t\tint n = s.nextInt();\n//\t\tint i = 1;\n//\t\tint sum = 0;\n//\t\twhile (i <= n) {\n//\t\t    sum += i;\n//\t\t    int j = 1;\n//\t\t    while (j <= i) {\n//\t\t        System.out.print(j);\n//\t\t        if (j != i) {\n//\t\t            System.out.print(\"+\");\n//\t\t        }\n//\t\t        j++;\n//\t\t    }\n//\t\t    System.out.print(\"=\" + sum);\n//\t\t    System.out.println();\n//\t\t    i++;\n//\t\t}\n//\n//\t}\n//\n//}\n"
        },
        {
          "fileName": "TrianglePattern.java",
          "code": "//package Patterns;\n//import java.util.Scanner;\n//public class TrianglePattern {\n//\n//\tpublic static void main(String[] args) {\n//\t\t// TODO Auto-generated method stub\n//\t\tScanner s = new Scanner(System.in);\n////\t\tPrint this pattern:\n////\t\t1\n////\t\t12\n////\t\t123\n////\t\t1234\n//\t\tint n = s.nextInt();\n//\t\tint i = 1;\n//\t\twhile(i <= n) {\n//\t\t\tint j = 1;\n//\t\t\twhile (j <= i) {\n//\t\t\t\tSystem.out.print(j);\n//\t\t\t\tj++;\n//\t\t\t}System.out.println();\n//\t\t\ti++;\n//\t\t}\n//\t\tSystem.out.println();     // print a blank line for space\n////\t\tPrint this pattern:\n////\t\t1\n////\t\t23\n////\t\t456\n////\t\t78910\n////\t\tUse the same input n:\n//\t\tint p = 1;\n//\t\tint l = 1;\n//\t\twhile(l <= n) {\n//\t\t\tint m = 1;\n//\t\t\twhile(m <= l) {\n//\t\t\t\tSystem.out.print(p);\n//\t\t\t\tm++;\n//\t\t\t\tp++;\n//\t\t\t}System.out.println();\n//\t\t\tl++;\n//\t\t}\n//\t\tSystem.out.println();     // print a blank line for space\n////\t\tPrint this pattern:\n////\t\t1\n////\t\t23\n////\t\t345\n////\t\t4567\n////\t\tUse same input n:\n//\t\tint a = 1;\n//\t\twhile(a <= n) {\n//\t\t\tint b = a;\n//\t\t\tint c = 1;\n//\t\t\twhile(c <= a) {\n//\t\t\t\tSystem.out.print(b);\n//\t\t\t\tc++;\n//\t\t\t\tb++;\n//\t\t\t}System.out.println();\n//\t\t\ta++;\n//\t\t}\n//\t\t\n//\t}\n//\n//}\n"
        },
        {
          "fileName": "fibonacci.java",
          "code": "package Patterns;\nimport java.util.Scanner;\npublic class fibonacci {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner s = new Scanner(System.in);\n\t\tint n = s.nextInt();\n\t\t\n\t\tint val1 = 1;\n\t\tint val2 = 1;\n\t\tint next = 0;\n\t\tfor(int i = 1; i < n-1; i++) {\n\t\t\tnext = val1 + val2;\n\t\t\tval1 = val2;\n\t\t\tval2 = next;\n\t\t}System.out.println(val2);\n\t}\n\n}\n"
        },
        {
          "fileName": "oddSquarePattern.java",
          "code": "//package Patterns;\n//import java.util.Scanner;\n//public class oddSquarePattern {\n//\n//\tpublic static void main(String[] args) {\n//\t\t// TODO Auto-generated method stub\n//\t\tScanner s = new Scanner(System.in);\n//\t\t\n//\t\tint n = s.nextInt();\n//\t\t\n//\t\tint currRow = 1;\n//\t\t\n//\t\twhile(currRow <= n) {\n//\t\t\tint valueToPrint =(2* currRow)-1;\n//\t\t\tint currCol = n;\n//\t\t\t\n//\t\t\twhile(currCol > 0) {\n//\t\t\t\tSystem.out.print(valueToPrint);\n//\t\t\t\tvalueToPrint += 2;\n//\t\t\t\t\n//\t\t\t\tif(valueToPrint > (2 * n) - 1) {\n//\t\t\t\t\tvalueToPrint = 1;\n//\t\t\t\t}\n//\t\t\t\t\n//\t\t\t\tcurrCol -= 1;\n//\t\t\t}\n//\t\t\tSystem.out.println();\n//\t\t\tcurrRow += 1;\n//\t\t}\n//\t}\n//\n//}\n"
        }
      ]
    },
    {
      "name": "Queues",
      "files": [
        {
          "fileName": "DoubleEndedQueue.java",
          "code": "package Queues;\n\npublic class DoubleEndedQueue {\n\tint[] dq;\n    int front;\n    int rear;\n    int size;\n\n    public DoubleEndedQueue(int n) {\n        dq = new int[n];\n        front = -1;\n        rear = 0;\n        size = n;\n    }\n\n    void insertFront(int key) {\n        if (isFull()) {\n            System.out.println(\"-1\");\n            return;\n        }\n        \n        if (front == -1) {\n            front = 0;\n            rear = 0;\n        } else if (front == 0)\n            front = size - 1 ;\n        else\n            front = front - 1;\n\n        dq[front] = key ;\n    }\n\n    void insertRear(int key) {\n        if (isFull()) {\n            System.out.println(\"-1\");\n            return;\n        }\n\n        if (front == -1) {\n            front = 0;\n            rear = 0;\n        } else if (rear == size-1)\n            rear = 0;\n        else\n            rear = rear+1;\n\n        dq[rear] = key;\n    }\n\n    void deleteFront() {\n        if (isEmpty()) {\n            System.out.println(\"-1\");\n            return;\n        }\n\n        if (front == rear) {\n            front = -1;\n            rear = -1;\n        } else if (front == size -1)\n            front = 0;\n        else\n            front = front+1;\n    }\n\n    void deleteRear() {\n        if (isEmpty()) {\n            System.out.println(\"-1\");\n            return;\n        }\n\n        if (front == rear) {\n            front = -1;\n            rear = -1;\n        } else if (rear == 0)\n            rear = size - 1;\n        else\n            rear = rear-1;\n    }\n\n    int getFront() {\n        if (isEmpty()) {\n            return -1;\n        }\n\n        return dq[front];\n    }\n\n    int getRear() {\n        if(isEmpty() || rear < 0) {\n            return -1;\n        }\n\n        return dq[rear];\n    }\n\n    boolean isFull() {\n        return ((front == 0 && rear == size - 1) || front == rear + 1);\n    }\n\n    boolean isEmpty() {\n        return (front == -1);\n    }\n}\n"
        },
        {
          "fileName": "QueueClass.java",
          "code": "package Queues;\n\npublic class QueueClass {\n\t\n\t\n\t// circular queue\n\tprivate int[] data;\n\t// keep index of front and rear\n\tprivate int frontIndex;\n\tprivate int rearIndex;\n\tprivate int size;\n\t\n\tpublic QueueClass(){\n\t\tdata = new int[5];\n\t\tfrontIndex = -1;\n\t\trearIndex = -1;\n\t\t\n\t}\n\t\n\tpublic QueueClass(int capacity){\n\t\tdata = new int[capacity];\n\t\tfrontIndex = -1;\n\t\trearIndex = -1;\n\t\t\n\t}\n\t\n\tpublic int size() {\n\t\treturn size;\n\t}\n\t\n\tpublic boolean isEmpty() {\n\t\treturn size == 0;\n\t}\n\t\n\tpublic int front() throws QueueEmptyException {\n\t\tif(size == 0) {\n\t\t\tthrow new QueueEmptyException(); \n\t\t}\n\t\treturn data[frontIndex];\n\t}\n\t\n\tpublic void enqueue(int elem)  {\n\t\tif(size == data.length) {\n\t\t\tdoubleCapacity();\n\t\t}\n\t\tif(size == 0) {\n\t\t\tfrontIndex = 0;\n\t\t}\n//\t\trearIndex++;\n//\t\tif(rearIndex == data.length) {\n//\t\t\trearIndex = 0;\n//\t\t}\n\t\trearIndex = (rearIndex + 1) % data.length;\n\t\tdata[rearIndex] = elem;\n\t\tsize++;\n\t}\n\t\n\tprivate void doubleCapacity() {\n\t\tint[] temp = data;\n\t\tdata = new int[2* temp.length];\n\t\tint index = 0;\n\t\t// elements must be copied according to their order because a queue is First in First out (Right side, tail, left side head)\n\t\t// copy all elements from frontIndex to end of array:\n\t\tfor(int i = frontIndex; i < temp.length; i++) {\n\t\t// copy at index 0, then keep increasing the index while copying over the array\n\t\t\tdata[index++] = temp[i];\n\t\t}\n\t\t// then copy all elements from start of the array, to frontIndex - 1.\n\t\tfor(int i = 0; i < frontIndex -1; i++) {\n\t\t\tdata[index++] = temp[i];\n\t\t}\n\t\tfrontIndex = 0;\n\t\trearIndex = temp.length - 1;\n\t}\n\n\tpublic int dequeue() throws QueueEmptyException {\n\t\tif(size == 0) {\n\t\t\tthrow new QueueEmptyException();\n\t\t}\n\t\tint temp = data[frontIndex];\n\t\t\n//\t\tfrontIndex++;\n//\t\tif(frontIndex == data.length) {\n//\t\t\tfrontIndex = 0;\n//\t\t}\n\t\t\n\t\tfrontIndex = (frontIndex + 1) % data.length;\n\t\tsize--;\n\t\tif(size == 0) {\n\t\t\tfrontIndex = -1;\n\t\t\trearIndex = -1;\n\t\t}\n\t\treturn temp;\n\t}\n}\n"
        },
        {
          "fileName": "QueueEmptyException.java",
          "code": "package Queues;\n\npublic class QueueEmptyException extends Exception {\n\n\tprivate static final long serialVersionUID = 1L;\n\n}\n"
        },
        {
          "fileName": "QueueFullException.java",
          "code": "package Queues;\n\npublic class QueueFullException extends Exception {\n\n\tprivate static final long serialVersionUID = 1L;\n\n}\n"
        },
        {
          "fileName": "QueueInJavaCollections.java",
          "code": "package Queues;\nimport java.util.Queue;\nimport java.util.LinkedList;\npublic class QueueInJavaCollections {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\t\n//\t\tQueue<Integer> queue = new Queue<Integer>; You can't do this, because Queue superclass is an interface, Remember:\n\t\t\n//\t\tand interface is a class with methods which are declared, but only defined within its subclasses.\n\t\t\n//\t\tto use queue, you must make it a variable referring to the object of the class thats implementing the queue interface, \n//\t\tin this case, Linked List is a class that implements the Queue interface.\n\n\t\tQueue<Integer> queue = new LinkedList<Integer>(); \n\t\t\n\t\tqueue.add(10);\n\t\tqueue.add(20);\n\t\tSystem.out.println(queue.size());\n\t\tSystem.out.println(queue.peek());\n\t\tSystem.out.println(queue.poll());\n\t\t\n\t\t\n\t}\n\n}\n"
        },
        {
          "fileName": "QueueUsingLinkedList.java",
          "code": "package Queues;\nimport linkedLists.LinkedListNodeClass;\npublic class QueueUsingLinkedList<T>{\n\t\n\tprivate LinkedListNodeClass<T>front;\n\tprivate LinkedListNodeClass <T>rear;\n\tprivate int size;\n\t\n\tpublic QueueUsingLinkedList() {\n\t\tfront = null;\n\t\trear = null;\n\t\tint size = 0;\n\t}\n\t\n\tpublic int size() {\n\t\treturn size;\n\t}\n\t\n\tpublic boolean isEmpty() {\n\t\treturn size == 0;\n\t}\n\t\n\tpublic void enqueue(T elem) {\n\t\tLinkedListNodeClass<T> Rs = new LinkedListNodeClass<>(elem);\n\t\tsize ++;\n\t\tif(front == null) {\n\t\t\tfront = Rs;\n\t\t\trear = Rs;\n\t\t\treturn;\n\t\t}\n\t\trear.next = Rs;\n\t\trear = Rs;\n\t}\n\t\n\tpublic T front() {\n\t\tif(front == null) {\n\t\t\tthrow new NullPointerException();\n\t\t}\n\t\treturn front.data;\n\t}\n\t\n\tpublic T dequeue() throws QueueEmptyException {\n\t\tif(front == null) {\n\t\t\tthrow new QueueEmptyException();\n\t\t}\n\t\tT temp = front.data;\n\t\tfront = front.next;\n\t\tif(front == null) {\n\t\t\trear = null;\n\t\t}\n\t\treturn temp;\n\t}\n\t\n}\n"
        },
        {
          "fileName": "Queues.java",
          "code": "package Queues;\n\n\n// Queue works as First in First out sequence / unlike stacks, which are last in first out\n\n// Queue elements are added to the rear, and removed from the front. \npublic class Queues {\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tQueueClass Rs = new QueueClass(3);\n\t\t\n\t\tint[] arr = {10,20,30,40,45};\n\t\t\n\t\tfor(int elem : arr) {\n\t\t\tRs.enqueue(elem);\n\t\t}\n\t\t\n\t\twhile(! Rs.isEmpty()) {\n\t\t\ttry {\n\t\t\t\tSystem.out.println(Rs.dequeue());\n\t\t\t} catch (QueueEmptyException e) {\n\t\t\t\t\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t}\n\n}\n"
        },
        {
          "fileName": "reverseKthElementsInQueue.java",
          "code": "package Queues;\nimport java.util.Stack;\nimport java.util.LinkedList;\nimport java.util.Queue;\n//In this problem, you need to reverse only the first K elements of the queue. \n//To do this, you can use an auxiliary stack and push the first K elements from \n//the queue onto the stack, effectively reversing their order. \npublic class reverseKthElementsInQueue {\n\tpublic static Queue<Integer> reverseKElements(Queue<Integer> input, int k) {\n\t\t//Your code goes here\n\t\t// If the queue is empty or k is greater than the size of the queue, return the same queue\n\t\tif (input.isEmpty() || k > input.size())\n\t\t\treturn input;\n\n\t\t// If k is 0 or 1, the queue remains unchanged\n\t\tif (k <= 0 || k == 1)\n\t\t\treturn input;\n\n\t\t// Create a stack and push the first k elements into it\n\t\tStack<Integer> stack = new Stack<>();\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tstack.push(input.poll());\n\t\t}\n\n\t\t// Pop the elements from the stack back into the queue\n\t\twhile (!stack.isEmpty()) {\n\t\t\tinput.add(stack.pop());\n\t\t}\n\n\t\t// Move the remaining elements from the front of the queue to the rear\n\t\tfor (int i = 0; i < input.size() - k; i++) {\n\t\t\tinput.add(input.poll());\n\t\t}\n\n\t\treturn input;\n\t}\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n"
        },
        {
          "fileName": "reverseQueue.java",
          "code": "package Queues;\nimport java.util.Queue;\nimport java.util.LinkedList;\n\n//The key to solve this problem without using any other data structures is to use recursion. \n//You can dequeue each element from the queue and then recursively call the reverse function. \n//Once you reach the end of the queue, you start enqueuing the elements back to the queue.\n\npublic class reverseQueue {\n\tpublic static void reverseQueue(Queue<Integer> input) {\n\t\t// Base case: If the queue is empty, return\n\t\tif (input.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Dequeue the front element from the queue\n\t\tint front = input.poll();\n\t\t\n\t\t// Recursive call for the remaining elements in the queue\n\t\treverseQueue(input);\n\t\t\n\t\t// Enqueue the front element back into the queue\n\t\tinput.add(front);\n\t}\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n"
        },
        {
          "fileName": "stackUsingTwoQueues.java",
          "code": "package Queues;\nimport java.util.Queue;\nimport java.util.LinkedList;\n\n// implement a stack data structure using 2 queues\npublic class stackUsingTwoQueues {\n\t//Define the data members\n    private Queue<Integer> queue1;\n    private Queue<Integer> queue2;\n\n    public stackUsingTwoQueues() {\n        //Implement the Constructor\n        queue1 = new LinkedList<>();\n        queue2 = new LinkedList<>();\n    }\n\n    /*----------------- Public Functions of Stack -----------------*/\n\n    public int getSize() { \n        //Implement the getSize() function\n        return queue1.size();\n    }\n\n    public boolean isEmpty() {\n        //Implement the isEmpty() function\n         return queue1.isEmpty();\n    }\n\n    public void push(int element) {\n        //Implement the push(element) function\n         queue1.add(element);\n    }\n\n    public int pop() {\n        //Implement the pop() function\n         if(queue1.isEmpty()){\n            return -1;\n        }\n        while(queue1.size() > 1){\n            queue2.add(queue1.poll());\n        }\n        int popVal = queue1.poll();\n\n        // Swap names of queues\n        Queue<Integer> temp = queue1; \n        queue1 = queue2;\n        queue2 = temp;\n\n        return popVal;\n    }\n\n    public int top() {\n        //Implement the top() function\n        if(queue1.isEmpty()){\n            return -1;\n        }\n        while(queue1.size() > 1){\n            queue2.add(queue1.poll());\n        }\n        int topVal = queue1.peek();\n        queue2.add(queue1.poll());\n\n        // Swap names of queues\n        Queue<Integer> temp = queue1; \n        queue1 = queue2;\n        queue2 = temp;\n\n        return topVal;\n    }\n}\n"
        }
      ]
    },
    {
      "name": "Recursion",
      "files": [
        {
          "fileName": "BinarySearchRecursive.java",
          "code": " package Recursion;\n\npublic class BinarySearchRecursive {\n\t// return index of target\n\t\n\t\n\t// IMPORTANT: the array must be sorted for binary search to work\n\t\n\tpublic static int binarySearch(int[] arr, int startIndex, int endIndex, int target) {\n\t\tif(startIndex > endIndex) {\n\t\t\t// element not in array\n\t\t\treturn -1;\n\t\t}\n\t\t//get middle index\n\t\tint middleIndex = (startIndex + endIndex)/2;\n\t\tif(arr[middleIndex] == target) {\n\t\t\treturn middleIndex;\n\t\t}\n\t\telse if(arr[middleIndex] < target) {\n\t\t\treturn binarySearch(arr, middleIndex + 1, endIndex, target);\n\t\t}\n\t\telse {\n\t\t\treturn binarySearch(arr, startIndex, middleIndex-1, target);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t// IMPORTANT: the array must be sorted for binary search to work\n\t\tint[] array = {1,3,6,8,11,15,34,56,89,90,93,100,145,158,163,190};\n\t\tSystem.out.println(binarySearch(array, 0, array.length-1, 3));\n\t}\n\n}\n"
        },
        {
          "fileName": "CheckforNumInArray.java",
          "code": "package Recursion;\n\npublic class CheckforNumInArray {\n\t// check if int x is in array, return true if it is and false if its not\n\tpublic static boolean checkNumber(int[] arr, int x) {\n\t\t// base case\n\t\tif(arr.length == 1) {\n\t\t\tSystem.out.println(\"top level \"+arr[0]);\n\t\t\tif(arr[0] == x) {\n\t\t\t\treturn true;\n\t\t\t}else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tint[] smallerArray = new int[arr.length-1]; // make a new array so you can do this recursively\n\t\tfor(int i = 1; i < arr.length; i++) {\n\t\t\tsmallerArray[i-1] = arr[i];\n\t\t}\n\t\tboolean answer = checkNumber(smallerArray, x);\n\t\t\n\t\tif(arr[0] == x) {\n\t\t\treturn true;\n\t\t}\n\t\treturn answer;\n\t}\n\tpublic static void main(String[] args) {\n\t\tint[] array = {1,2,3,4,5,6,56,78,90,25,32,54};\n\t\tint x = 1;\n\t\tSystem.out.println(\"outsite \"+checkNumber(array, x));\n\t}\n\n}\n"
        },
        {
          "fileName": "CountZeros.java",
          "code": "package Recursion;\n\npublic class CountZeros {\n\t\n\tpublic static int countZeros(int N) {\n        if (N == 0) {\n            return 1;\n        }\n        \n        if (N < 10) {\n            return 0;\n        }\n        \n        int lastDigit = N % 10;\n        int zerosInRest = countZeros(N / 10);\n        \n        if (lastDigit == 0) {\n            return zerosInRest + 1;\n        } else {\n            return zerosInRest;\n        }\n    }\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\t int zeros = countZeros(102304);\n\t     System.out.println(\"Number of zeros: \" + zeros);\n\t}\n\n}\n"
        },
        {
          "fileName": "MergeSort2.java",
          "code": "package Recursion;\n// merge and sort array recursively, this algorithm is splitting the arrays into a tree\npublic class MergeSort2 {\n\t\tpublic static void mergeSort(int[] arr) {\n\t\t\t//base case\n\t\t\tif(arr.length <= 1) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint[] arr1 = new int[arr.length/2];\n\t\t\tint[] arr2 = new int[arr.length - arr1.length];\n\t\t\t// copy array\n\t\t\tfor(int i = 0; i < arr.length/2; i++) {\n\t\t\t\tarr1[i] = arr[i];\n\t\t\t}\n\t\t\tfor(int i = arr.length/2; i < arr.length; i++) {\n\t\t\t\tarr2[i - arr.length/2] = arr[i];\n\t\t\t}\n\t\t\tmergeSort(arr1);\n\t\t\tmergeSort(arr2);\n\t\t\tmerge(arr1, arr2, arr);\n\t\t\t\n\t\t}\n\t\t// merge the 2 arrays\n\t\tpublic static void merge(int[] source1, int[] source2, int[] destination) {\n\t\t\tint i = 0;\n\t\t\tint j = 0;\n\t\t\tint k = 0;\n\t\t\twhile(i < source1.length && j < source2.length) {\n\t\t\t\tif(source1[i] <= source2[j]) {\n\t\t\t\t\tdestination[k] = source1[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tk++;\n\t\t\t\t}else {\n\t\t\t\t\tdestination[k] = source2[j];\n\t\t\t\t\tk++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// copy whatever is remaining from source 1\n\t\t\tif(i < source1.length) {\n\t\t\t\twhile(i < source1.length) {\n\t\t\t\t\tdestination[k] = source1[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// copy whatever remains from source 2\n\t\t\tif(j < source2.length) {\n\t\t\t\twhile(j < source2.length) {\n\t\t\t\t\tdestination[k] = source2[j];\n\t\t\t\t\tk++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tpublic static void main(String[] args) {\n\t\t// merge and sort array recursively, this algorithm is splitting the arrays into a tree\n\t\tint[] array = {90, 31, 94, 80, 46, 28, 48, 31, 28, 90, 9, 27, 81, 43, 94, 5, 56, 13, 1, 23, 85, 71, 93, 53, 82 };\n\t\tmergeSort(array);\n\t\tfor(int i = 0; i < array.length; i++) {\n\t\t\tSystem.out.println(array[i]);\n\t\t}\n\t}\n\n}\n"
        },
        {
          "fileName": "Multiplication.java",
          "code": "package Recursion;\n\n//Given two integers M & N, \n//calculate and return their multiplication using recursion. \n//You can only use subtraction and addition for your calculation. \n//No other operators are allowed.\n\npublic class Multiplication {\n\t\n    public static int multiply(int M, int N) {\n        if (N == 0) {\n            return 0;\n        }\n        \n        if (N > 0) {\n            return M + multiply(M, N - 1);\n        } else {\n            return -multiply(M, -N);\n        }\n    }\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\t int result = multiply(5, 4);\n\t     System.out.println(\"Multiplication result: \" + result);\n\t}\n\n}\n"
        },
        {
          "fileName": "PrintNums1toN.java",
          "code": "package Recursion;\n\npublic class PrintNums1toN {\n\t\n\t//base case n=0 - at this point do nothing\n\t\n\tpublic static void printNums(int n) {\n\t\tif(n == 0) {\n\t\t\treturn;\n\t\t}\n\t\tprintNums(n-1);\n\t\tSystem.out.println(n);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\n\t\tprintNums(10);\n\n\t}\n\n}"
        },
        {
          "fileName": "QuickSort.java",
          "code": "package Recursion;\n\npublic class QuickSort {\n\t\n    public static void quickSort(int[] arr, int start, int end) {\n        if (start < end) {\n            // pivotIndex is partitioning index, arr[pivotIndex] is now at right place\n            int pivotIndex = partition(arr, start, end);\n\n            // Recursively sort elements before and after partition\n            quickSort(arr, start, pivotIndex - 1);\n            quickSort(arr, pivotIndex + 1, end);\n        }\n    }\n\n    public static int partition(int[] arr, int start, int end) {\n        int pivotPoint = arr[end];\n        int i = (start - 1); // index of smaller element\n\n        for (int j = start; j < end; j++) {\n            // If current element is smaller than or equal to pivot\n            if (arr[j] <= pivotPoint) {\n                i++;\n\n                // swap arr[i] and arr[j]\n                int temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n\n        // swap arr[i+1] and arr[end] (or pivot)\n        int temp = arr[i + 1];\n        arr[i + 1] = arr[end];\n        arr[end] = temp;\n\n        return i + 1;\n    }\n\n\tpublic static void main(String[] args) {\n\t\tint[] arr = {90,31,94,80,46,28,48,31,28,90,9,27,81,43,94,5,56,13,1,23,85,71,93,53,82};\n\t\t/////\n\t\tquickSort(arr, 0, arr.length-1);\n\t\t/////\n\t\tfor (int i = 0; i<arr.length; i++) {\n        System.out.println(\"arr: \" + arr[i]);\n\t\t}\n\t}\n\n}\n\n"
        },
        {
          "fileName": "StackSizeExample.java",
          "code": "package Recursion;\n\npublic class StackSizeExample {\n\t\n\tstatic int count = 0;\n\n\tpublic static void printNums(int n) {\n\t\tif(n == 0) {\n\t\t\treturn;\n\t\t}\n\t\tcount++;\n\t\tprintNums(n-1);\n\t\tSystem.out.println(n);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tprintNums(350000);\n\t\t} catch (StackOverflowError e) {\n\t\t\tSystem.out.println(\"Max depth reached: \" + count);\n\t\t\t//System.exit(1); // exit the program as it's generally not safe to continue after a StackOverflowError\n\t\t}\n\t}\n}\n"
        },
        {
          "fileName": "SumOfArray.java",
          "code": "package Recursion;\n\npublic class SumOfArray {\n\tpublic static int sumUpArray(int[] arr) {\n\t\tif(arr.length == 1) {\n\t\t\treturn arr[0]; // at this point arr[0] = 4, but as soon as its kicked back out of the if statement arr[0]=3 \n\t\t}\n\t\tint[] smallerArray = new int[arr.length-1];\n\t\t\n\t\tfor(int i = 1; i < arr.length; i++) {\t\t// make a new array and copy over arr\n\t\t\tsmallerArray[i-1] = arr[i];\n\t\t}\n\t\tint total = sumUpArray(smallerArray)+ arr[0]; // arr[0]=3 now after it got kicked back from the if statement\n\t\t\n//\t\tfor (int element : arr) {\n//\t          System.out.println(\"arr: \" + element);\t// print out the unwinding array\n//\t    }\n\t\t\n\t\treturn total;\n\t}\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tint[] array = {5,1,2,7,9,3,4};\n\t\tSystem.out.println(sumUpArray(array));\n\t}\n\n}\n"
        },
        {
          "fileName": "TowerOfHanoi.java",
          "code": "package Recursion;\n\npublic class TowerOfHanoi {\n\n\n\t    public static void towerOfHanoi(int n, char source, char auxiliary, char destination) {\n\t        if (n == 1) {\n\t            System.out.println(\"Move disk 1 from rod \" + source + \" to rod \" + destination);\n\t            return;\n\t        }\n\t        towerOfHanoi(n - 1, source, destination, auxiliary);\n\t        System.out.println(\"Move disk \" + n + \" from rod \" + source + \" to rod \" + destination);\n\t        towerOfHanoi(n - 1, auxiliary, source, destination);\n\t    }\n\n\t    public static void main(String args[]) {\n\t        int n = 4; // Number of disks\n\t        towerOfHanoi(n, 'a', 'b', 'c');\n\t    }\n\n\n}\n"
        },
        {
          "fileName": "checkString.java",
          "code": "package Recursion;\n//Suppose you have a string, S, made up of only 'a's and 'b's. Write a recursive function that checks if the string was generated using the following rules:\n//a. The string begins with an 'a'\n//b. Each 'a' is followed by nothing or an 'a' or \"bb\"\n//c. Each \"bb\" is followed by nothing or an 'a'\n//If all the rules are followed by the given string, return true otherwise return false.\npublic class checkString {\n    public static boolean checkString(String s) {\n        // base cases\n        if (s.length() == 0) {\n            return true;\n        } else if (s.charAt(0) != 'a') {\n            return false;\n        } else if (s.length() == 1) {\n            return true;\n        }\n\n        // recursive cases\n        if (s.charAt(1) == 'a') {\n            return checkString(s.substring(1));\n        } else if (s.length() > 2 && s.substring(1, 3).equals(\"bb\")) {\n            if (s.length() == 3 || s.charAt(3) == 'a') {\n                return checkString(s.substring(3));\n            }\n        }\n\n        return false;\n    }\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n        System.out.println(checkString(\"a\"));     // Output: true\n        System.out.println(checkString(\"aabba\")); // Output: true\n        System.out.println(checkString(\"aab\"));   // Output: false\n        System.out.println(checkString(\"bba\"));   // Output: false\n\t}\n\n}\n"
        },
        {
          "fileName": "findIndexValueinArray.java",
          "code": "package Recursion;\n\npublic class findIndexValueinArray {\n\t// find first occurrence of index value and return it, otherwise return -1, you can make copies\n\tpublic static int findIndex(int[] arr, int x) {\n\t\t\n\t\tif(arr.length == 0) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\tif(arr[0] == x) {\t\t// gets the element if it exists at index 0, \n\t\t\treturn 0;\t\t\t// then sends 0 back because 0 is the index of the element at arr[0]\n\t\t}\n\t\tint [] smallerArray = new int[arr.length-1];\n\t\tfor(int i = 1; i < arr.length; i++) {\n\t\t\tsmallerArray[i-1] = arr[i];\n\t\t}\n\t\tint firstIndex = findIndex(smallerArray, x);\t// first index will become = 0\n\t\t\n\t\tSystem.out.println(firstIndex);\n\t\t\n\t\tif(firstIndex == -1) {\n\t\t\treturn -1;\n\t\t}\n\t\t\treturn firstIndex + 1; // this causes the firstIndex to increment, as each unresolved recursive call unwinds\n\t}\n\t\n\t// find first occurrence of index value in an array, given a start index, without making copies of the array\n\tpublic static int getIndex(int[] arr,int target, int startIndex) {\n\t\tif(arr[startIndex] == target) {\n\t\t\treturn startIndex;\n\t\t}\n\t\tif(startIndex == arr.length-1) {\n\t\t\treturn -1;\n\t\t}\n\t\tint targetIndex = getIndex(arr, target, startIndex + 1);\n\t\treturn targetIndex;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tint[] array = {5,2,6,3,51,66,23};\n\t\tint x = 23;\n\t\t//System.out.println(\"index is: \"+findIndex(array, x));\n\t\tSystem.out.println(\"outside\"+getIndex(array, x, 0));\n\t}\n\n}\n"
        },
        {
          "fileName": "findLastIndex.java",
          "code": "package Recursion;\n//Given an array of length N and an integer x, you need to find and return the last index of integer x present in the array. Return -1 if it is not present in the array.\n//Last index means - if x is present multiple times in the array, return the index at which x comes last in the array.\n//You should start traversing your array from 0, not from (N - 1).\n//Do this recursively. Indexing in the array starts from 0.\npublic class findLastIndex {\n\t\n\tpublic static int lastIndex(int[] arr, int target) {\n\t\tif(arr.length == 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tint[] smallerArray = new int[arr.length-1];\n\t\t\n\t\tfor(int i = 1; i < arr.length; i++) {\t\t// make a new array and copy over arr\n\t\t\tsmallerArray[i-1] = arr[i];\n\t\t}\n\t\t\n\t\tint index = lastIndex(smallerArray, target);\n\t\t///////////////////////////////////////////////\n\t\tSystem.out.println(\"index \" + index);\n\t\t///////////////////////////////////////////////\n\t\tif (index >= 0) {\n\t\t\tindex +=1;\n\t\t}\n\t\tif(index == -1) {\n\t\t\tif(arr[0] == target) {\n\t\t\t\tindex += 1;\t\t\t\n\t\t\t}else {\n\t\t\t\tindex = -1;\n\t\t\t}\n\t\t}\n\t\t///////////////////////////////////////////////\n\t\tSystem.out.println(\"arr[0] \" + arr[0]);\n\t\t\n\t\t//System.out.println(\"smallerArray[0] \" + smallerArray[0] ); // don't run this, it will break the code\n\t\t\n\t\tfor (int element : arr) {\n\t          System.out.println(\"arr: \" + element);\n\t      }\n\t\tfor (int element : smallerArray) {\n\t          System.out.println(\"smallerArr: \" + element);\n\t      }\n\t\t///////////////////////////////////////////////\n\t\treturn index;\n\t}\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tint[] array = {5,4,6,2,7,4,3,4,6};\n\t\tSystem.out.println(\"outside\" + lastIndex(array, 6));\n\t}\n\n}\n"
        },
        {
          "fileName": "findWaysUpStairs.java",
          "code": "package Recursion;\n//A child is running up a staircase with N steps, and can hop either 1 step, 2 steps or 3 steps at a time. \n//Implement a method to count how many possible ways the child can run up to the stairs. \n//You need to return number of possible ways W.\n\npublic class findWaysUpStairs {\n    public static int findWays(int n) {\n        int[] ways = new int[n + 1];\n        ways[0] = 1;  // base case: 1 way to climb 0 stairs\n        ways[1] = 1;  // base case: 1 way to climb 1 stair\n        ways[2] = 2;  // base case: 2 ways to climb 2 stairs\n\n        for (int i = 3; i <= n; i++) {\n            ways[i] = ways[i - 1] + ways[i - 2] + ways[i - 3];\n        }\n\n        return ways[n];\n    }\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t       System.out.println(findWays(4));  // Output: 7\n\t       System.out.println(findWays(5));  // Output: 13\n\t       System.out.println(findWays(6));  // Output: 24\n\t       \n//Here is the recursive relation:\n//For the first step, the child can reach in only one way.\n//For the second step, the child can reach in two ways (one step + one step or two steps).\n//For the third step, the child can reach in four ways (one step + one step + one step, one step + two steps, two steps + one step, three steps).\n//For the remaining steps, the child can reach in ways which is the sum of ways of reaching (n-1)th, (n-2)th and (n-3)th step.\n\t}\n\n}\n"
        },
        {
          "fileName": "geometricSum.java",
          "code": "package Recursion;\n\npublic class geometricSum {\n\tpublic static double calculateGeometricSum(int k) {\n        if (k == 0) {\n            return 1;\n        }\n        \n        double previousSum = calculateGeometricSum(k - 1);\n        double currentTerm = 1 / Math.pow(2, k);\n        \n        return previousSum + currentTerm;\n    }\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\t int k = 5; // Change this value to your desired k\n\t\t double sum = calculateGeometricSum(k);\n\t\t System.out.println(sum);\n\t}\n\n}\n"
        },
        {
          "fileName": "numberOfDigits.java",
          "code": "package Recursion;\n\nimport java.util.Scanner;\n\npublic class numberOfDigits {\n\t\n\tpublic static int count(int n) {\n\t\tif(n < 10) {\n\t\t\treturn 1;\n\t\t}\n\t\tint smallOutput = count(n/10);\n\t\treturn smallOutput + 1;\n\t\t\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\t\n\t\tint n = s.nextInt();\n\t\tSystem.out.println(count(n));\n\t}\n\n}\n"
        },
        {
          "fileName": "pairStar.java",
          "code": "package Recursion;\n//Given a string S, compute recursively a new string where identical chars \n//that are adjacent in the original string are separated from each other by a \"*\".\npublic class pairStar {\n    public static String addStars(String s) {\n        // base case: if the string is empty or has only one character, return the string as it is\n        if (s.length() <= 1) {\n            return s;\n        }\n        // recursive case: if the current character is the same as the next one, insert a '*' between them\n        if (s.charAt(0) == s.charAt(1)) {\n            return s.charAt(0) + \"*\" + addStars(s.substring(1));\n        } else {\n            return s.charAt(0) + addStars(s.substring(1));\n        }\n    }\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t      System.out.println(addStars(\"aaaa\"));  // Output: \"a*a*a*a\"\n\t      System.out.println(addStars(\"abcdd\"));  // Output: \"abcd*d\"\n\t}\n\n}\n"
        },
        {
          "fileName": "powerOfX.java",
          "code": "package Recursion;\nimport java.util.Scanner;\npublic class powerOfX {\n\t\n\tpublic static int powerOfX(int x, int n) {\n\t\tif(n == 0) {\n\t\t\treturn 1;\n\t\t}\n\t\tint smallOutput = powerOfX(x, n-1);\n\t\tint output = x * smallOutput;\n\t\treturn output;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner s = new Scanner(System.in);\n\t\tint x = s.nextInt();\n\t\tint n = s.nextInt();\n\t\tSystem.out.println(powerOfX(x,n));\n\t}\n\n}\n"
        },
        {
          "fileName": "recursion.java",
          "code": "\n\npackage Recursion;\n\npublic class recursion {\n\n\tpublic static int factorial(int n) {\n\t\tif(n==0) {\n\t\t\treturn 1;\n\t\t}\n\t\t\n\t\tint smallerOutput = factorial(n-1);\n\t\tint output = n * smallerOutput;\n\t\treturn output;\n\t}\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(factorial(5));\n\n\t}\n\n}\n"
        },
        {
          "fileName": "removeXinString.java",
          "code": "package Recursion;\n\npublic class removeXinString {\n\t// remove target char from a string\n\tpublic static String removeX(String str) {\n\t\tif(str.length() == 0) {\n\t\t\treturn str;\n\t\t}\n\t\tString smallerOutput = removeX(str.substring(1));\n\t\t\n\t\t//System.out.println(\"small : \" + smallerOutput);\n\t\t//System.out.println(\"str : \" + str);\n\t\t\n\t\t\n\t\tif(str.charAt(0) == 'x') {\n\t\t\treturn smallerOutput + \"\"; // changed from str.charAt(0) to smallerOutput and it worked, why?\n\t\t\t// because we are building smallerOutput 1 char at a time and checking if each charAt(0) is out target\n\t\t}else {\n\t\t\treturn str.charAt(0) + smallerOutput;\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tString s = \"abxcdxedx\";\n\t\tSystem.out.println(removeX(s));\n\n\t}\n\n}\n"
        },
        {
          "fileName": "replacePi.java",
          "code": "package Recursion;\n\npublic class replacePi {\n\t// replace instances of 'pi' in a string with '3.14'\n\tpublic static String replacePi(String str) {\n\t\tif(str.length() <=1 ) {\n\t\t\treturn str;\n\t\t}\n\t\tif(str.charAt(0) == 'p' && str.charAt(1) == 'i') {\n\t\t\t// call recursion on length n-2 for case \"pipi\"\n\t\t\tString smallOutput = replacePi(str.substring(2));\n\t\t\treturn \"3.14\" + smallOutput;\n\t\t}else {\n\t\t\t//call recursion on string length n-1\n\t\t\tString smallOutput = replacePi(str.substring(1));\n\t\t\treturn str.charAt(0) + smallOutput;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(replacePi(\"apiapiapipipi\"));\n\t}\n\n}\n"
        },
        {
          "fileName": "sortedArray.java",
          "code": "package Recursion;\n\npublic class sortedArray {\n\n\tpublic static boolean isSorted(int[] arr) {\n\t\tif(arr.length == 1) {\n\t\t\treturn true;\n\t\t}\n\t\tif(arr[0] > arr[1]) {\n\t\t\treturn false;\n\t\t}\n\t\tint[] smallerArray = new int[arr.length-1];\n\t\tfor(int i = 1; i < arr.length; i++) {\t\t// make a new array and copy over arr\n\t\t\tsmallerArray[i-1] = arr[i];\n\t\t}\n\t\tboolean isSmallArraySorted = isSorted(smallerArray);\n\t\treturn isSmallArraySorted;\n\t}\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tint[] array = {5,1,2,7,9,3,4};\n\t\tint[] array1 = {1,2,3,4,5,6};\n\t\tSystem.out.println(isSorted(array));\n\t\tSystem.out.println(isSorted(array1));\n\t}\n\n}\n"
        },
        {
          "fileName": "stringPalindrome.java",
          "code": "package Recursion;\n\npublic class stringPalindrome {\n\t\n\t   public static boolean isPalindrome(String s) {\n\t        if (s.length() <= 1) {\n\t            return true;\n\t        }\n\t        \n\t        char firstChar = s.charAt(0);\n\t        char lastChar = s.charAt(s.length() - 1);\n\t        \n\t        if (firstChar == lastChar) {\n\t            String subString = s.substring(1, s.length() - 1);\n\t            return isPalindrome(subString);\n\t        } else {\n\t            return false;\n\t        }\n\t    }\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tString input = \"racecar\"; // Change this string to test different cases\n        boolean isPalin = isPalindrome(input);\n        \n        System.out.println(\"Is \\\"\" + input + \"\\\" a palindrome? \" + isPalin);\n\t}\n\n}\n"
        },
        {
          "fileName": "stringRecursion.java",
          "code": "package Recursion;\n\npublic class stringRecursion {\n\t// take a string and replace all occurrences of char a with char b\n\tpublic static String replace(String s, char a, char b) {\n\t\tif(s.length() == 0) { // this is returning an empty string\n\t\t\treturn s;\n\t\t}\n\t\tString smallOutput = replace(s.substring(1), a, b); // .substring method takes a starting index and goes to the end or, takes a start and end index. \n\t\t\n\t\tSystem.out.println(\"small : \" + smallOutput);\n\t\tSystem.out.println(\"s : \" + s);\n\t\t\n\t\tif (s.charAt(0) == a) {\n\t\t\treturn b + smallOutput; // at first we are appending to an empty string and this order matters\n\t\t}else {\n\t\t\treturn s.charAt(0) + smallOutput;\n\t\t}\n\t}\n\t/////////////////////2 function////////////////////////////////\n\tpublic static String removeDuplicates(String s) {\n\t\t// remove consecutive duplicates\n\t\tif(s.length() <= 1) {\n\t\t\tSystem.out.println(\"hit\");\n\t\t\treturn s;\n\t\t}\n\t\n\t\tString smallStr = removeDuplicates(s.substring(1));\n\t\tif(s.charAt(0) == smallStr.charAt(0)) {\n\t\t\treturn  \"\" + smallStr ;\n\t\t}\n\t\treturn s.charAt(0) + smallStr ;\n\t}\n\tpublic static void main(String[] args) {\n//\t\tString s = \"abxcdxedx\";\n//\t\tSystem.out.println(replace(s, 'x', 'y'));\n\t\tString t = \"abbbcdefff\";\n\t\tSystem.out.println(removeDuplicates(t));\n\t}\n\n}\n"
        },
        {
          "fileName": "stringToNumber.java",
          "code": "package Recursion;\n\npublic class stringToNumber {\n\tpublic static int convertToNum(String str) {\n        return convertToNumberRecursive(str, 0);\n    }\n\n    public static int convertToNumberRecursive(String str, int index) {\n        if (index == str.length()) {\n            return 0;\n        }\n\n        int digit = str.charAt(index) - '0';\n        int multiplier = (int) Math.pow(10, str.length() - 1 - index);\n        int remainingNumber = convertToNumberRecursive(str, index + 1);\n\n        return digit * multiplier + remainingNumber;\n    }\n\n    public static void main(String[] args) {\n        String str = \"12345\";\n        int number = convertToNum(str);\n        System.out.println(\"Converted number: \" + number);\n    }\n}"
        },
        {
          "fileName": "sumOfDigits.java",
          "code": "package Recursion;\n\npublic class sumOfDigits {\n\n\tpublic static int sum(int n){\n\t\tif(n == 0){\n\t\t\treturn n;\n\t\t}\n\n\t\tint smallSum = sum(n / 10);\n\t    int digit = n % 10;\n\t        \n\t    return smallSum + digit;\n\t}\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tint total = sum(12345);\n\t\tSystem.out.println(total);\n\t}\n\n}\n"
        }
      ]
    },
    {
      "name": "StackWithLinkedList",
      "files": [
        {
          "fileName": "Stack.java",
          "code": "package StackWithLinkedList;\n// full implementation of a singly linked list with a stack\npublic class Stack {\n    private class Node {\n        int data;\n        Node next;\n\n        Node(int data) {\n            this.data = data;\n            this.next = null;\n        }\n    }\n\n    private Node top;\n    private int size;\n\n    public Stack() {\n        top = null;\n        size = 0;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public boolean isEmpty() {\n        return (size == 0);\n    }\n\n    public void push(int element) {\n        Node newNode = new Node(element);\n        newNode.next = top;\n        top = newNode;\n        size++;\n    }\n\n    public int pop() {\n        if(isEmpty()) {\n            return -1; // stack is empty\n        }\n        int temp = top.data;\n        top = top.next;\n        size--;\n        return temp;\n    }\n\n    public int top() {\n        if(isEmpty()) {\n            return -1; // stack is empty\n        }\n        return top.data;\n    }\n}\n"
        },
        {
          "fileName": "StacksWithLinkedList.java",
          "code": "package StackWithLinkedList;\n\nimport Stacks.StackEmptyException;\nimport linkedLists.LinkedListNodeClass; // imported from previous package\n\npublic class StacksWithLinkedList <T> {\n\t// head of linked list\n\tprivate LinkedListNodeClass<T> head;\n\t// to optimize speed rather than iterating over the linked list to count it for the size() method, just keep a size variable\n\tprivate int size;\n\t\n\tpublic StacksWithLinkedList() {\n\t\thead = null;\n\t\tsize = 0;\n\t}\n\t\n\tpublic int size() {\n\t\treturn size;\n\t}\n\t\n\tpublic boolean isEmpty() {\n\t\treturn size == 0;\n\t}\n\t\n\tpublic void push(T elem) {\n\t\t// the newly inserted element is the new head\n\t\tLinkedListNodeClass<T> p = new LinkedListNodeClass<T>(elem);\n\t\tp.next = head;\n\t\thead = p;\n\t\tsize++;\n\t}\n\t\n\tpublic T top() throws StackEmptyException {\n\t\tif(head == null || size == 0) {\n\t\t\tthrow new StackEmptyException();\n\t\t}\n\t\treturn head.data;\n\t}\n\t\n\tpublic T pop() throws StackEmptyException {\n\t\tif(head == null) {\n\t\t\tthrow new StackEmptyException();\n\t\t}\n\t\tT temp = head.data;\n\t\thead = head.next;\n\t\tsize--;\n\t\treturn temp;\n\t\t\n\t}\n}\n"
        },
        {
          "fileName": "javaCollectionsFrameWork.java",
          "code": "package StackWithLinkedList;\n\nimport java.util.Stack;\nimport java.util.Vector;\n\npublic class javaCollectionsFrameWork {\n\n\tpublic static void main(String[] args) {\n\t\tStack<Integer> stack = new Stack<>();\n\t\tstack.push(10);\n\t\tstack.size();\n\t\tSystem.out.println(stack.size());\n\t\t// give the top element\n\t\tstack.peek();\n\t\t// removes an element\n\t\tstack.pop();\n\t\t// checks if stack is empty\n\t\tstack.isEmpty();\n\t\t// travel the elements not the indicies\n\t\tint[] arr= {10, 11, 13, 14, 5, 8};\n\t\tfor(int elem : arr) {\n\t\t\tstack.push(elem);\n\t\t}\n\t\twhile(!stack.isEmpty()) {\n\t\t\tSystem.out.println(stack.pop());\n\t\t}\n\t\tstack.push(5);\n        stack.push(10);\n        stack.push(15);\n        System.out.print(stack.pop()+stack.size());\n\t}\n\n}\n"
        },
        {
          "fileName": "stackUse.java",
          "code": "package StackWithLinkedList;\n\nimport Stacks.StackEmptyException;\n\npublic class stackUse {\n\n\tpublic static void main(String[] args) throws StackEmptyException {\n\t\t\n\t\tStacksWithLinkedList<Integer> Newstack = new StacksWithLinkedList<>();\n\t\t\n\t\tint[] arr = {10, 11, 13, 14, 5, 8};;\n\t\t\n\t\n\t\tfor(int i = 0; i < arr.length; i++) {\n\t\t\tNewstack.push(arr[i]);\n\t\t}\n\t\twhile (!Newstack.isEmpty()) {\n\t\t\tSystem.out.println(Newstack.pop());\n\t\t}\n\t}\n\n}\n"
        }
      ]
    },
    {
      "name": "Stacks",
      "files": [
        {
          "fileName": "BalancedBrackets.java",
          "code": "package Stacks;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n// is this expression balanced? (a{b+c[d-e]+f}) * For each type of bracket, its matched with another in Last in First out Sequence.\n// Push the brackets onto a stack, until you reach a closing bracket, then check for the last in first out sequence\nimport java.util.Stack;\n\npublic class BalancedBrackets {\n\t\n\tpublic static boolean isBalanced(String expression) {\n        Stack<Character> stack = new Stack<>();\n\n        for (char ch : expression.toCharArray()) {\n            if (ch == '(') {\n                stack.push(ch);  // Push opening bracket to the stack\n            } else if (ch == ')') {\n                if (stack.isEmpty() || stack.peek() != '(') {  // No corresponding opening bracket\n                    return false;\n                }\n                stack.pop();  // Pop the corresponding opening bracket from the stack\n            }\n        }\n\n        return stack.isEmpty();  // Check if all opening brackets are closed\n    }\n\t\n\t\n\t///////////////////////////////////////////////\n//\tRedundant brackets\n\tpublic static boolean checkRedundantBrackets(String expression) {\n\t\t//Your code goes here\n\t\tDeque<Character> stack = new ArrayDeque<>();\n        for (char ch : expression.toCharArray()) {\n            if (ch != ')') {\n                stack.push(ch);\n            } else {\n                if (stack.peek() == '(') {\n                    return true; // Found redundant brackets\n                } else {\n                    // Discard all characters until the matching opening bracket\n                    while (!stack.isEmpty() && stack.peek() != '(') {\n                        stack.pop();\n                    }\n                    // Discard the opening bracket\n                    if (!stack.isEmpty()) {\n                        stack.pop();\n                    }\n                }\n            }\n        }\n        return false; // No redundant brackets found\n\t}\n\t/////////////////////////////////////////////////\n//\tBracket reversal \n\t\n//\tFor a given expression in the form of a string, find the minimum number of brackets that can be reversed \n//\tin order to make the expression balanced. The expression will only contain curly brackets.\n//\tIf the expression can't be balanced, return -1.\n\tpublic static int countBracketReversals(String input) {\n\t\t//Your code goes here\n\t\tif (input.length() % 2 != 0) {\n            // If number of brackets is not even then we can't make pairs\n            return -1;\n        }\n\n        Deque<Character> stack = new ArrayDeque<>();\n        for (char ch : input.toCharArray()) {\n            if (ch == '{') {\n                stack.push(ch);\n            } else { // ch == '}'\n                if (!stack.isEmpty() && stack.peek() == '{') {\n                    stack.pop();\n                } else {\n                    stack.push(ch);\n                }\n            }\n        }\n\n        int count = 0;\n        while (!stack.isEmpty()) {\n            char c1 = stack.pop();\n            char c2 = stack.pop();\n            // If both are same i.e., {{ or }}, then we need to reverse one bracket\n            // If not same i.e., {} or }{, then we need to reverse both brackets\n            if (c1 == c2) {\n                count++;\n            } else {\n                count += 2;\n            }\n        }\n\n        return count;\n\t}\n\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\t \tString expression = \"(())()\";  // Example expression\n\t\t \t\n\t        boolean balanced = isBalanced(expression);\n\t        \n\t        System.out.println(balanced);\n\t}\n\n}\n"
        },
        {
          "fileName": "ReverseStack.java",
          "code": "package Stacks;\n\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\npublic class ReverseStack {\n\t public static void reverseStack(Deque<Integer> input, Deque<Integer> extra) {\n\t        while (!input.isEmpty()) {\n\t            extra.push(input.pop());\n\t        }\n\t        \n\t        while (!extra.isEmpty()) {\n\t            System.out.print(extra.pop() + \" \");\n\t        }\n\t    }\n\n    public static void main(String[] args) {\n    \t\n    \tDeque<Integer> stack1 = new ArrayDeque<>();\n        stack1.push(1);\n        stack1.push(2);\n        stack1.push(3);\n        stack1.push(4);\n        Deque<Integer> stack2 = new ArrayDeque<>();\n\n        reverseStack(stack1, stack2); // This will print: 1 2 3 4 \n    }\n}\n"
        },
        {
          "fileName": "Stack.java",
          "code": "package Stacks;\n\npublic class Stack {\n\t// we are storing our stack in an array\n\t\n\tprivate int data[]; // \n\tprivate int topIndex; // holds the top index for pushing elements to the array\n\t\n\t\n\tpublic Stack(int elem) {\n\t\tdata = new int[elem];\n\t\ttopIndex = -1;\n\t}\n//\tpublic Stack() {\n//\t\tdata = new int[10];\n//\t\ttopIndex = -1;\n//\t}\n\t// O(1)\n\tpublic void push(int elem){\n\t\t// if stack full\n\t\tif(topIndex == data.length-1) {\n//\t\t\tStackFullException e = new StackFullException();\n//\t\t\t//throw e;\n//\t\t\tthrow new StackFullException();\n\t\t\tdoubleCapacity();\n\t\t}\n\t\ttopIndex ++;\n\t\tdata[topIndex] = elem;\n\t}\n\tprivate void doubleCapacity() {\n\t\tSystem.out.println(\"double capacity\");\n\t\t// create a larger array\n\t\tint[] temp = data;\n\t\tdata = new int[2 * temp.length];\n\t\t// copy over the array\n\t\tfor(int i = 0; i < temp.length; i++) {\n\t\t\tdata[i] = temp[i];\n\t\t}\n\t}\n\t\n\t// time complexity = O(1)\n\tpublic int size() {\n\t\treturn topIndex +1;\n\t}\n\t// O(1)\n\tpublic boolean isEmpty() {\n\t\tif(topIndex == -1) {\n\t\t\treturn true;\n\t\t}return false;\n\t}\n\t// O(1)\n\tpublic int top() throws StackEmptyException{\n\t\tif(topIndex == -1) {\n\t\t\t// throw stack empty\n\t\t\tthrow new StackEmptyException();\n\t\t}\n\t\treturn data[topIndex];\n\t}\n\t// O(1)\n\tpublic int pop() throws StackEmptyException {\n\t\t// remove from the stack\n\t\tif(topIndex == -1) {\n\t\t\tthrow new StackEmptyException();\n\t\t} \n\t\tint temp = data[topIndex];\n\t\ttopIndex --;\n\t\treturn temp;\n\t}\n\t\n}\n"
        },
        {
          "fileName": "StackEmptyException.java",
          "code": "package Stacks;\n\npublic class StackEmptyException extends Exception {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\t\n}\n"
        },
        {
          "fileName": "StackFullException.java",
          "code": "package Stacks;\n\npublic class StackFullException extends Exception {\n\n\tprivate static final long serialVersionUID = 1L;\t// keeps track of the exception\n\t\n\t\n\t\n}\n"
        },
        {
          "fileName": "StackUse.java",
          "code": "package Stacks;\n\npublic class StackUse {\n\n\tpublic static void main(String[] args) throws StackFullException, StackEmptyException {\n\t\t// write down the functions that you want the software to perform\n\t\t\n\t\tStack Newstack = new Stack(2);\n\t\t\n\t\tint[] arr= {10, 11, 13, 14, 5, 8};\n\t\t\n\t\tfor(int i = 0; i < arr.length; i++) {\n\t\t\tNewstack.push(arr[i]);\n\t\t}\n\t\twhile (!Newstack.isEmpty()) {\n\t\t\tSystem.out.println(Newstack.pop());\n\t\t}\n\t\t\n//\t\t\n//\t\tNewstack.push(10); // add something to the stack\n//\t\tNewstack.top(); // read the top element of the stack\n//\t\tNewstack.pop(); // remove an element from the stack\n//\t\tNewstack.size(); // get the size of the stack\n//\t\tNewstack.isEmpty(); // check if the stack is empty\n\t}\n\n}\n"
        }
      ]
    },
    {
      "name": "Strings",
      "files": [
        {
          "fileName": "CheckStringPermutation.java",
          "code": "package Strings;\n\npublic class CheckStringPermutation {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\t// check if one string is a permutation of another (they must have identical characters, but in a different order from one another)\n\t\tString str1 = \"abcdefg\";\n\t\tString str2 = \"gcdbfea\";\n\t\tString test = \"\";\n\t\tboolean IsPermutation = false;\n\t\t\n\t\tfor(int i = 0; i< str1.length(); i++) {\n\t\t\t\n\t\t\tfor(int j = 0; j < str2.length(); j++) {\n\t\n\t\t\t\tif(str2.charAt(j) == str1.charAt(i)) {\n\t\t\t\t\ttest = test + str2.charAt(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(str1.equals(test)) {\n\t\t\tIsPermutation = true;\n\t\t}\n\t\tSystem.out.print(IsPermutation);\n\t\t\n\t\t\n\t}\n\n}\n"
        },
        {
          "fileName": "CountWords.java",
          "code": "package Strings;\npublic class CountWords {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t    String str = \"Hello World\";  \n\t\t\n\t\tString[] tokens = str.split(\"\\\\s+\"); // split by whitespace\n\t        int tokenCount = tokens.length;\n\t        \n\t        System.out.print(tokenCount);\n\t}\n\n}\n"
        },
        {
          "fileName": "Palindrome.java",
          "code": "package Strings;\n\npublic class Palindrome {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tString str = \"racecar\";\n\t\tString pal = \"\";\n\t\tfor(int i = str.length()-1; i >=0; i--){\n\t\t\tpal = pal + str.charAt(i);\n\t\t}\n\t\tboolean isValid = false;\n\t\t\n\t\tif (pal.equals(str)){\n\t\t\tisValid = true;\n\t\t}\n\t}\n\n}\n"
        },
        {
          "fileName": "RemoveConsecutiveDuplicates.java",
          "code": "package Strings;\n\npublic class RemoveConsecutiveDuplicates {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tString str = \"aaaabbcddeff\";\n\t\tString ans = \"\";\n\t\tint i = 1;\n\t\tint index = 0;\n\t\tans = ans + str.charAt(index);\n\t\twhile (i < str.length()) {\n\t\t\tif(str.charAt(i) == ans.charAt(index)) {\n\t\t\t\ti++;\n\t\t\t}else {\n\t\t\t\tchar tempChar = str.charAt(i);\n\t\t\t\tans = ans + tempChar;\n\t\t\t\tindex++;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.print(ans);\n\t}\n\n}\n"
        },
        {
          "fileName": "StringBasics.java",
          "code": "package Strings;\n\npublic class StringBasics {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\t// getting to know strings\n\t\t //char arr[] = {'C','o','d','i','n','g'};\n\t\t String str1 = \"abcd\";\n\t\t //String str2 = \" is fun \";\n\t\t String str3 = \"abcda\";\n\t\t //System.out.println(str1.contains(\"ing\"));\n\t\t //str1 += str2;\n\t\t //str2 = str1.concat(str2);\n\t\t //System.out.println(str1.equals(str3));\n\t\t // will compare lexicographically and print the difference in ASCII values\n\t\t System.out.println(str1.compareTo(str3));\n\t\t//System.out.println(str1.length());\n\t\t//System.out.println(str1.charAt(3));\n\t\t\n\t\t String a=\"coding\";\n\t\t for(int i=2;i<5;i++)\n\t\t {\n\t\t     System.out.print(a.substring(i-2,i+1));\n\t\t }\n\t\t }\n\t\t\n\t\t\n\t\t\n\t}\n\n"
        },
        {
          "fileName": "SubStrings.java",
          "code": "package Strings;\n\npublic class SubStrings {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n//\t\tprint substrings of pqrs.\n\t\tString str = \"pqrs\";\n\t\t\n\t\tfor(int i = 0; i <= str.length(); i++) {\n\t\t\tfor(int j = i; j<= str.length(); j++) {\n\t\t\t\tSystem.out.println(str.substring(i, j));\n\t\t\t}\n\t\t}\n\t\tfor(int m = 1; m <= str.length(); m++) {\n\t\t\t\n\t\t\tfor(int n = 0; n <= str.length()-m; n++) {\n\t\t\t\t\n\t\t\t\tint end = m + n - 1;\n\t\t\t\t\n\t\t\t\tSystem.out.println(str.substring(n, end+1));\n\t\t\t}\n\t\t}\n\t\tStringBuffer str1 = new StringBuffer(\"\");\n\t\tfor(int k=0;k<5;k++){\n\t\t\t\n\t\t    str1.append((char)('a'+k));\n\t\t}\n\t\tSystem.out.println(str1);\n\t\t\n\t}\n\n}\n"
        },
        {
          "fileName": "compressString.java",
          "code": "package Strings;\n\npublic class compressString {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tString str = \"aaaabbcddeff\";\n\t\tString ans = \"\";\n\t\tint i = 1;\n\t\tint index = 0;\n\t\tint count = 1;\n\t\tans = ans + str.charAt(index);\n\t\twhile (i < str.length()) {\n\t\t\tif(str.charAt(i) == ans.charAt(index)) {\n\t\t\t\tcount ++;\n\t\t\t\ti++;\n\t\t\t}else {\n\t\t\t\tif(count > 1) {\n\t\t\t\t\tans = ans + count;\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t\tchar tempChar = str.charAt(i);\n\t\t\t\tans = ans + tempChar;\n\t\t\t\tcount = 1;\n\t\t\t\tindex++;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tif (count > 1) {\n\t\t\tans = ans+count;\n\t\t}\n\t\tSystem.out.print(ans);\n\t}\n\n}\n"
        },
        {
          "fileName": "highestOccuringCharacter.java",
          "code": "package Strings;\n\npublic class highestOccuringCharacter {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tString str = \"abbcfddaeffe\";\n\t\tchar greatestIndex = str.charAt(0);\n\t\tint occurance = 0;\n\t\tint greatestOccurance = 0;\n\t\tfor(int i = 0; i < str.length(); i++) {\n\t\t\t\n\t\t\tString temp = str.replace(String.valueOf(str.charAt(i)), \"\");\n\t\t\toccurance = str.length() - temp.length();\n\t\t\t\n\t\t\tif(occurance > greatestOccurance) {\n\t\t\t\tgreatestIndex = str.charAt(i);\n\t\t\t\tgreatestOccurance = occurance;\n\t\t\t}\n\t\t}System.out.print(greatestIndex);\n\t}\n\n}\n"
        },
        {
          "fileName": "removeOccurancesOfChar.java",
          "code": "package Strings;\n\npublic class removeOccurancesOfChar {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tString str = \"aabcacbaa\";\n\t\tchar target = 'a';\n\t\tSystem.out.print(str.replace(String.valueOf(target), \"\"));\n\t}\n\n}\n"
        },
        {
          "fileName": "reverseEachWord.java",
          "code": "package Strings;\n\npublic class reverseEachWord {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tString str = \"Hello, Im learning how to code.\";\n\t\tString ans = \"\";\n\t\tint wordStart = 0;\n\t\tint i = 0;\n\t\tfor(; i< str.length(); i++) {\n\t\t\tif(str.charAt(i) == ' ') {\t// will cause the loop to execute if statement, when it reaches a space\n\t\t\t\t// reverse current word\n\t\t\t\tint wordEnd = i-1;\n\t\t\t\tString reversedWord = \"\"; // strings are immutable so a variable to store a new string is needed\n\t\t\t\tfor(int j = wordStart; j<= wordEnd; j++) {\n\t\t\t\t\treversedWord = str.charAt(j) + reversedWord; // concatenates the chars to the begining of reversed word\n\t\t\t\t}\n\t\t\t\t// add it to final string\n\t\t\t\tans += reversedWord + \" \";\n\t\t\t\twordStart = i + 1;\n\t\t\t}\n\t\t}\n\t\t// handle the last word\n\t\tint wordEnd = i-1;\n\t\tString reversedWord = \"\"; // strings are immutable so a variable to store a new string is needed\n\t\tfor(int j = wordStart; j<= wordEnd; j++) {\n\t\t\treversedWord = str.charAt(j) + reversedWord; // concatenates the chars to the begining of reversed word\n\t\t\n\t\t\n\t\t}\n\t\tans += reversedWord + \" \";\n\t\tSystem.out.print(ans);\n\t\t//return ans;\n\t}\n\n}\n"
        },
        {
          "fileName": "reverseStringWordwise.java",
          "code": "package Strings;\n\npublic class reverseStringWordwise {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tString str = \"Coding is fun.\";\n\t\tString ans = \"\";\n\t\tString reversed = \"\";\n\t\t// use wordStart to manipulate starting point of j\n\t\tint wordStart = 0;\n\t\t// use outer for loop to set the parameters for j\n\t\tfor(int i = 0; i < str.length(); i++) {\n\t\t\t\n\t\t\tif(str.charAt(i) == ' ') {\n\t\t\t\t\n\t\t\t\tint wordEnd = i-1;\n\t\t\t\t\n\t\t\t\tfor(int j = wordStart; j <= wordEnd; j++){\n\t\t\t\t\treversed += str.charAt(j);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tans = reversed + \" \" + ans ;\n\t\t\t\twordStart = i + 1;\n\t\t\t\treversed = \"\";\n\t\t\t}\n\t\t}\n\t\t// handle last word (outside of the outer loop)\n\t\tint wordEnd = str.length() - 1;\n\t\tfor(int j = wordStart; j<= wordEnd; j++) {\n\t\t\treversed += str.charAt(j);\n\t\t}\n\t\tans = reversed + \" \" + ans;\n\t\t\n\t\tSystem.out.print(ans);\n\t\t \n\t}\n\n}\n"
        }
      ]
    },
    {
      "name": "Time_SpaceComplexity",
      "files": [
        {
          "fileName": "duplicateInArray.java",
          "code": "package Time_SpaceComplexity;\n//The first line contains an Integer 't' which denotes the number of test cases or queries to be run. \n//Then the test cases follow.\n//First line of each test case or query contains an integer 'N' representing the size of the array/list.\n//Second line contains 'N' single space separated integers representing the elements in the array/list\npublic class duplicateInArray {\n//\tHashing: Keep a boolean array, initially all set to false. Iterate over the array/list, \n//\tand if a value at index arr[i] is marked true in boolean array, \n//\tthen this is the repeating element. If it is not marked, then mark it.\n\tpublic static int findDuplicate(int[] arr) {\n\t    boolean[] boolArr = new boolean[arr.length - 1];\n\t    for(int i = 0; i < arr.length; i++) {\n\t        if(boolArr[arr[i]]) {\n\t            return arr[i];\n\t        }\n\t        boolArr[arr[i]] = true;\n\t    }\n\t    return -1; // In case no duplicate is found\n\t}\n\t\n//\talternative: \n//\tSum formula: Sum all the elements in the array and subtract the sum of numbers from 0 to N-2 from this sum. \n//\tThe result will be the duplicate number. \n//\tNote that this method could potentially lead to integer overflow if N is large.\n\t\n\tpublic static int findDuplicate1(int[] arr) {\n\t    int sum = 0;\n\t    for(int i = 0; i < arr.length; i++) {\n\t        sum += arr[i];\n\t    }\n\t    int n = arr.length - 2;\n\t    int sumToN = n * (n + 1) / 2;\n\t    return sum - sumToN;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tint[] arr = {0, 3, 1, 5, 4, 3, 2};\n\t\tint solution = findDuplicate(arr);\n\t\tSystem.out.println(solution);\n\t}\n\n}\n"
        },
        {
          "fileName": "equilibriumIndex.java",
          "code": "package Time_SpaceComplexity;\n// find an index i where the sum of elements on left is equal to sum of elements on right, if not present return -1\npublic class equilibriumIndex {\n// begin at first index save leftside value = 0 (there is no left side elements so its sum is 0)\n// calculate sum of right side elements save this value rightside value = (sum of rest of elements)\n\t// compare right side sum and left side sum (if ==) return current index (else move to next)\n// move to next element update left side sum to [current index-1] + leftside sum\n// update right side sum by subtracting current index from right side sum\n\t// compare right side sum and left side sum (if ==) return current index (else move to next)\n// if current index == arr.length -1 and no equilibrium has been found return -1\n\t\n\tpublic static int equilibrium(int[] arr) {\n\t    // this runs at O(n) time complexity \n\t\t// because each element is visited only 1 time in the for loop and the while loop\n\t\t\n\t\tint leftSum = 0;\n\t    int rightSum = 0;\n\t    int i = 0;\n\t    if (arr.length == 1) {\n\t        return 0;\n\t    }\n\t    else if (arr.length == 2) {\n\t        return -1;\n\t    }\n\t    else {\n\t        for(i = 1; i < arr.length; i++) {\n\t            rightSum += arr[i];\n\t        }\n\t        i = 0;\n\t        while(i < arr.length) {\n\t            if(rightSum == leftSum) {\n\t                return i;\n\t            }\n\t            leftSum += arr[i];\n\t            if(i + 1 < arr.length) {\n\t                rightSum -= arr[i + 1];\n\t            }\n\t            i++;\n\t        }\n\t        return -1;\n\t    }\n\t}\n\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tint[] arr1 = {1, 2, 4, 1, 3, 4, 3, 1};\n\t\t\n\t\tint eqPoint = equilibrium(arr1);\n\t\tSystem.out.println(eqPoint);\n\t}\n\n}\n"
        },
        {
          "fileName": "findArrayIntersection.java",
          "code": "package Time_SpaceComplexity;\n//QuickSort Time Complexity: QuickSort, in the average case, has a time complexity of O(n log n), \n//where n is the number of elements in the array. This is because the algorithm divides the array into two halves at each level (log n levels) and performs linear work (n) at each level. \n//However, in the worst-case scenario (when the array is already sorted or reverse sorted), QuickSort runs in O(n^2) time. This worst-case scenario is rare, especially when the pivot is chosen wisely (e.g., randomly or using the median-of-three method).\n//\n//Intersection Time Complexity: The intersection part of the code has a time complexity of O(n + m), \n//where n is the number of elements in arr1 and m is the number of elements in arr2. \n//This is because, in the worst-case scenario, the code needs to go through all the elements in both arrays once.\n//\n//Combining both parts, in the average case, the time complexity of the entire program is O(n log n) for sorting arr1, \n//O(m log m) for sorting arr2, and O(n + m) for finding the intersection, resulting in a total time complexity of O(n log n + m log m + n + m).\n//\n//However, the comment in your code states the time complexity as O(n^2), which seems to be considering the worst-case scenario for the QuickSort algorithm. \n//But remember, this scenario is quite rare with proper pivot selection strategies.\n//\n//Keep in mind that the Big O notation describes the upper bound of the time complexity in the worst case, \n//so it is not incorrect to say the time complexity is O(n^2), but it does not represent the average case for this code, which is more likely to be encountered.\npublic class findArrayIntersection {\n\t\n\tpublic static void quickSort(int[] arr, int start, int end){\n\t\tif (start < end){\n\t\t\tint pivotIndex = partition(arr, start, end);\n\t\t\tquickSort(arr, start, pivotIndex -1);\n\t\t\tquickSort(arr, pivotIndex+1, end);\n\t\t}\n\t}\n\n\tpublic static int partition(int[] arr, int start, int end){\n\t\tint pivot = arr[end];\n\t\tint i = (start - 1);\n\t\tfor(int j = start; j < end; j++){\n\t\t\tif (arr[j] <= pivot) {\n\t\t\t\ti++;\n\n\t\t\t\tint temp = arr[i];\n\t\t\t\tarr[i] = arr[j];\n\t\t\t\tarr[j] = temp;\n\t\t\t} \n\t\t}\n\t\tint temp = arr[i + 1];\n\t\tarr[i + 1] = arr[end];\n\t\tarr[end] = temp;\n\t\treturn i +1;\n\t}\n\tpublic static void main(String[] args) {\n\t\t// Time complexity = O(n^2) \n\t\t// find intersection\n\t\tint[] arr1 = {2, 6, 8, 5, 4, 3};\n\t\tint[] arr2 = {6, 9, 8, 5, 9, 2};\n\t\t// sort the arrays first\n\t\tquickSort(arr1, 0, arr1.length - 1);\n        quickSort(arr2, 0, arr2.length - 1);\n        \n        // Use two pointers to find common elements\n        int i = 0, j = 0;\n        while (i < arr1.length && j < arr2.length) {\n            // if (i > 0 && arr1[i] == arr1[i-1]) {\n            //     // Skip duplicate elements in arr1\n            //     i++;\n            //     continue;\n            // }\n        \t// compare element in each sorted array and increment\n            if (arr1[i] < arr2[j]) {\n                i++;\n            } else if (arr1[i] > arr2[j]) {\n                j++;\n            } else {\n                // Print intersection element\n                System.out.print(arr1[i] + \" \");\n                i++;\n                j++;\n            }\n        }\n        System.out.println();\n\t}\n\n}\n"
        },
        {
          "fileName": "findTriplets.java",
          "code": "package Time_SpaceComplexity;\n//You have been given a random integer array/list(ARR) and a number X. \n//Find and return the triplet(s) in the array/list which sum to X.\n//Note :\n//Given array/list can contain duplicate elements.\npublic class findTriplets {\n\n\tpublic static int findTriplets(int[] arr, int X) {\n\t\t int n = arr.length;\n\t        int count = 0;\n\n\t        for (int i = 0; i < n - 2; i++) {\n\t            for (int j = i + 1; j < n - 1; j++) {\n\t                for (int k = j + 1; k < n; k++) {\n\t                    if (arr[i] + arr[j] + arr[k] == X) {\n\t                        count++;\n\t                    }\n\t                }\n\t            }\n\t        }\n\n\t        return count;\n    }\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tint[] arr = {1, 2, 3, 4, 5, 6, 7};\n\t\tint solution = findTriplets(arr, 7);\n\t\tSystem.out.println(solution);\n\t}\n\n}\n"
        },
        {
          "fileName": "findUniqueElement.java",
          "code": "package Time_SpaceComplexity;\n//You have been given an integer array/list(ARR) of size N. Where N is equal to [2M + 1].\n//Now, in the given array/list, 'M' numbers are present twice and one number is present only once.\n//You need to find and return that number which is unique in the array/list.\npublic class findUniqueElement {\n//\tThe XOR operator has some unique properties:\n//\n//It returns zero when we take XOR of two same numbers.\n//It returns the same number when we take XOR of a number with zero.\n//By taking the XOR of all the elements in the array, \n//we will be left with the unique number as all pairs will cancel each other out \n//and the XOR will return the unique number.\n\n\tpublic static int uniqueElement(int[] arr) {\n\t\tint uniqueElement = 0;\n\t\tfor(int i = 0; i < arr.length; i++) {\n\t\t\tuniqueElement ^= arr[i];  \n// A number XORed with itself will always result in 0. \n// This is because each bit in the number is identical to the corresponding bit in the other number, \n// and XORing identical bits results in 0.\n\t\t\t\n//\tA number XORed with 0 will always result in the original number. \n//\tThis is because XORing any bit with 0 results in the original bit.\n\t\t}\n\t\treturn uniqueElement;\n\t\n\t}\n//This code will iterate through all elements in the array and apply XOR operation. \n//All numbers that are present twice will cancel out each other and the result will be the unique number \n//that is present only once. The time complexity is O(n) and space complexity is O(1).\t\n//\tXOR (^=)\n//\tA B A XOR B\n//\t-----------\n//\t0 0    0\n//\t0 1    1\n//\t1 0    1\n//\t1 1    0 (0 is false and 1 is true)\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tint[] arr = {1, 3, 1, 3, 6, 6, 7, 10, 7};\n\t\tint element = uniqueElement(arr);\n\t\tSystem.out.println(element);\n\t}\n\n}\n"
        },
        {
          "fileName": "rotateArray.java",
          "code": "package Time_SpaceComplexity;\n//You have been given a random integer array/list(ARR) of size N. \n//Write a function that rotates the given array/list by D elements(towards the left).\n//Note:\n//Change in the input array/list itself. You don't need to return or print the elements.\npublic class rotateArray {\n\t\n//\tPlease note that this approach has a time complexity of O(n) and a space complexity of O(d) \n//\tbecause we are using an additional temporary array of size d. However, this is a straightforward \n//\tmethod and is easy to understand. There are other methods with better space complexity \n//\t(like the Juggling algorithm) that you can explore for more efficiency.\n\t\n\tpublic static void rotate(int[] arr, int d) {\n        int n = arr.length;\n        int[] temp = new int[d];\n        \n        // Step 1: Copy the first 'd' elements in a temporary array\n        for (int i = 0; i < d; i++) {\n            temp[i] = arr[i];\n        }\n        \n        // Step 2: Shift the rest of the arr[] elements towards left \n        for (int i = d; i < n; i++) {\n            arr[i - d] = arr[i];\n        }\n        \n        // Step 3: Store back the d elements\n        for (int i = 0; i < d; i++) {\n            arr[i + n - d] = temp[i];\n        }\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {1, 2, 3, 4, 5, 6, 7};\n        int d = 2;\n        \n        rotate(arr, d);\n        \n        // Print the rotated array\n        for (int i = 0; i < arr.length; i++) {\n            System.out.print(arr[i] + \" \");\n        }\n\t}\n\n}\n"
        },
        {
          "fileName": "sumToNum.java",
          "code": "package Time_SpaceComplexity;\nimport java.util.HashMap;\n//You have been given an integer array/list(ARR) and a number 'num'. \n//Find and return the total number of pairs in the array/list which sum to 'num'.\npublic class sumToNum {\n//\tYou can solve this problem by creating a map or an array to store the frequencies of each element in the array. \n//\tThen, iterate through the array again and for each element check if there exists \n//\ta pair that makes up the sum to 'num'. \n//\tBe careful to avoid counting any pair twice.\n\t\n\t    public static int numPairsSumToNum(int[] arr, int num) {\n\t        HashMap<Integer, Integer> frequencies = new HashMap<>();\n\t        int count = 0;\n\t        \n\t        for (int i = 0; i < arr.length; i++) {\n\t            int complement = num - arr[i];\n\t            if (frequencies.containsKey(complement)) {\n\t                count += frequencies.get(complement);\n\t            }\n\t            \n\t            if (!frequencies.containsKey(arr[i])) {\n\t                frequencies.put(arr[i], 0);\n\t            }\n\t            frequencies.put(arr[i], frequencies.get(arr[i]) + 1);\n\t        }\n\t        \n\t        return count;\n\t    }\n\n//\t    In this code, we first create a map to store the frequencies of each number in the array. \n//\t    Then, for each number, we calculate its complement with respect to the target sum 'num'. \n//\t    If this complement is in our map, we add its frequency to our count. This accounts for all \n//\t    the pairs that include the current number and sum to 'num'. Finally, \n//\t    we update the frequency of the current number in the map.\n//\n//\t    The time complexity of this solution is O(n), where n is the size of the input array, \n//\t    because we do a constant amount of work for each element\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tint[] arr = {1, 3, 6, 2, 5, 4, 3, 2, 4};\n\t\tint num = 7;\n\t\tint solution = numPairsSumToNum(arr, num);\n\t\tSystem.out.println(solution);\n\t}\n\n}\n"
        }
      ]
    },
    {
      "name": "arrayLists",
      "files": [
        {
          "fileName": "arrayList.java",
          "code": "package arrayLists;\n\nimport java.util.ArrayList;\n\n// array list create a dynamic array\npublic class arrayList {\n\n\t// remove consecutive duplicates from array\n\tpublic static ArrayList<Integer> removeConsecutiveDuplicates(int arr[]){\n\t\tArrayList<Integer> result = new ArrayList<>();\n\t\tresult.add(arr[0]);\n\t\tfor(int i = 1; i < arr.length; i ++) {\n\t\t\tif(arr[i] != arr[i - 1]) {\n\t\t\t\tresult.add(arr[i]);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tArrayList<Integer> arr = new ArrayList<>();\n\t\tarr.add(10);\n\t\tarr.add(20);\n\t\tarr.add(30);\n\t\tarr.add(1, 80);\t// will add 80 at index 1, and shift remaining elements\n\t\tarr.remove(2);\t// removes index 2\n\t\tSystem.out.println(arr.size());\n\t\tSystem.out.println(arr.get(2));\t// get the element at index 2\n\t\t\n\t\t// print all indices\n\t\tfor(int i = 0; i < arr.size(); i++) {\t\t// i is just an index\n\t\t\tSystem.out.println(arr.get(i));\n\t\t}\n\t\t\n\t\t// enhanced follow (for each loop)\n\t\tfor(int i : arr) {\t\t\t// i holds the value of the array list element\n\t\t\tSystem.out.println(i);\n\t\t}\n\t\t\n\t\tint[] arr1 = {10,10,20,20,30,40,40,50,10};\n\t\t\n\t\tArrayList <Integer> result = removeConsecutiveDuplicates(arr1);\n\t\t\n\t\tfor(int i : result) {\n\t\t\tSystem.out.println(i);\n\t\t}\n\t\t\n\t}\n\n}\n"
        }
      ]
    },
    {
      "name": "fundamentals",
      "files": [
        {
          "fileName": "ASC_II_Values.java",
          "code": "package fundamentals;\n\npublic class ASC_II_Values {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\t\n//\t\tASC II values of characters/ ASC II of a = 97.... 97 + 3 = 100\n\t\tchar ch = 'a';\n\t\tSystem.out.println(ch + 3);\n\t\tSystem.out.println((int)ch);\n\t\t\n//\t\tmin and max value of 4 byte int;\n\t\t\n\t\tint min = Integer.MIN_VALUE;\n\t\tint max = Integer.MAX_VALUE;\n\t\t\n\t\tSystem.out.println(min + \" \" + max);\n\t\t\t\t\n\n\t}\n\n}\n"
        },
        {
          "fileName": "AddTwoNumbers.java",
          "code": "package fundamentals;\n//\n//public class AddTwoNumbers {\n//\n//\tpublic static void main(String[] args) {\n//\t\t\n//\t\tint a = 10;\n//\t\tint b = 25;\n//\t\tint c = a + b;\n//\t\tSystem.out.println(c);\n//\t\t\n//\n//\t}\n//\n//}\n"
        },
        {
          "fileName": "ArithmeticOperators.java",
          "code": "//package fundamentals;\n//\n//public class ArithmeticOperators {\n//\tpublic static void main(String[] args) {\n//\t\tint a =10;\n//\t\tint b = 3;\n//\t\tint c = a / b;\n//\t\tint d = b % a;\n//\t\t\n//\t\tSystem.out.println(c);\n//\t\tSystem.out.println(d);\n//\t}\n//}\n"
        },
        {
          "fileName": "AverageTestScores.java",
          "code": "//package fundamentals;\n////Write a program to input a name(as a single character) and marks of three tests as m1, m2, and m3 of a student considering all the three marks have been given in integer format.\n////Now, you need to calculate the average of the given marks and print it along with the name as mentioned in the output format section.\n////All the test marks are in integers and hence calculate the average in integer as well. That is, you need to print the integer part of the average only and neglect the decimal part.\n////\n////\n////\n////Input format :\n////Line 1 : Name(Single character)\n////Line 2 : Marks scored in the 3 tests separated by single space. \n////Output format :\n////First line of output prints the name of the student.\n////Second line of the output prints the average mark.\n////Constraints\n////Marks for each student lie in the range 0 to 100 (both inclusive)\n//import java.util.Scanner;\n//\n//public class AverageTestScores {\n//\n//\tpublic static void main(String[] args) {\n//\t\t// TODO Auto-generated method stub\n//\t\tScanner s = new Scanner(System.in);\n//\t\t// Take input\n//\t\tString str = s.next();\n//\t\t char ch = str.charAt(0);\n//\t\tint m1 = s.nextInt();\n//\t\tint m2 = s.nextInt();\n//\t\tint m3 = s.nextInt();\n//\t\t// calculate Average\n//\t\tint Avg = (m1+m2+m3)/3;\n//\t\t// print\n//\t\tSystem.out.println(ch);\n//\t\tSystem.out.print(Avg);\n//\t}\n//\n//}\n"
        },
        {
          "fileName": "CalcTotalSalary.java",
          "code": "//package fundamentals;\n//\n//import java.util.Scanner;\n//\n//public class CalcTotalSalary {\n//\n//\tpublic static void main(String[] args) {\n//\t\t// TODO Auto-generated method stub\n//\t\t\n//\t\t\tScanner s = new Scanner(System.in);\n//\t\t\t\n//\t\t\tString str = s.nextLine();\n//\t\t\t\n//\t\t\tchar RsLast = str.charAt(str.length()-1);\t\t\t\t// access last element of the string\n//\t\t\t\n//\t\t\tString RsFirst = str.substring(0, str.length()-2);\t\t\t// get string starting at index zero not including last index\n//\t\t\t\n//\t\t\tdouble Rs = Integer.parseInt(RsFirst);\n//\t\t\t\n//\t\t\tdouble hra = 0.20;\n//\t\t\t\n//\t\t\tdouble da = 0.50;\n//\t\t\t\n//\t\t\tdouble pf = 0.11;\t\n//\t\t\t\n//\t\t\tif (RsLast == 'A') {\n//\t\t\t\tdouble SalaryA = Math.ceil((Rs + (Rs * hra) + (Rs * da)) + 1700-(Rs * pf));\n//\t\t\t\tint totalSalaryA = (int) SalaryA;\n//\t\t\t\tSystem.out.println(totalSalaryA);\n//\t\t\t}else if(RsLast == 'B') {\n//\t\t\t\tdouble SalaryB = Math.ceil((Rs + (Rs * hra) + (Rs * da) + 1500)-(Rs * pf));\n//\t\t\t\tint totalSalaryB = (int) SalaryB;\n//\t\t\t\tSystem.out.println(totalSalaryB);\n//\t\t\t}else {\n//\t\t\t\tdouble SalaryC = Math.ceil((Rs + (Rs * hra) + (Rs * da) + 1300) - (Rs * pf));\n//\t\t\t\tint totalSalaryC = (int) SalaryC;\n//\t\t\t\tSystem.out.println(totalSalaryC);\n//\t\t\t}\t\t\n//\t\t\n//\t}\n//\n//}\n"
        },
        {
          "fileName": "Compare_Capital_or_LowerCase.java",
          "code": "//package fundamentals;\n//import java.util.Scanner;\n//public class Compare_Capital_or_LowerCase {\n//\n//\tpublic static void main(String[] args) {\n//\t\t// TODO Auto-generated method stub\n//\t\t\n//\t\tScanner s = new Scanner(System.in);\n//\t\t\n//\t\tString str = s.next();\n//\t\tchar c = str.charAt(0);\n//\t\t\n//\t\tif (c >= 'A' && c <= 'Z') {\t\t\t\t\t// we are comparing the ASCII values\n//\t\t\tSystem.out.println(\"is Upper Case\");\t// ASCII \"a\" is larger than \"A\" ASCII value\n//\t\t} else if(c >= 'a' && c <= 'z') {\n//\t\t\tSystem.out.println(\"is lower case\");\n//\t\t} else {\n//\t\t\tSystem.out.println(\"Not a letter\");\n//\t\t}\n//\t}\n//\n//}\n"
        },
        {
          "fileName": "Conditionals.java",
          "code": "//package fundamentals;\n//import java.util.Scanner;\n//public class Conditionals {\n//\n//\tpublic static void main(String[] args) {\n//\t\t// TODO Auto-generated method stub\n//\t\tScanner s = new Scanner(System.in);\n//\t\tint a, b;\n//\t\t\n//\t\ta = s.nextInt();\n//\t\tb = s.nextInt();\n//\t\t\n//\t\tif(a > b) {\n//\t\t\tSystem.out.println(\"first num is greater\");\n//\t\t}else {\n//\t\t\tSystem.out.println(\"second num is greater\");\n//\t\t}\n//\t\n//\t\tSystem.out.println(\"outside of if/else\");\n//\t\t\n//\t}\n//\n//}\n"
        },
        {
          "fileName": "DataTypes.java",
          "code": "//package fundamentals;\n//\n//public class DataTypes {\n//\n//\tpublic static void main(String[] args) {\n//\t\t\n////\tint is 4 bytes;\n////\tint a = 10;\n//\n////\tshort s = 15;\n////\tbyte b = 11;\n//\t\n////\tlong is 8 bytes\n////\tlong l = 117;\n//\t\n////\tdouble is 8 bytes\n////\tdouble t = 3.2;\n////\tfloat is 4 bytes\n////\tfloat f = 3.2f;\n//\t\n////\tchar stores a character and must use single quotes\n////\ta string must use double quotes\n////\tchar ch = 'a';\n//\t\n////\tboolean b1 = true;\n//\t\n//\t\t\n//}\n//\t}\n"
        },
        {
          "fileName": "Even_Odd.java",
          "code": "//package fundamentals;\n//\n//import java.util.Scanner;\n//\n//public class Even_Odd {\n//\n//\tpublic static void main(String[] args) {\n//\t\t// TODO Auto-generated method stub\n//\t\tScanner s = new Scanner(System.in);\n//\t\tint a;\n//\t\t\n//\t\ta = s.nextInt();\n//\t\t\n////\t\tint rem = a % 2;\n//\t\t\n////\t\tboolean result = rem == 0;\n//\t\t\n//\t\tif(a % 2 == 0) {\n//\t\t\tSystem.out.println(a + \" is even\");\n//\t\t}else {\n//\t\t\tSystem.out.println(a + \" is odd\");\n//\t\t}// dont have to include else.\n//\t}\n//\n//}\n"
        },
        {
          "fileName": "Factors.java",
          "code": "//package fundamentals;\n//import java.util.Scanner;\n//public class Factors {\n//\n//\tpublic static void main(String[] args) {\n//\t\t// TODO Auto-generated method stub\n//\t\tScanner s = new Scanner(System.in);\n//\t\t\n//\t\tint n = s.nextInt();\n//\t\tint div = 2;\n//\t\t\n//\t\twhile(div < n) {\n//\t\t\tif(n % div == 0) {\n//\t\t\t\tSystem.out.print(div + \" \");\n//\t\t\t}div++;\n//\t\t}\n//\t\t\n//\t}\n//\n//}\n"
        },
        {
          "fileName": "HelloWorld.java",
          "code": "//package fundamentals;\n//\n//public class HelloWorld {\n//\t\n//\tpublic static void main(String[] args) {\n//\t\tSystem.out.print(\"Hello World\");\n//\t\tSystem.out.print(\"\\n\");\n//\t\tSystem.out.print(\"Hello World\");\n//\t\tSystem.out.println(\"Hello World\");\n////\t\tcmd / makes a line comment\n////\t\tSystem.out.print(\"Hello World\\n\");\n//\t\t\n//\t\t/*\n//\t\tPrintln prints a new line\n//\t\tSystem.out.println();\n//\t\t*/\n//\t}\n//\n//}\n//\n"
        },
        {
          "fileName": "MultiplicationTable.java",
          "code": "//package fundamentals;\n//import java.util.Scanner;\n//public class MultiplicationTable {\n//\n//\tpublic static void main(String[] args) {\n//\t\t// TODO Auto-generated method stub\n//\t\tScanner s = new Scanner(System.in);\n//\t\t\n//\t\tint n = s.nextInt();\n//\t\tint i = 1;\n//\t\twhile(i <= 10) {\n//\t\t\tSystem.out.println(i*n);\n//\t\t\ti++;\n//\t\t}\n//\t}\n//\n//}\n"
        },
        {
          "fileName": "MultiplyFloatingNums.java",
          "code": "//\n//\n//\n////Given two floating numbers, F1 and F2, \n////write a program to return the product of these floating numbers.\n////Give your answer to 6 decimal places\n//\n//\n//package fundamentals;\n//\n//public class MultiplyFloatingNums {\n//\n//\tpublic static double main(double f1, double f2) {\n//\t\t// TODO Auto-generated method stub\n//\t\t  double product = f1 * f2;\n//\t      return Math.round(product * 1e6)/1e6;\n//\t      \n//\t \n//\t}\n//\n//}\n//\n"
        },
        {
          "fileName": "PracticeTypeCast.java",
          "code": "//\n////Given a character, you need to return the ASCII value of that character.\n//\n//package fundamentals;\n//\n//public class PracticeTypeCast {\n//\n//\tpublic static int calculateASCII(char ch) {\n//\t    // Write your code here\n//\t    int ASC = (int) ch;\n//\t    return ASC;\n//\t}\n//}\n//\n//\n"
        },
        {
          "fileName": "RectangleArea.java",
          "code": "//package fundamentals;\n//\n//import java.util.Scanner;\n//\n//public class RectangleArea {\n//\n//\tpublic static void main(String[] args) {\n//\t\t/* Your class should be named Main.\n// \t\t\t* Read input as specified in the question.\n// \t\t\t* Print output as specified in the question.\n//\t\t*/\n//\n//\t\t// Write your code here\n//\t\tScanner s = new Scanner(System.in);\n//\t\tint x1 = s.nextInt();\n//\t\tint y1 = s.nextInt();\n//\t\tint x2 = s.nextInt();\n//\t\tint y2 = s.nextInt();\n//\n//\t\tint base = x2 - x1;\n//\t\tint height = y2 - y1;\n//\n//\t\tint area = base * height;\n//\t\tSystem.out.print(area);\n//\t}\n//\n//}"
        },
        {
          "fileName": "Relational_Operators.java",
          "code": "//package fundamentals;\n//\n//public class Relational_Operators {\n//\n//\tpublic static void main(String[] args) {\n//\t\t// TODO Auto-generated method stub\n//\t\tint a = 10, b = 20;\n//\t\tSystem.out.println(a < b);\n//\t\tSystem.out.println(a > b);\n//\t\tSystem.out.println(a != b);\n//\t\tSystem.out.println(a == b);\n//\t\tSystem.out.println(a <= b);\n//\t\tSystem.out.println(a >= b);\n//\t\t\n////\t\tAND = &&\n////\t\tOR = ||\n////\t\tNOT = !\n//\t\t\n//\t\tSystem.out.println(true && true);\n//\t\tSystem.out.println(true || false);\n//\t\tSystem.out.println(!true);\n//\t\tSystem.out.println(!(a > b));\n//\t\t\n//\t}\n//\n//}\n"
        },
        {
          "fileName": "ReturnStatment.java",
          "code": "//package fundamentals;\n//\n//import java.util.Scanner;\n//\n//public class ReturnStatment {\n//\n//\tpublic static void main(String[] args) {\n//\t\t// TODO Auto-generated method stub\n//\t\tScanner s = new Scanner(System.in);\n//\t\tint n = s.nextInt();\n//\n//\t\tint i = 2;\n////\t\tboolean isPrime = true;\n//\n//\t\twhile(i <= n-1) {\n//\t\t\tif(n % i == 0) {\n//\t\t\t\tSystem.out.println(\"not prime\");\n////\t\t\t\tisPrime = false;\n//\t\t\t\treturn;\t\t\t\t//return will exit the loop no other statement will execute\n//\t\t\t\t\n//\t\t\t}\n//\t\t\ti += 1;\n//\t\t}\n//\t\tSystem.out.println(\"is prime\");\n////\t\tif(isPrime) {\n////\t\t\tSystem.out.println(\"is prime\");\n////\t\t}else{\n////\t\t\tSystem.out.println(\"not prime\");\n////\t\t };\n//\n//\t}\n//\n//}\n"
        },
        {
          "fileName": "ScopeOfVariables.java",
          "code": "//package fundamentals;\n//\n//public class ScopeOfVariables {\n//\n//\tpublic static void main(String[] args) {\n//\t\t// TODO Auto-generated method stub\n//\t\t\n//\t\t\n//\t\tint a = 10;\t\t\t\t\t// variable a can be used anywhere after this line in Main\n//\t\t\n//\t\tif(a >= 100) {\n//\t\t\tint b = 10;\n//\t\t\tSystem.out.println(b);\n//\t\t\tSystem.out.println(a);\n//\t\t\t\n//\t\t}else {\n//\t\t\tint b = 20;\n//\t\t\tSystem.out.println(b); \t// you can re-assign b here because 'else' has different scope than 'if'. \n//\t\t\tint c = 20;\t\t\t\t// c only has scope within 'else'.\n//\t\t}\n////\t\tSystem.out.println(b);\t\t// cant print b here because its outside the scope of if statement\n//\t\t\n//\t\tint i = 1;\n//\t\twhile(i <=5) {\n//\t\t\tint j = 10;\n//\t\t\tSystem.out.println(j);\t\t// j will always be 10 because each time the loop goes around j will be reassigned to 10.\n//\t\t\ti++;\n//\t\t\tj++;\n//\t\t\t\n//\t\t}\n//\t}\n//\n//}\n"
        },
        {
          "fileName": "SimpleInterest.java",
          "code": "//public class Solution {\n    //public static double SimpleInterest(int p, int r, int t) {\n      /*\n       * Step 1: Store integer variables p,r and t in \"long\" data type\n       * Step 2: Calculate (P * R *T) and store in long data type e.g: long SI=(P * R *T)\n       * Step 3: Now calculate SI/100 and store the result in \"double\" data type\n       *         NOTE: To get the result with precision upto 2 decimal places. double data type can be used.\n       *\n       * Step 4: Return the result\n       */\n\n        // Write your code here\n//        \n\t\t/* this is wrong:\n\t\t \n\t\t  int p = p\n//        long R = r;\n//        long T = t;\n//\n//        long SI = (P*R*T);\n//        double solution = SI/100;\n//        return solution;\n//    \t*/\n//\t\tThis is correct:\n//    \tdouble floatP = p, floatR = r, floatT = t;\n//\t    double simpleInterest = floatP * floatR * floatT / (float)100;\n//\t    return simpleInterest;\n//}\n//    }\n"
        },
        {
          "fileName": "Solution.java",
          "code": "//package fundamentals;\n//\n//\n//\n//public class Solution {\n//\tpublic static void multipleOf5(int n) {\n//        // Write your code here\n//\n//       \n//\n//\t\tif ((n % 5) == 0){\t\t// Must wrap conditionals in parenthesis\n//            System.out.println(\"multiple of 5\");\n//        }else{\n//            System.out.println(\"Not a multiple of 5\");\n//        };\n//    }\n//}"
        },
        {
          "fileName": "SumOfEvenAndOdd.java",
          "code": "//package fundamentals;\n//import java.util.Scanner;\n//public class SumOfEvenAndOdd {\n//\n//\tpublic static void main(String[] args) {\n//\t\t// TODO Auto-generated method stub\n//\t\tScanner s = new Scanner(System.in);\n//\t\t\n//\t\t  int n = s.nextInt();\n//\t        \n//\t        int evenSum = 0;\n//\t        int oddSum = 0;\n//\t        while (n > 0) {\n//\t            int digit = n % 10;\t\t// modulo extracts the last digit off the input, because dividing it by 10 leaves a remainder\n//\t            if (digit % 2 == 0) {\n//\t                evenSum += digit;\n//\t            } else {\n//\t                oddSum += digit;\n//\t            }\n//\t            n /= 10;\t\t\t\t// because n is of type 'int' dividing it by 10 will cut off the decimal value remainder we targeted\n//\t        }  System.out.println(evenSum + \" \" + oddSum);\n//\t}\n//\n//}\n"
        },
        {
          "fileName": "TakeUserInput.java",
          "code": "//package fundamentals;\n//\n//import java.util.Scanner;\n//\n//public class TakeUserInput {\n//\n//\tpublic static void main(String[] args) {\n//\t\t// TODO Auto-generated method stub\n//\t\t\n//\t\tint a, b;\n//\t\t\n//\t\tScanner s = new Scanner(System.in);\n//\t\t a = s.nextInt(); \t// fetches the first number user entered\n//\t\t b = s.nextInt();\t// fetches the next number user entered\n//\t\tint c = a+b;\n//\t\tSystem.out.println(c);\n//\t\t\n//\t\t// take a double or long or String as input\n////\t\ts.nextDouble();\n////\t\ts.nextLong();\n//\t\t// take a word input\n//\t\t\n////\t\tTo get the string word by word\n//\t\tString str = s.next();\n//\t\tSystem.out.println(str);\n//\t\tSystem.out.println(str);\n//\t\t\n////\t\tTo get the entire line input\n//\t\tString str1 = s.nextLine();\n//\t\tSystem.out.println(str1);\n//\t\tSystem.out.println(str1);\n//\t\t\n////\t\tGet the first character of a string input\n//\t\tString str2 = s.next();\n//\t\tchar ch = str2.charAt(0);  // index of first character\n//\t\tSystem.out.println(ch);\n//\t\t\n//\t}\n//\n//}\n"
        },
        {
          "fileName": "TypeCasting.java",
          "code": "//package fundamentals;\n//\n//public class TypeCasting {\n//\n//\tpublic static void main(String[] args) {\n//\t\t// TODO Auto-generated method stub\n//\t\t\n////\t\tWe are converting a character to an integer;\n//\t\tchar ch = 'a';\t\t\t// char has size 2 bytes\n//\t\tint b = ch;\t\t\t\t// int holds 4 bytes, this is an implicit conversion\n//\t\tch = b;\t\t\t// Error: you can't store a type like long, in an int, because long is bigger. Unless you explicitly convert it\n//\t\tSystem.out.println(b);  // its OK to put a smaller 2 byte value into a larger 4byte space\n//\n//\t\t\n////\t\tExplicit typecast: to explicitly convert and force the conversion you may loose data;\n//\t\tch =(char)b;\t\t\t// this is explicit type conversion, warning: data loss may occur\n//\t\tint i = 10.6; \t\t\t// Error: any decimal number is a double and this wont work, unless you typecast it\n//\t\tint j = (int)10.6;\t\t// here we have typecasted j, and forced it to hold 10.6, warning: data loss can occur\n//\t\t\n////\t\tFloats: all decimal numbers by default are doubles, doubles are 8 bytes long, and floats are 4 bytes.\n//\t\tfloat f = 1.7;\t\t\t// Error: 1.7 is a 8 byte double and float is a 4byte type, can't do this unless you explicitly say\n////\t\t2 ways to declare 1.7 as a float:\n//\t\tfloat g = 1.7f;\n////\t\tor explicitly typecast it\n//\t\tfloat h = (float)1.7;\n////\t\tworking with differing types\n//\t\tSystem.out.println(4 + 4);\t\t\t// here, 2 ints will produce an int\n//\t\tSystem.out.println(4 + 4.5);\t\t// here, an int and a double will produce the larger data type: double\n//\t\tSystem.out.println(4.1 + 4.4);\t\t// here, two doubles will produce a double\n//\t\tSystem.out.println(2/5);\t\t\t// here, the result will be 0 unless its typecast into a double\n//\t\tSystem.out.println((double)2/5);\t// here, we typecast into a double to get output of a double = 0.4\n//\t\tSystem.out.println(2.0/5);\t\t\t// here, is another way to get the same result = 0.4\n//\t}\n//\n//}\n"
        },
        {
          "fileName": "WhileLoops.java",
          "code": "//package fundamentals;\n//import java.util.Scanner;\n//public class WhileLoops {\n//\n//\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n//\t    int x=5;\n//\t    int y=5;\n//\t    while((x=5)==y)\n//\t    {\n//\t        System.out.println(\"Hello\");\n//\t        x++;\n//\t        y++;\n//\t    }\n//\t\tScanner s = new Scanner(System.in);\n//\n//\t\tint S = s.nextInt();\n//\t\tint E = s.nextInt();\n//\t\tint W = s.nextInt();\n//\t\t\n//\t\twhile(S <= E){\t\t\t\t\t\t// celcius to farenheight\n//\t\t\tint C = (S - 32) * 5/9;\n//\t\t\tSystem.out.println(S + \" \" + C);\n//\t\t\tS += W;\t\t\t\n//\t\t}\n//\t}\n//\n//}\n"
        },
        {
          "fileName": "toThePowerOf.java",
          "code": "//\n//\n//package fundamentals;\n//import java.util.Scanner;\n//public class toThePowerOf {\n//\n//\tpublic static void main(String[] args) {\n//\t\t// TODO Auto-generated method stub\n//\t\tScanner s = new Scanner(System.in);\n//\t\t\n//\t\tint x = s.nextInt();\n//\t\tint n = s.nextInt();\n//\t\t\n//\t\tdouble y = Math.pow(x, n);\t\t// Math.pow() takes a double as input, so you may need to cast it back into an int.\n//\t\t\n//\t\tint z = (int) y;\t\t\t\t// casting back into an int.\n//\t\t\n//\t\tSystem.out.println(z);\n//\t}\n//\n//}\n"
        }
      ]
    },
    {
      "name": "generics",
      "files": [
        {
          "fileName": "Pair.java",
          "code": "package generics;\n\npublic class Pair <T> {\n\t\n\t// the variable type T is set as generic so any type can be passed to it\n\t\n\tprivate T first;\n\tprivate T second;\n\t\n\tpublic Pair(T first, T second) {\n\t\tthis.first = first;\n\t\tthis.second = second;\n\t}\n\tpublic T getFirst() {\n\t\treturn first;\n\t}\n\tpublic void setFirst(T first) {\n\t\tthis.first = first;\n\t}\n\tpublic T getSecond() {\n\t\treturn second;\n\t}\n\tpublic void setSecond(T second) {\n\t\tthis.second = second;\n\t}\n}\n"
        },
        {
          "fileName": "genericMethods.java",
          "code": "package generics;\n\npublic class genericMethods {\n\tpublic static <T> void printArray(T arr[]) {\n\t\t\n\t\tfor(int i = 0; i < arr.length; i ++) {\n\t\t\tSystem.out.println(arr[i]);\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n}\n"
        },
        {
          "fileName": "pairUse.java",
          "code": "package generics;\n\npublic class pairUse {\n\n\tpublic static void main(String[] args) {\n\t\t\n//\t\tPair p = new Pair(10, 20);\n//\t\tSystem.out.println(p.getFirst() + \" \" + p.getSecond());\n//\t\tPairString pS = new PairString(\"aa\", \"bb\");\n//\t\tPairDouble pS = new PairDouble(3.1, 7.2);\n\t\t// <String> will be replaced at all instances of T in the constructor\n\t\tPair<String> pS = new Pair<String>(\"aa\", \"bb\");\n\t\tSystem.out.println(pS.getFirst() + \" \" + pS.getSecond());\n\t\tpS.setFirst(\"10\");\n\t\t\n\t\t// cannot write primitive data types (char, double, int) must use Integer/Character/Double (wrapper class)\n\t\tPair<Integer> pI = new Pair<Integer>(10,20);\n\t\tSystem.out.println(pI.getFirst() + \" \" + pI.getSecond());\n\t\t\n\t\tPair<Double> pD = new Pair<Double>(10.1,20.2);\n\t\tSystem.out.println(pD.getFirst() + \" \" + pD.getSecond());\n\t\n\t\t// could make a pair of vehicle\n//\t\tPair<Vehicle> pV = new Pair<vehicle>(new Vehicle(), new Vehicle());\n\t\n\t\t// chained generic pairs\n\t\tPair<String, Integer> pInner = new Pair<String, Integer>();\n\t\tPair<Pair<String, Integer>, String> p = new Pair<>();\n\t\t\n\t\tp.setFirst(pInner);\n\t\tSystem.out.println(p.getFirst());\n\t\tp.getSecond(\"abcd\");\n\t\tSystem.out.println(p.getSecond());\n\t\t\n\t\n\t}\n\n}\n"
        },
        {
          "fileName": "sumUpNumsofList.java",
          "code": "package generics;\n\npublic class sumUpNumsofList {\n\t\n\tpublic static int cost(List <Integer> num) {\n\t    int sum = 0;\n\t    for (Integer number : num) {\n\t        sum += number;\n\t    }\n\t    return sum;\n\t}\n\t//  more modern and functional programming style, you can use Java's stream API to calculate the sum:\n\tpublic static int cost(List <Integer> num) {\n\t    return num.stream().mapToInt(Integer::intValue).sum();\n\t}\n\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n"
        }
      ]
    },
    {
      "name": "inheritance",
      "files": [
        {
          "fileName": "Vehicle.java",
          "code": "package inheritance;\n\npublic abstract class Vehicle {\n\t// the java Object class, is the super class of every class in java\n\t\n\t\n\t// we have moved the common properties from the child/sub-class into a parent/base-class Vehicle\n\tprivate String color;\t\t// this was made private, so setters and getters must be created because private variables are not inherited\n\tpublic int maxSpeed;\n\tprotected int minSpeed;\n\t\n\t// to avoid errors make a default vehicle constructor and an implicit vehicle constructor \n\t\n\tpublic Vehicle(int num) {\n\t\tthis.maxSpeed=num;\n\t\tSystem.out.println(\"Vehicles constructor\");\n\t}\n\t\n\tpublic String getColor() {\n\t\treturn color;\n\t}\n\t\n\tpublic void setColor(String color) {\n\t\tthis.color = color;\n\t}\n\t\n\tpublic void print() {\n\t\tSystem.out.println(\"Vehicle \" + \"color \"+ color+\" maxspeed \"+ maxSpeed);\n\t}\n\t\n\tpublic int getMaxSpeed() {\n\t\treturn maxSpeed;\n\t}\n\t\n\tpublic abstract boolean isMotorized();\n}\n"
        },
        {
          "fileName": "VehicleUse.java",
          "code": "package inheritance;\n\npublic class VehicleUse {\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tVehicle v = new Vehicle(30);\t\t// output is \"Vehicles constructor\"// requires maxSpeed argument\n\t\t\n\t\tv.setColor(\"red\");\n\t\tv.maxSpeed = 85;\n\t\tv.print();\n\t\t// car extends vehicle class, and the properties from vehicle will be available in car\n\t\tcar c = new car(4, 100);\t\t\t\t// output is \"vehicles constructor\" and \"cars constructor\", whenever you call constructor of child class, it calls constructor of super class\n\t\t\n\t\tc.setColor(\"Black\");\n\t\tc.maxSpeed = 100;\n\t\tc.numDoors = 4;\n\t\tc.print();\n//\t\tc.printCar();\n\t\t// bicycle extends vehicle class, and the properties from vehicle will be available in bicycle\n\t\tbicycle b = new bicycle();\n\t\t\n\t\tb.setColor(\"Green\");\n\t\tb.print();\n\n\t}\n\n}\n"
        },
        {
          "fileName": "bicycle.java",
          "code": "\n\npackage inheritance;\n// to indicate inheritance, use 'extends' keyword\npublic class bicycle extends Vehicle{\n\t\n\t\n}\n"
        },
        {
          "fileName": "car.java",
          "code": "\n\npackage inheritance;\n//to indicate inheritance, use 'extends' keyword\npublic class car extends Vehicle{\n\t\n\tint numDoors;\n\t\n\tint maxSpeed;\n\t\n\tpublic car(int numDoors, int maxSpeed) {   // compile error because superclass is called and the superclass constructor requires properties to be defined which are not being defined here\n//\t\tsuper(maxSpeed);\n\t\tSystem.out.println(\"cars constructor\");\n\t\tthis.numDoors = numDoors;\n\t}\n\t\n\tpublic void printCar() {\n\t\tSystem.out.println(\"car \" + \"color \"+ getColor() +\" maxspeed \"+ maxSpeed+ \" numDoors \" + numDoors);\n\t}\n\t\n\tpublic void print() {\n\t\tsuper.print();  // super refers to the parent class, and will cause the print function from parent to execute\n\t\tSystem.out.println(\"This is an example of function overriding, print() is defined in vehicle and car, but car.print() will override and run first if it exists in car\");\n\t}\n\t\n\tpublic void printMaxSpeed() {\n\t\tsuper.maxSpeed=150; //sets parent class maxSpeed\n\t\tSystem.out.println(maxSpeed);  // will print cars maxSpeed\n\t\tSystem.out.println(super.maxSpeed);  // will print parent class maxSpeed\n\t}\n\t\n\t@Override\n\tpublic boolean isMotorized() { // completes the incomplete method isMorotrized in abstract class Vehicle\n\t\treturn true;\n\t}\n\t\n\t\n}\n"
        }
      ]
    },
    {
      "name": "inheritance_2",
      "files": [
        {
          "fileName": "Truck.java",
          "code": "package inheritance_2;\nimport inheritance.Vehicle;\npublic class Truck extends Vehicle {\n\t\n\tint maxCapacity;\n\t\n\t\n\t// color and maxSpeed have default scope which is available only inside its package, so we need to use a getColor() which has public scope\n\tpublic void print() {\n\t\t// minSpeed is available here because Truck is a class derived from Vehicle class, and minSpeed has protected scope\n\t\tSystem.out.println(\"Vehicle \" + \"color \"+ getColor() +\" maxspeed \"+ maxSpeed + \" maxCapacity \" + maxCapacity + \" minSpeed \" + minSpeed);\n\t}\n\t\n\tpublic Truck(int maxCapacity, int maxSpeed) {\n\t\tsuper(maxSpeed);\n\t\tSystem.out.println(\"cars constructor\");\n\t\tthis.maxCapacity = maxCapacity;\n\t}\n}\n"
        },
        {
          "fileName": "Vehicle2Use.java",
          "code": "package inheritance_2;\n\nimport inheritance.Vehicle;\n\npublic class Vehicle2Use extends Vehicle {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tVehicle v = new Vehicle();\n\t\t\n\t\tv.maxSpeed = 10;\n\t\t\n\t\tv.minSpeed = 5;\t// cannot use minSpeed here because Vehicle2Use is not a derived class of Vehicle.\n\t}\n\n}\n// Solve:\n\n//package p1;\n//\n//public class Vehicle {\n//    protected String name;\n//}\n\n//Which of the following code(s) will give error?\n//A. \n//package p1;\n//\n//public class Car {\n//    void props() {\n//        Vehicle v = new Vehicle();\n//        v.name = \"Vehicle 1st\";      \n//    }\n//}\n//\n//B. \n//package p2;\n//\n//class Car{\n//    public static void main(String args[]) {\n//        Car c = new Car();\n//        c.name = \"Ferrari\";\n//    }\n//}\n//\n//C. \n//package p2;\n//\n//import p1.Vehicle;\n//class Car {\n//    void props() {\n//        Vehicle v = new Vehicle();\n//        v.name = \"BMW\";\n//    }\n//}\n//D. \n//package p2;\n//\n//class Car extends Vehicle {\n//    public static void main(String args[]) {\n//        Car c = new Car();\n//        c.name = \"Ferrari\";\n//    }\n//}\n\n//Solution Description\n//Option B defines a class Car in package p2 which cannot directly access the protected variable name from Vehicle since Car is not a subclass of Vehicle and is in a different package.\n//\n//\n//\n//\n//Option C defines a class Car in package p2 that imports the Vehicle class from package p1. \n//Since Car is not a subclass of Vehicle and is not in the same package as Vehicle, it cannot directly access the protected variable name. Therefore, option C will give an error."
        }
      ]
    },
    {
      "name": "interfaces",
      "files": [
        {
          "fileName": "vehicleInterface.java",
          "code": "package interfaces;\n\npublic interface vehicleInterface {\n\tdouble PI = 3.14;\n\tboolean isMotorized();\n\t String getCompany();\n}\n"
        }
      ]
    },
    {
      "name": "linkedLists",
      "files": [
        {
          "fileName": "BubbleSortLinkedList.java",
          "code": "package linkedLists;\n\npublic class BubbleSortLinkedList {\n\t\n\tpublic static int length(LinkedListNodeClass<Integer> head){\n        int len = 0;\n        LinkedListNodeClass<Integer> temp = head;\n        while(temp != null){\n            temp = temp.next;\n            len++;\n        }\n        return len;\n    }\n\n    public static LinkedListNodeClass<Integer> bubbleSort(LinkedListNodeClass<Integer> head) {\n        int n = length(head);\n        \n        for(int i = 0; i < n-1; i++){\n            LinkedListNodeClass<Integer> prev = null, curr = head;\n            for(int j = 0; j < n-i-1; j++){\n                if(curr.data <= curr.next.data){\n                    prev = curr;\n                    curr = curr.next;\n                } else {\n                    if(prev == null){\n                        LinkedListNodeClass<Integer> nextNode = curr.next;\n                        curr.next = nextNode.next;\n                        nextNode.next = curr;\n                        head = nextNode;\n                        prev = nextNode;\n                    } else {\n                        LinkedListNodeClass<Integer> nextNode = curr.next;\n                        prev.next = nextNode;\n                        curr.next = nextNode.next;\n                        nextNode.next = curr;\n                        prev = nextNode;\n                    }\n                }\n            }\n        }\n        return head;\n    }\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n"
        },
        {
          "fileName": "CircularDoublyLinkedList.java",
          "code": "package linkedLists;\n\npublic class CircularDoublyLinkedList {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n"
        },
        {
          "fileName": "EvenAfterOdd.java",
          "code": "package linkedLists;\n\npublic class EvenAfterOdd {\n\tpublic static LinkedListNodeClass<Integer> evenAfterOdd(LinkedListNodeClass<Integer> head) {\n\t\tif (head == null) \n\t\t\treturn head;\n\t\t\n\t\tLinkedListNodeClass<Integer> oddH = null, oddT = null, evenH = null, evenT = null;\n\t\tLinkedListNodeClass<Integer> current = head;\n\t\t\n\t\twhile(current != null) {\n\t\t\tint element = current.data;\n\t\t\t\n\t\t\tif(element % 2 != 0) {\n\t\t\t\tif(oddH == null) {\n\t\t\t\t\toddH = current;\n\t\t\t\t\toddT = current;\n\t\t\t\t} else {\n\t\t\t\t\toddT.next = current;\n\t\t\t\t\toddT = oddT.next;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif(evenH == null) {\n\t\t\t\t\tevenH = current;\n\t\t\t\t\tevenT = current;\n\t\t\t\t} else {\n\t\t\t\t\tevenT.next = current;\n\t\t\t\t\tevenT = evenT.next;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurrent = current.next;\n\t\t}\n\n\t\tif(oddH == null) {\n\t\t\treturn evenH;\n\t\t} else {\n\t\t\toddT.next = evenH;\n\t\t}\n\t\t\n\t\tif(evenH != null) {\n\t\t\tevenT.next = null;\n\t\t}\n\t\t\n\t\treturn oddH;\n\t}\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n"
        },
        {
          "fileName": "IncrementLargeNumber.java",
          "code": "package linkedLists;\n\n\npublic class IncrementLargeNumber {\n\t\n\tprivate static int addWithCarry(LinkedListNodeClass<Integer> node) {\n        // If this is the last node, then add 1 to it and return carry\n        if (node.next == null) {\n            node.data++;\n            int carry = node.data / 10;\n            node.data = node.data % 10;\n            return carry;\n        }\n\n        // Call addWithCarry for next node\n        int carry = addWithCarry(node.next);\n\n        // Add carry to this node, compute new carry\n        node.data += carry;\n        carry = node.data / 10;\n        node.data = node.data % 10;\n\n        // return carry to the previous node\n        return carry;\n    }\n\t\n\tpublic static LinkedListNodeClass<Integer> nextLargeNumber(LinkedListNodeClass<Integer> head) {\n        int carry = addWithCarry(head);\n\n        // If there is a carry left after adding to all nodes, we need to add a new node\n        // to the head of the linked list\n        if (carry > 0) {\n            LinkedListNodeClass<Integer> newNode = new LinkedListNodeClass<>(carry);\n            newNode.next = head;\n            head = newNode;\n        }\n\n        return head;\n    }\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\t\n\n\t}\n\n}\n"
        },
        {
          "fileName": "JavaLinkedListPackage.java",
          "code": " package linkedLists;\n // import java linked list class\nimport java.util.LinkedList;\n\npublic class JavaLinkedListPackage {\n\n\tpublic static void main(String[] args) {\n\t\t// creates a doubly linked list\n\t\tLinkedList<Integer> list = new LinkedList<>();\n\t\t// add to the linked list\n\t\tlist.add(10);\n\t\tlist.add(20);\n\t\tlist.add(30);\n\t\t// list = 10 -> 20 -> 30\n\t\tlist.add(1,100); // add 100 at index 1\n//\t\tnow list = 10 -> 100 -> 20 -> 30\n\t\tSystem.out.println(list.get(1)); // get value at an index\n\t\tlist.addFirst(80);\n\t\tSystem.out.println(list.size());\n\t\tlist.set(0, 60); // sets the value at index 0 to 60\n\t\tlist.remove(); //removes the first element of the list\n\t\tfor(int i = 0; i < list.size(); i++) {\n\t\t\tSystem.out.println(list.get(i));\n\t\t}\n\t\t\n\t}\n\n}\n"
        },
        {
          "fileName": "Kreverse.java",
          "code": "package linkedLists;\n//Given this linked list: 1 -> 2 -> 3 -> 4 -> 5\n//\n//For k = 2, you should return: 2 -> 1 -> 4 -> 3 -> 5\n//\n//For k = 3, you should return: 3 -> 2 -> 1 -> 5 -> 4\npublic class Kreverse {\n\tpublic static LinkedListNodeClass<Integer> kReverse(LinkedListNodeClass<Integer> head, int k) {\n        LinkedListNodeClass<Integer> current = head;\n        LinkedListNodeClass<Integer> next = null;\n        LinkedListNodeClass<Integer> prev = null;\n        int count = 0;\n\n        /* reverse first k nodes of the linked list */\n        while (count < k && current != null) {\n            next = current.next;\n            current.next = prev;\n            prev = current;\n            current = next;\n            count++;\n        }\n\n        /* next is now a pointer to (k+1)th node. \n           recursively call for the list starting from current. \n           and make rest of the list as next of first node */\n        if (next != null) {\n            head.next = kReverse(next, k);\n        }\n\n        /* prev is new head of the input list */\n        return prev;\n    }\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n"
        },
        {
          "fileName": "LinkedListNodeClass.java",
          "code": "package linkedLists;\n\n\n// linked list nodes store data, and the address of the next node that its attached too.\npublic class LinkedListNodeClass <T>{\n\t\tpublic T data;\n\t\tpublic LinkedListNodeClass <T> next;\t\t// makes a pointer to the next node\n\t\t\n\t\tpublic LinkedListNodeClass(T data){\t\t\n\t\t\tthis.data = data;\n\t\t}\n\t\t\n}\n"
        },
        {
          "fileName": "LinkedListUse.java",
          "code": "package linkedLists;\n\nimport java.util.Scanner;\n\npublic class LinkedListUse {\n\n\t//-----------------------------------------------------------------------------\n\tpublic static LinkedListNodeClass<Integer> createLinkedList() {\n\t\tLinkedListNodeClass <Integer> n1 = new LinkedListNodeClass<>(10);\t// creates a new node with data = 10 and next references the next nodes memory address\n\t\tLinkedListNodeClass <Integer> n2 = new LinkedListNodeClass<>(20);\n\t\tLinkedListNodeClass<Integer> n3 = new LinkedListNodeClass<>(30);\n\t\tLinkedListNodeClass<Integer> n4 = new LinkedListNodeClass<>(40);\n\t\t\n\t\tn1.next = n2;\t\t\t// points n1 to n2's address\n\t\tn2.next = n3;\n\t\tn3.next = n4;\n\t\t\n\t\tSystem.out.println(\"n1 \" + n1 + \" data \" + n1.data + \" next \" + n1.next);\n\t\tSystem.out.println(\"n2 \" + n2 + \" data \" + n2.data + \" next \" + n2.next);\n\t\tSystem.out.println(\"n3 \" + n3 + \" data \" + n3.data + \" next \" + n3.next);\n\t\tSystem.out.println(\"n1 \" + n4 + \" data \" + n4.data + \" next \" + n4.next);\n\t\t\n\t\t\n\t\treturn n1;\t\t// should return the first nodes reference\n\t}\n\t//-----------------------------------------------------------------------------\n\tpublic static void print(LinkedListNodeClass <Integer> head) {\n\t\tSystem.out.println(\"Print \" + head);\n\t\t\n\t\twhile(head != null) {\n\t\t\tSystem.out.println(head.data);\n\t\t\thead = head.next;\t// will set head to the address of the next node\n\t\t}\n\t}\n\t//-----------------------------------------------------------------------------\n\tpublic static void increment(LinkedListNodeClass<Integer> head) {\n\t\tLinkedListNodeClass<Integer> temp = head;\n\t\t\n\t\twhile( temp != null ) {\n\t\t\ttemp.data++;\n\t\t\ttemp=temp.next;\n\t\t}\n\t\t\n\t\t//head.data++; // increments the head\n\t}\n\t//-----------------------------------------------------------------------------\n\tpublic static LinkedListNodeClass<Integer> takeInput(){\n\t\tScanner s = new Scanner(System.in);\n\t\t// keep taking user input until user inputs -1\n\t\tint data = s.nextInt();\n\t\t// return the head\n\t\tLinkedListNodeClass<Integer> head = null;\n\t\twhile(data != -1) {\n\t\t\tLinkedListNodeClass<Integer> currentNode = new LinkedListNodeClass<Integer>(data);\n\t\t\t// check if head is null to assign head node\n\t\t\tif(head == null) {\n\t\t\t\thead = currentNode;\n\t\t\t}else {\n\t\t\t\t// create the connection to the next node\n\t\t\t\tLinkedListNodeClass<Integer> tail = head;\n\t\t\t\twhile(tail.next != null) {\n\t\t\t\t\ttail = tail.next;\n\t\t\t\t}\n\t\t\t\t// tail will reference last node\n\t\t\t\t// connect current node after last node\n\t\t\t\ttail.next = currentNode;\n\t\t\t}\n\t\t\tdata = s.nextInt();\n\t\t}\n\t\treturn head;\n\t}\n\t//-----------------------------------------------------------------------------\n\t\t// prints the linked list recursively\n\t\tpublic static void printRecursive(LinkedListNodeClass<Integer> head) {\n\t\t\t// base case\n\t\t\tif(head == null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSystem.out.println(head.data + \" \");\n\t\t\t\n\t\t\tprintRecursive(head.next);\n\t\t}\n\t\t//-----------------------------------------------------------------------------\n\t\t// Recursively insert a node at a specified position\n\t\tpublic static LinkedListNodeClass<Integer> insertNodeRecursivley(LinkedListNodeClass<Integer> head, int elem, int pos){\n\t\t\t// insert a node recursively\n\t\t\t// allows for entering a node at the 0th position if the list is empty\n\t\t\tif(head == null && pos > 0) {\n\t\t\t\treturn head;\n\t\t\t}\n\t\t\t// base case\n\t\t\tif(pos == 0) {\n\t\t\t\t// make a new node containing the element to insert\n\t\t\t\tLinkedListNodeClass<Integer> newNode = new LinkedListNodeClass<>(elem);\n\t\t\t\tnewNode.next = head;\n\t\t\t\treturn newNode;\n\t\t\t}else {\n\t\t\t\tLinkedListNodeClass<Integer> smallerHead = insertNodeRecursivley(head.next,elem, pos - 1);\n\t\t\t\thead.next = smallerHead;\n\t\t\t\treturn head;\n\t\t\t}\n\t\t}\n\t\t//-----------------------------------------------------------------------------\n\t\tpublic static LinkedListNodeClass<Integer> deleteNodeRecursively(LinkedListNodeClass<Integer> head, int pos){\n\t\t    // Base case: if the head is null or if the position is outside the list\n\t\t    if (head == null || pos < 0) {\n\t\t        return head;\n\t\t    }\n\n\t\t    // If the position is at the head of the list\n\t\t    if (pos == 0) {\n\t\t        return head.next;\n\t\t    }\n\n\t\t    // Recursive case: move down the list\n\t\t    head.next = deleteNodeRecursively(head.next, pos - 1);\n\t\t    \n\t\t    return head;\n\t\t}\n\t\t//-----------------------------------------------------------------------------\n\t\tpublic static LinkedListNodeClass<Integer> reverseLinkedListRecursivley(LinkedListNodeClass<Integer> head){\n\t\t    // Base case: if head is null or there's only one node, just return the head\n\t\t    if (head == null || head.next == null) {\n\t\t        return head;\n\t\t    }\n\n\t\t    // Recursive case: reverse the rest of the list\n\t\t    LinkedListNodeClass<Integer> reversedRest = reverseLinkedListRecursivley(head.next);\n\n\t\t    // Re-hook up the current node, so that our next node points to the current node\n\t\t    head.next.next = head;\n\n\t\t    // Make sure to null out the link to the next node, since it already points to us\n\t\t    head.next = null;\n\n\t\t    // Return the head of the new reversed list (which is the last node in the original list)\n\t\t    return reversedRest;\n\t\t}\n\t\t//-----------------------------------------------------------------------------\n\t\tpublic static LinkedListNodeClass<Integer> reverseLinkedListIteratively(LinkedListNodeClass<Integer> head) {\n\t\t    LinkedListNodeClass<Integer> current = head;\n\t\t    LinkedListNodeClass<Integer> previous = null;\n\t\t    LinkedListNodeClass<Integer> nextNode;\n\n\t\t    while (current != null) {\n\t\t        // Store the next node\n\t\t        nextNode = current.next;\n\n\t\t        // Change the next of current\n\t\t        // This is where actual reversing happens\n\t\t        current.next = previous;\n\n\t\t        // Move previous and current one step forward\n\t\t        previous = current;\n\t\t        current = nextNode;\n\t\t    }\n\n\t\t    // Returning the new head of the reversed list (which is the last node in the original list)\n\t\t    return previous;\n\t\t}\n\t\t//-----------------------------------------------------------------------------\n\t\tpublic static LinkedListNodeClass<Integer> findMiddleWithoutCalculatingLength(LinkedListNodeClass<Integer> head){\n\t\t\tLinkedListNodeClass<Integer> fast = head;\n\t\t\tLinkedListNodeClass<Integer> slow = head;\n\t\t\twhile(fast != null && fast.next != null && fast.next.next != null) {\n\t\t\t\tslow = slow.next;\n\t\t\t\tfast = fast.next.next;\n\t\t\t}\n\t\t\treturn slow;\n\t\t}\n\t\t//-----------------------------------------------------------------------------\n\t\tpublic static LinkedListNodeClass<Integer> merge2linkedLists(LinkedListNodeClass<Integer> head1, LinkedListNodeClass<Integer> head2){\n\t\t\tif(head1 == null) {\n\t\t\t\treturn head2;\n\t\t\t}\n\t\t\tif(head2 == null) {\n\t\t\t\treturn head1;\n\t\t\t}\n\t\t\tLinkedListNodeClass<Integer> head = null, tail = null;\n\t\t\t\n\t\t\twhile(head1 != null && head2 != null) {\n\t\t\t\tLinkedListNodeClass<Integer> newNode = null;\n\t\t\t\tif(head1.data < head2.data) {\n\t\t\t\t\tnewNode = new LinkedListNodeClass<>(head1.data);\n\t\t\t\t\thead1 = head1.next;\n\t\t\t\t}else {\n\t\t\t\t\tnewNode = new LinkedListNodeClass<>(head2.data);\n\t\t\t\t\thead2 = head2.next;\n\t\t\t\t}\n\t\t\t\tif(head == null) {\n\t\t\t\t\thead = newNode;\n\t\t\t\t\ttail = newNode;\n\t\t\t\t}else {\n\t\t\t\t\ttail.next = newNode;\n\t\t\t\t\ttail = newNode;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Append remaining nodes of either list\n\t\t    if(head1 != null) {\n\t\t        tail.next = head1;\n\t\t    } else {\n\t\t        tail.next = head2;\n\t\t    }\n\n\t\t    return head;\n\t\t}\n\t\t//-----------------------------------------------------------------------------\n\t\tpublic static LinkedListNodeClass<Integer> midPoint(LinkedListNodeClass<Integer> head) {\n\t        //Your code goes here\n\t        \tLinkedListNodeClass<Integer> fast = head;\n\t\t\t\tLinkedListNodeClass<Integer> slow = head;\n\t\t\t\twhile(fast != null && fast.next != null && fast.next.next != null) {\n\t\t\t\t\tslow = slow.next;\n\t\t\t\t\tfast = fast.next.next;\n\t\t\t\t}\n\t\t\t\treturn slow;\n\t    }\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tLinkedListNodeClass<Integer> head = createLinkedList();\n\t\t\n\t\tincrement(head);\n\t\t\n\t\tLinkedListNodeClass<Integer> n1 = new LinkedListNodeClass<>(10);  \n\t\tSystem.out.println(head.data); // prints the first node\n\t\tSystem.out.println(head.next);\t// starts by printing the 2nd node\n\t\t\n\t\t\n\t\t//// count the length of a linked list\n//\t      if (head == null) {\n//\t            return 0;  // Handle the case when the head is null\n//\t        }\n//\n//\t        int count = 0;\n//\t        Node current = head;\n//\n//\t        while (current != null) {\n//\t            count++;\n//\t            current = current.next;\n//\t        }\n//\n//\t        System.out.println();\n\n\t}\n\n}\n"
        },
        {
          "fileName": "appendLastNnodesToFrontOfLinkedList.java",
          "code": "package linkedLists;\n\npublic class appendLastNnodesToFrontOfLinkedList {\n\t\n\tpublic static LinkedListNodeClass<Integer> appendLastNToFirst(LinkedListNodeClass<Integer> head, int n) {\n\t\t//Your code goes here\n\t\tif(head == null || n <= 0) {\n            return head;\n        }\n\n        // calculate the length of the list\n        LinkedListNodeClass<Integer> temp = head;\n        int length = 0;\n        while(temp != null) {\n            temp = temp.next;\n            length++;\n        }\n\n        // if n is greater than the length of the list, reduce n\n        n = n % length;\n        if(n == 0) {\n            return head;\n        }\n\n        // find the new split point\n        int splitPoint = length - n;\n\n        temp = head;\n        int count = 1;\n\n        // traverse the list to the split point\n        while(count < splitPoint && temp != null) {\n            temp = temp.next;\n            count++;\n        }\n\n        // if we found a valid split point\n        if(temp != null) {\n            LinkedListNodeClass<Integer> newHead = temp.next; // the new head is the next node\n            temp.next = null; // disconnect the old list after the split point\n\n            // find the last node in the list\n            temp = newHead;\n            while(temp.next != null) {\n                temp = temp.next;\n            }\n\n            // connect the last node to the old head\n            temp.next = head;\n            head = newHead; // the new head of the list\n        }\n\n        return head;\n\t}\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n"
        },
        {
          "fileName": "circularLinkedList.java",
          "code": "package linkedLists;\n\npublic class circularLinkedList {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\t\n\t}\n\n}\n"
        },
        {
          "fileName": "deleteAlternateNodes.java",
          "code": "package linkedLists;\n\npublic class deleteAlternateNodes {\n\t\n\tpublic static void deleteAlternateNodes(LinkedListNodeClass<Integer> head) {\n        // Checking if the list is empty or only contains a single node\n        if (head == null || head.next == null) {\n            return;\n        }\n        LinkedListNodeClass<Integer> current = head;\n        while (current != null && current.next != null) {\n            // Skip the next node\n            current.next = current.next.next;\n            // Move to the next node\n            current = current.next;\n        }\n    }\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n"
        },
        {
          "fileName": "deleteEveryN_Nodes.java",
          "code": "package linkedLists;\n\npublic class deleteEveryN_Nodes {\n\tpublic static LinkedListNodeClass<Integer> skipMdeleteN(LinkedListNodeClass<Integer> head, int M, int N) {\n\t\tif (M == 0) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tif (head == null || N < 0 || M < 0) {\n\t\t\treturn head;\n\t\t}\n\t\t\n\t\tLinkedListNodeClass<Integer> current = head, temp = null;\n\t\tint i;\n\t\t\n\t\twhile (current != null) {\n\t\t\t// skip (M - 1) nodes\n\t\t\tfor (i = 1; current != null && i < M; i++) {\n\t\t\t\tcurrent = current.next;\n\t\t\t}\n\t\t\t\n\t\t\t// check if we reached end of list\n\t\t\tif (current == null) {\n\t\t\t\treturn head;\n\t\t\t}\n\t\t\t\n\t\t\t// start from next node and delete N nodes\n\t\t\ttemp = current.next;\n\t\t\tfor (i = 1; temp != null && i <= N; i++) {\n\t\t\t\tLinkedListNodeClass<Integer> next = temp.next;\n\t\t\t\ttemp = next;\n\t\t\t}\n\t\t\t\n\t\t\t// link the previous list with remaining nodes\n\t\t\tcurrent.next = temp;\n\t\t\tcurrent = temp;\n\t\t}\n\t\t\n\t\treturn head;\n\t}\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n"
        },
        {
          "fileName": "deleteNode.java",
          "code": "package linkedLists;\n\npublic class deleteNode {\n\n\tpublic static LinkedListNodeClass<Integer> deleteNode(LinkedListNodeClass<Integer> head, int pos) {\n\t\t// Write your code here.\n\t\tif(pos == 0){\n\t\t\t// delete node head\n\t\t\tif(head != null){\n\t\t\t\thead = head.next;\n\t\t\t}\n\t\t\treturn head;\n\t\t}\n\t\tLinkedListNodeClass<Integer> temp = head;\n\t\tint count = 0;\n\n\t\t// find the node preceding the one we want to delete\n\t\twhile (temp != null && count < pos - 1){\n\t\t\ttemp = temp.next;\n\t\t\tcount++;\n\t\t}\n\t\t\t// If we've found such a node and it's not the last one\n\t\tif (temp != null && temp.next != null) {\n\t\t\t// Bypass the node we want to delete\n\t\t\ttemp.next = temp.next.next;\n\t\t}\n\t\t\n\t\treturn head;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\t\n\t}\n\n}\n"
        },
        {
          "fileName": "doublyLinkedLIst.java",
          "code": "package linkedLists;\n\npublic class doublyLinkedLIst {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n"
        },
        {
          "fileName": "eliminateDuplicates.java",
          "code": "package linkedLists;\n\npublic class eliminateDuplicates {\n\t\n\tpublic static LinkedListNodeClass<Integer> removeDuplicates(LinkedListNodeClass<Integer> head) {\n\t\t//Your code goes here\n\t\tif(head == null || head.next == null) {\n            return head;  // If head is null or there is only one node, return head.\n        }\n\n        LinkedListNodeClass<Integer> current = head;\n        while(current.next != null) {\n            if(current.data.equals(current.next.data)) {\n                current.next = current.next.next;  // If current node and next node have the same data, skip next node.\n            } else {\n                current = current.next;  // If current node and next node have different data, move to next node.\n            }\n        }\n        return head;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n"
        },
        {
          "fileName": "findNodeInLinkedList.java",
          "code": "package linkedLists;\n\npublic class findNodeInLinkedList {\n\n\tpublic static int findNode(LinkedListNodeClass<Integer> head, int n) {\n\t\t// Write your code here.\n\t\tLinkedListNodeClass<Integer> temp = head;\n\t\tint index = 0;\n\t\twhile(temp != null){\n\t\t\tif(temp.data == n){\n\t\t\t\t// If the data is found, return the current index\n\t\t\t\treturn index;\n\t\t\t}else{\n\t\t\t\tindex++;\n\t\t\t\ttemp = temp.next;\n\t\t\t}\n\t\t}\n\t\t// If the loop completes without finding the data, return -1\n\t\treturn -1;\n\t}\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n"
        },
        {
          "fileName": "findNodeRecursivley.java",
          "code": "package linkedLists;\n\npublic class findNodeRecursivley {\n\t\n\tpublic static int findNodeRec(LinkedListNodeClass<Integer> head, int n) {\n    \tif(head == null) {   // If head is null (base case)\n        \treturn -1;\n    \t}\n    \tif(head.data.equals(n)) {  // If the data of the head is 'n'\n        \treturn 0;\n    \t} else {\n        \tint smallAns = findNodeRec(head.next, n); // Recursive call\n        \tif(smallAns == -1){ // If 'n' is not found in the rest of the list\n            \treturn -1;\n        \t} else {\n            \treturn smallAns + 1;  // If 'n' is found, increment the index by 1\n        \t}\n    \t}\n\t}\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n"
        },
        {
          "fileName": "insertNodeIntoLinkedList.java",
          "code": "package linkedLists;\n\nimport java.util.Scanner;\n\npublic class insertNodeIntoLinkedList {\n\n\tpublic static void print(LinkedListNodeClass <Integer> head) {\n\t\tSystem.out.println(\"Print \" + head);\n\t\t\n\t\twhile(head != null) {\n\t\t\tSystem.out.println(head.data);\n\t\t\thead = head.next;\t// will set head to the address of the next node\n\t\t}\n\t}\n\t\n\tpublic static LinkedListNodeClass<Integer> takeInput(){\n\t\tScanner s = new Scanner(System.in);\n\t\t// keep taking user input until user inputs -1\n\t\tint data = s.nextInt();\n\t\t// return the head\n\t\tLinkedListNodeClass<Integer> head = null;\n\t\twhile(data != -1) {\n\t\t\tLinkedListNodeClass<Integer> currentNode = new LinkedListNodeClass<Integer>(data);\n\t\t\t// check if head is null to assign head node\n\t\t\tif(head == null) {\n\t\t\t\thead = currentNode;\n\t\t\t}else {\n\t\t\t\t// create the connection to the next node\n\t\t\t\tLinkedListNodeClass<Integer> tail = head;\n\t\t\t\twhile(tail.next != null) {\n\t\t\t\t\ttail = tail.next;\n\t\t\t\t}\n\t\t\t\t// tail will reference last node\n\t\t\t\t// connect current node after last node\n\t\t\t\ttail.next = currentNode;\n\t\t\t}\n\t\t\tdata = s.nextInt();\n\t\t}\n\t\treturn head;\n\t}\n\t\n\t\n\tpublic static LinkedListNodeClass<Integer> insert(LinkedListNodeClass<Integer> head, int elem, int pos) {\n//\t\t2 -> 8 -> 10 -> 15 -> 25\n\t\t// insert 20 at position 3\n\t\t// if you have to insert at position i, you must have the reference to position i-1\n\t\t// travel to i-1 node\n\t\t// make connection to i'th node before connecting i-1 node\n\t\tLinkedListNodeClass<Integer> newNode = new LinkedListNodeClass<Integer>(elem);\n\t\t\n\t\t\n\t\t// handle 0th position\n\t\tif (pos == 0) {\n\t\t\tnewNode.next = head;\n\t\t\treturn newNode;\t\t// whenever there's a change in the head you need to return it so main gets it\n\t\t}\n\t\tint count = 0;\n\t\t// reference to node at previous position\n\t\tLinkedListNodeClass<Integer> prev = head;\n\t\twhile(count < pos - 1) {\n\t\t\tcount++;\n\t\t\tprev = prev.next;\n\t\t}\n\t\tif(prev != null) {\n\t\t\t// points to the new node\n\t\t\t// make connection before breaking the i-1 nodes connection\n\t\t\tnewNode.next = prev.next;\n\t\t\tprev.next = newNode;\n\t\t}\n\t\treturn head;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tLinkedListNodeClass<Integer> head = takeInput();\n\t\thead = insert(head, 80, 2);\n\t\tprint(head);\n\t}\n\n}\n"
        },
        {
          "fileName": "mergeSortLinkedList.java",
          "code": "package linkedLists;\n\nimport java.util.Scanner;\n\npublic class mergeSortLinkedList {\n\t\n\tpublic static LinkedListNodeClass<Integer> takeInput(){\n\t\tScanner s = new Scanner(System.in);\n\t\t// keep taking user input until user inputs -1\n\t\tint data = s.nextInt();\n\t\t// return the head\n\t\tLinkedListNodeClass<Integer> head = null;\n\t\twhile(data != -1) {\n\t\t\tLinkedListNodeClass<Integer> currentNode = new LinkedListNodeClass<Integer>(data);\n\t\t\t// check if head is null to assign head node\n\t\t\tif(head == null) {\n\t\t\t\thead = currentNode;\n\t\t\t}else {\n\t\t\t\t// create the connection to the next node\n\t\t\t\tLinkedListNodeClass<Integer> tail = head;\n\t\t\t\twhile(tail.next != null) {\n\t\t\t\t\ttail = tail.next;\n\t\t\t\t}\n\t\t\t\t// tail will reference last node\n\t\t\t\t// connect current node after last node\n\t\t\t\ttail.next = currentNode;\n\t\t\t}\n\t\t\tdata = s.nextInt();\n\t\t}\n\t\treturn head;\n\t}\n\t// ------------------------------------------------------------------------\n\tpublic static LinkedListNodeClass<Integer> mergeSort(LinkedListNodeClass<Integer> head){\n\t\tif(head == null || head.next == null) {\n\t\t\treturn head;\n\t\t}\n\t\t// get the middle point\n\t\tLinkedListNodeClass<Integer> middle = midPoint(head);\n\t\t// split the list into 2 part (break the middle connection point it toward null)\n\t\tLinkedListNodeClass<Integer> part1Head = head;\n\t\tLinkedListNodeClass<Integer> part2Head = middle.next;\n\t\tmiddle.next = null;\n\t\t// recursive call on each new half of the unsorted linked list\n\t\tLinkedListNodeClass<Integer> smallHead = mergeSort(part1Head);\n\t\tLinkedListNodeClass<Integer> smallHead2 = mergeSort(part2Head);\n\t\t// send to the merge function to merge them back together\n\t\tLinkedListNodeClass<Integer> finalList = merge2linkedLists(smallHead, smallHead2);\n\t\treturn finalList;\n\t}\n\t// -----------------------------------------------------------------------\n\tpublic static LinkedListNodeClass<Integer> midPoint(LinkedListNodeClass<Integer> head) {\n\t\t//Your code goes here\n\t\tLinkedListNodeClass<Integer> fast = head;\n\t\tLinkedListNodeClass<Integer> slow = head;\n\t\twhile(fast != null && fast.next != null && fast.next.next != null) {\n\t\t\tslow = slow.next;\n\t\t\tfast = fast.next.next;\n\t\t}\n\t\treturn slow;\n\t}\n\t// -------------------------------------------------------------------------\n\tpublic static LinkedListNodeClass<Integer> merge2linkedLists(LinkedListNodeClass<Integer> head1, LinkedListNodeClass<Integer> head2){\n\t\tif(head1 == null) {\n\t\t\treturn head2;\n\t\t}\n\t\tif(head2 == null) {\n\t\t\treturn head1;\n\t\t}\n\t\tLinkedListNodeClass<Integer> head = null, tail = null;\n\t\t\n\t\twhile(head1 != null && head2 != null) {\n\t\t\tLinkedListNodeClass<Integer> newNode = null;\n\t\t\tif(head1.data < head2.data) {\n\t\t\t\tnewNode = new LinkedListNodeClass<>(head1.data);\n\t\t\t\thead1 = head1.next;\n\t\t\t}else {\n\t\t\t\tnewNode = new LinkedListNodeClass<>(head2.data);\n\t\t\t\thead2 = head2.next;\n\t\t\t}\n\t\t\tif(head == null) {\n\t\t\t\thead = newNode;\n\t\t\t\ttail = newNode;\n\t\t\t}else {\n\t\t\t\ttail.next = newNode;\n\t\t\t\ttail = newNode;\n\t\t\t}\n\t\t}\n\t\t// Append remaining nodes of either list\n\t    if(head1 != null) {\n\t        tail.next = head1;\n\t    } else {\n\t        tail.next = head2;\n\t    }\n\n\t    return head;\n\t}\n\t// ---------------------------------------------------------------------\n\tpublic static void print(LinkedListNodeClass <Integer> head) {\n\t\tSystem.out.println(\"Print \" + head);\n\t\t\n\t\twhile(head != null) {\n\t\t\tSystem.out.println(head.data);\n\t\t\thead = head.next;\t// will set head to the address of the next node\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tLinkedListNodeClass<Integer>head = takeInput();\n\t\thead = mergeSort(head);\n\t\tprint(head);\n\t}\n\n}\n"
        },
        {
          "fileName": "printReversedLinkedList.java",
          "code": "package linkedLists;\n\npublic class printReversedLinkedList {\n\tpublic static void printReverse(LinkedListNodeClass<Integer> root) {\n\t\t//Your code goes here\n\t\t if (root == null) {\n            return;  // Base case of recursion: if the list is empty, do nothing.\n        }\n        \n        printReverse(root.next);  // Recursive call: print the rest of the list.\n\n        System.out.print(root.data + \" \");  // Print the current node after the rest of the list has been printed.\n\t}\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n"
        },
        {
          "fileName": "print_ith_node.java",
          "code": "package linkedLists;\n\npublic class print_ith_node  {\n\n\tpublic static void ithNode(LinkedListNodeClass<Integer> head, int i) {\n\tLinkedListNodeClass<Integer> temp = head;\n    int count = 0;\n    while(temp != null){\n    \tif(count == i){\n    \t\tSystem.out.println(temp.data);\n    \t\treturn;\n    \t}else{\n    \t\tcount++;\n    \t\ttemp = temp.next;\n    \t}\n    }\n\t}\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n"
        },
        {
          "fileName": "swap2Nodes.java",
          "code": "package linkedLists;\n\npublic class swap2Nodes {\n\tpublic static LinkedListNodeClass<Integer> swapNodes(LinkedListNodeClass<Integer> head, int i, int j) {\n\t\t// Nothing to do if i and j are the same\n\t\tif (i == j) {\n\t\t\treturn head;\n\t\t}\n\n\t\t// Search for i-th node\n\t\tint count = 0;\n\t\tLinkedListNodeClass<Integer> prevX = null, currX = head;\n\t\twhile (currX != null && count < i) {\n\t\t\tprevX = currX;\n\t\t\tcurrX = currX.next;\n\t\t\tcount++;\n\t\t}\n\n\t\t// Search for j-th node\n\t\tcount = 0;\n\t\tLinkedListNodeClass<Integer> prevY = null, currY = head;\n\t\twhile (currY != null && count < j) {\n\t\t\tprevY = currY;\n\t\t\tcurrY = currY.next;\n\t\t\tcount++;\n\t\t}\n\n\t\t// If either i or j is out of bounds, no swapping\n\t\tif (currX == null || currY == null) {\n\t\t\treturn head;\n\t\t}\n\n\t\t// If x is not head of linked list\n\t\tif (prevX != null) {\n\t\t\tprevX.next = currY;\n\t\t} else {\n\t\t\thead = currY;\n\t\t}\n\n\t\t// If y is not head of linked list\n\t\tif (prevY != null) {\n\t\t\tprevY.next = currX;\n\t\t} else {\n\t\t\thead = currX;\n\t\t}\n\n\t\t// Swap next pointers\n\t\tLinkedListNodeClass<Integer> temp = currX.next;\n\t\tcurrX.next = currY.next;\n\t\tcurrY.next = temp;\n\n\t\treturn head;\n\t}\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n"
        },
        {
          "fileName": "userInputLinkedList.java",
          "code": "package linkedLists;\nimport java.util.Scanner;\npublic class userInputLinkedList {\n\t\n\tpublic static LinkedListNodeClass<Integer> takeInput(){\n\t\tScanner s = new Scanner(System.in);\n\t\t// keep taking user input until user inputs -1\n\t\tint data = s.nextInt();\n\t\t// return the head\n\t\tLinkedListNodeClass<Integer> head = null;\n\t\twhile(data != -1) {\n\t\t\tLinkedListNodeClass<Integer> currentNode = new LinkedListNodeClass<Integer>(data);\n\t\t\t// check if head is null to assign head node\n\t\t\tif(head == null) {\n\t\t\t\thead = currentNode;\n\t\t\t}else {\n\t\t\t\t// create the connection to the next node\n\t\t\t\tLinkedListNodeClass<Integer> tail = head;\n\t\t\t\twhile(tail.next != null) {\n\t\t\t\t\ttail = tail.next;\n\t\t\t\t}\n\t\t\t\t// tail will reference last node\n\t\t\t\t// connect current node after last node\n\t\t\t\ttail.next = currentNode;\n\t\t\t}\n\t\t\tdata = s.nextInt();\n\t\t}\n\t\treturn head;\n\t}\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\t\n\t\tLinkedListNodeClass<Integer> head = takeInput();\n\t\t\n\t\t\n\t\t\n\n\t}\n\n}\n"
        }
      ]
    }
  ]
}